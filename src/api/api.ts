/**
 * SGM-MUSIC-API
 * SGM-MUSIC-API
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

 import * as querystring from 'querystring';
 import * as url from 'url';
 
 import * as isomorphicFetch from 'isomorphic-fetch';
 import * as assign from 'core-js/library/fn/object/assign';
 
 interface Dictionary<T> {
	 [index: string]: T;
 }
 export interface FetchAPI {
	 (url: string, init?: any): Promise<any>;
 }
 
 const basePath = process.env.basePathApi;
 export const BAs3_T0k3n = process.env.bAs3_T0k3n;
 export const BASE_PATH = basePath.replace(/\/+$/, '');
 export interface FetchArgs {
	 url: string;
	 options: any;
 }
 
 export class BaseAPI {
	 basePath: string;
	 fetch: FetchAPI;
 
	 constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
		 this.basePath = basePath;
		 this.fetch = fetch;
	 }
 }
 
 export interface AccessToken {
	 id: string;
	 /**
	  * time to live in seconds (2 weeks by default)
	  */
	 ttl?: number;
	 /**
	  * Array of scopes granted to this access token.
	  */
	 scopes?: Array<string>;
	 created?: Date;
	 userId?: number;
 }
 
 export interface Account {
	 id: string;
	 firstName?: string;
	 lastName?: string;
	 companyName?: string;
	 dateOfBirth?: Date;
	 kind?: string;
	 sex?: boolean;
	 avatar?: string;
	 address?: string;
	 country?: string;
	 numberOrder?: number;
	 businessTypeString?: string;
	 realm?: string;
	 username?: string;
	 email: string;
	 emailVerified?: boolean;
	 createdAt?: Date;
	 updatedAt?: Date;
	 businessTypeId?: number;
 }
 
 export interface AccountPlaylist {
	 id?: number;
	 accountId?: string;
	 playlistId?: number;
 }
 
 export interface AccountProject {
	 id?: number;
	 accountId?: string;
	 projectId?: number;
 }
 
 export interface AccountSubscription {
	 des?: string;
	 id?: number;
	 accountId?: string;
	 subscriptionId?: number;
 }
 
 export interface AccountToken {
	 id: string;
	 /**
	  * time to live in seconds (2 weeks by default)
	  */
	 ttl?: number;
	 /**
	  * Array of scopes granted to this access token.
	  */
	 scopes?: Array<string>;
	 created?: Date;
	 userId?: string;
	 createdAt?: Date;
	 updatedAt?: Date;
 }
 
 export interface Artist {
	 name?: string;
	 des?: string;
	 avatar?: string;
	 id?: number;
 }
 
 export interface Bill {
	 paymentType?: string;
	 totalPrice?: string;
	 note?: string;
	 id?: number;
 }
 
 export interface BusinessType {
	 type?: string;
	 des?: string;
	 id?: number;
 }
 
 export interface Cart {
	 isVatRemoved?: boolean;
	 id?: number;
	 accountId?: string;
 }
 
 export interface ComposeTrack {
	 author?: string;
	 des?: string;
	 id?: number;
	 accountId?: string;
	 trackId?: number;
 }
 
 export interface Download {
	 des?: string;
	 id?: number;
	 listenersId?: string;
	 trackDownloadId?: number;
	 createdAt?: Date;
	 updatedAt?: Date;
 }
 
 export interface Feature {
	 tag?: string;
	 slug?: string;
	 id?: number;
	 accountId?: string;
 }
 
 export interface Genre {
	 slug?: string;
	 tag?: string;
	 coverImage?: string;
	 soundEffect?: boolean;
	 id?: number;
	 fatherGenreId?: number;
	 accountId?: string;
	 createdAt?: Date;
	 updatedAt?: Date;
 }
 
 export interface InlineResponse200 {
	 count?: number;
 }
 
 export interface InlineResponse2001 {
	 exists?: boolean;
 }
 
 /**
  * Information related to the outcome of the operation
  */
 export interface InlineResponse2002 {
	 /**
	  * The number of instances updated
	  */
	 count?: number;
 }
 
 export interface InlineResponse2003 {
	 undefined?: any;
 }
 
 export interface InlineResponse2004 {
	 result?: any;
 }
 
 export interface Mood {
	 tag?: string;
	 slug?: string;
	 coverImage?: string;
	 id?: number;
	 accountId?: string;
	 createdAt?: Date;
	 updatedAt?: Date;
 }
 
 export interface Playlist {
	 name?: string;
	 id?: number;
	 projectId?: number;
 }
 
 export interface Price {
	 price?: number;
	 type?: string;
	 des?: string;
	 id?: number;
	 accountId?: string;
	 createdAt?: Date;
	 updatedAt?: Date;
 }
 
 export interface Project {
	 name?: string;
	 des?: string;
	 id?: number;
 }
 
 export interface Role {
	 id?: number;
	 name: string;
	 description?: string;
	 created?: Date;
	 modified?: Date;
 }
 
 /**
  * Map principals to roles
  */
 export interface RoleMapping {
	 id?: number;
	 /**
	  * The principal type, such as USER, APPLICATION, ROLE, or user model name in case of multiple user models
	  */
	 principalType?: string;
	 principalId?: string;
	 roleId?: number;
 }
 
 export interface Subscription {
	 type?: string;
	 tracks?: number;
	 soundEffect?: number;
	 firstMonth?: boolean;
	 social?: boolean;
	 onlinePlatform?: boolean;
	 websites?: boolean;
	 digitalAds?: boolean;
	 tV?: boolean;
	 streaming?: boolean;
	 multipleAccount?: boolean;
	 coverageChannel?: boolean;
	 coverageBusiness?: boolean;
	 curation?: boolean;
	 customizedProductions?: boolean;
	 customerSuccessManager?: boolean;
	 pricePerMonth?: number;
	 pricePerYear?: number;
	 id?: number;
	 createrId?: string;
	 accountId?: string;
	 createdAt?: Date;
	 updatedAt?: Date;
 }
 
 export interface Tag {
	 des?: string;
	 id?: number;
 }
 
 export interface Track {
	 name?: string;
	 thumb?: string;
	 file?: string;
	 type?: string;
	 typeMusic?: string;
	 id?: number;
	 createdAt?: Date;
	 updatedAt?: Date;
	 cartId?: number;
 }
 
 export interface TrackGenre {
	 des?: string;
	 enable?: boolean;
	 id?: number;
	 trackId?: number;
	 genreId?: number;
 }
 
 export interface TrackInCart {
	 des?: string;
	 id?: number;
	 trackId?: number;
	 cartId?: number;
 }
 
 export interface TrackInPlaylist {
	 des?: string;
	 id?: number;
	 trackId?: number;
	 playlistId?: number;
 }
 
 export interface TrackMood {
	 des?: string;
	 enable?: boolean;
	 id?: number;
	 trackId?: number;
	 moodId?: number;
 }
 
 export interface User {
	 realm?: string;
	 username?: string;
	 email: string;
	 emailVerified?: boolean;
	 id?: number;
 }
 
 /**
  * AccountApi - fetch parameter creator
  */
 export const AccountApiFetchParamCreator = {
	 /**
	  *
	  * @summary Change a user's password.
	  * @param oldPassword
	  * @param newPassword
	  */
	 accountChangePassword(
		 params: { oldPassword: string; newPassword: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "oldPassword" is set
		 if (params['oldPassword'] == null) {
			 throw new Error('Missing required parameter oldPassword when calling accountChangePassword');
		 }
		 // verify required parameter "newPassword" is set
		 if (params['newPassword'] == null) {
			 throw new Error('Missing required parameter newPassword when calling accountChangePassword');
		 }
		 const baseUrl = `/Accounts/change-password`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 oldPassword: params['oldPassword'],
			 newPassword: params['newPassword'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Confirm a user registration with identity verification token.
	  * @param uid
	  * @param token
	  * @param redirect
	  */
	 accountConfirm(
		 params: { uid: string; token: string; redirect?: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "uid" is set
		 if (params['uid'] == null) {
			 throw new Error('Missing required parameter uid when calling accountConfirm');
		 }
		 // verify required parameter "token" is set
		 if (params['token'] == null) {
			 throw new Error('Missing required parameter token when calling accountConfirm');
		 }
		 const baseUrl = `/Accounts/confirm`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 uid: params['uid'],
			 token: params['token'],
			 redirect: params['redirect'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Accounts/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountCreate(params: { data?: Account }, options?: any): FetchArgs {
		 const baseUrl = `/Accounts`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountCreateChangeStreamGetAccountsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Accounts/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountCreateChangeStreamPostAccountsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Accounts/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountDeleteById');
		 }
		 const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountExistsGetAccountsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountExistsGetAccountsidExists'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountExistsHeadAccountsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountExistsHeadAccountsid');
		 }
		 const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Accounts`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountFindById');
		 }
		 const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Accounts/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Login a user with username/email and password.
	  * @param credentials
	  * @param include Related objects to include in the response. See the description of return value for more details.
	  */
	 accountLogin(params: { credentials: any; include?: string }, options?: any): FetchArgs {
		 // verify required parameter "credentials" is set
		 if (params['credentials'] == null) {
			 throw new Error('Missing required parameter credentials when calling accountLogin');
		 }
		 const baseUrl = `/Accounts/login`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 include: params['include'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['credentials']) {
			 fetchOptions.body = JSON.stringify(params['credentials'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Logout a user with access token.
	  */
	 accountLogout(options?: any): FetchArgs {
		 const baseUrl = `/Accounts/logout`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPatchOrCreate(params: { data?: Account }, options?: any): FetchArgs {
		 const baseUrl = `/Accounts`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts accessTokens of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountAccessTokens(
		 params: { id: string; where?: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeCountAccessTokens'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/accessTokens/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts composes of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountComposes(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCountComposes');
		 }
		 const baseUrl = `/Accounts/{id}/composes/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts downloads of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountDownloads(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCountDownloads');
		 }
		 const baseUrl = `/Accounts/{id}/downloads/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts feature of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountFeature(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCountFeature');
		 }
		 const baseUrl = `/Accounts/{id}/feature/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts genre of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountGenre(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCountGenre');
		 }
		 const baseUrl = `/Accounts/{id}/genre/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts makeSubscription of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountMakeSubscription(
		 params: { id: string; where?: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeCountMakeSubscription'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/makeSubscription/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts mood of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountMood(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCountMood');
		 }
		 const baseUrl = `/Accounts/{id}/mood/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts playlist of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountPlaylist(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCountPlaylist');
		 }
		 const baseUrl = `/Accounts/{id}/playlist/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts price of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountPrice(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCountPrice');
		 }
		 const baseUrl = `/Accounts/{id}/price/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts project of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountProject(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCountProject');
		 }
		 const baseUrl = `/Accounts/{id}/project/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts roles of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountRoles(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCountRoles');
		 }
		 const baseUrl = `/Accounts/{id}/roles/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in accessTokens of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateAccessTokens(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeCreateAccessTokens'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in cart of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateCart(params: { id: string; data?: Cart }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreateCart');
		 }
		 const baseUrl = `/Accounts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in composes of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateComposes(params: { id: string; data?: Track }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreateComposes');
		 }
		 const baseUrl = `/Accounts/{id}/composes`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in downloads of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateDownloads(params: { id: string; data?: Track }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreateDownloads');
		 }
		 const baseUrl = `/Accounts/{id}/downloads`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in feature of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateFeature(params: { id: string; data?: Feature }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreateFeature');
		 }
		 const baseUrl = `/Accounts/{id}/feature`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in genre of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateGenre(params: { id: string; data?: Genre }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreateGenre');
		 }
		 const baseUrl = `/Accounts/{id}/genre`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in makeSubscription of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateMakeSubscription(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeCreateMakeSubscription'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/makeSubscription`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in mood of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateMood(params: { id: string; data?: Mood }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreateMood');
		 }
		 const baseUrl = `/Accounts/{id}/mood`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in playlist of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreatePlaylist(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreatePlaylist');
		 }
		 const baseUrl = `/Accounts/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in price of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreatePrice(params: { id: string; data?: Price }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreatePrice');
		 }
		 const baseUrl = `/Accounts/{id}/price`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in project of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateProject(params: { id: string; data?: Project }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreateProject');
		 }
		 const baseUrl = `/Accounts/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in roles of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateRoles(params: { id: string; data?: Role }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeCreateRoles');
		 }
		 const baseUrl = `/Accounts/{id}/roles`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all accessTokens of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteAccessTokens(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDeleteAccessTokens'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all composes of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteComposes(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDeleteComposes');
		 }
		 const baseUrl = `/Accounts/{id}/composes`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all downloads of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteDownloads(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDeleteDownloads');
		 }
		 const baseUrl = `/Accounts/{id}/downloads`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all feature of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteFeature(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDeleteFeature');
		 }
		 const baseUrl = `/Accounts/{id}/feature`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all genre of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteGenre(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDeleteGenre');
		 }
		 const baseUrl = `/Accounts/{id}/genre`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all makeSubscription of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteMakeSubscription(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDeleteMakeSubscription'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/makeSubscription`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all mood of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteMood(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDeleteMood');
		 }
		 const baseUrl = `/Accounts/{id}/mood`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all playlist of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeletePlaylist(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDeletePlaylist');
		 }
		 const baseUrl = `/Accounts/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all price of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeletePrice(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDeletePrice');
		 }
		 const baseUrl = `/Accounts/{id}/price`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all project of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteProject(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDeleteProject');
		 }
		 const baseUrl = `/Accounts/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all roles of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteRoles(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDeleteRoles');
		 }
		 const baseUrl = `/Accounts/{id}/roles`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for accessTokens.
	  * @param id Account id
	  * @param fk Foreign key for accessTokens
	  */
	 accountPrototypeDestroyByIdAccessTokens(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeDestroyByIdComposes(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdComposes'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdComposes'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/composes/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeDestroyByIdDownloads(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdDownloads'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdDownloads'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/downloads/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for feature.
	  * @param id Account id
	  * @param fk Foreign key for feature
	  */
	 accountPrototypeDestroyByIdFeature(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdFeature'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdFeature'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/feature/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for genre.
	  * @param id Account id
	  * @param fk Foreign key for genre
	  */
	 accountPrototypeDestroyByIdGenre(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdGenre'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdGenre'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/genre/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for makeSubscription.
	  * @param id Account id
	  * @param fk Foreign key for makeSubscription
	  */
	 accountPrototypeDestroyByIdMakeSubscription(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdMakeSubscription'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdMakeSubscription'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/makeSubscription/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for mood.
	  * @param id Account id
	  * @param fk Foreign key for mood
	  */
	 accountPrototypeDestroyByIdMood(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdMood');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdMood');
		 }
		 const baseUrl = `/Accounts/{id}/mood/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeDestroyByIdPlaylist(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdPlaylist'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdPlaylist'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/playlist/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for price.
	  * @param id Account id
	  * @param fk Foreign key for price
	  */
	 accountPrototypeDestroyByIdPrice(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdPrice'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdPrice'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/price/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeDestroyByIdProject(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdProject'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdProject'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/project/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeDestroyByIdRoles(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeDestroyByIdRoles'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeDestroyByIdRoles'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/roles/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes cart of this model.
	  * @param id Account id
	  */
	 accountPrototypeDestroyCart(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeDestroyCart');
		 }
		 const baseUrl = `/Accounts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of composes relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeExistsComposes(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeExistsComposes');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeExistsComposes');
		 }
		 const baseUrl = `/Accounts/{id}/composes/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of downloads relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeExistsDownloads(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeExistsDownloads');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeExistsDownloads');
		 }
		 const baseUrl = `/Accounts/{id}/downloads/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of playlist relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeExistsPlaylist(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeExistsPlaylist');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeExistsPlaylist');
		 }
		 const baseUrl = `/Accounts/{id}/playlist/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of project relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeExistsProject(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeExistsProject');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeExistsProject');
		 }
		 const baseUrl = `/Accounts/{id}/project/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of roles relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeExistsRoles(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeExistsRoles');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeExistsRoles');
		 }
		 const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for accessTokens.
	  * @param id Account id
	  * @param fk Foreign key for accessTokens
	  */
	 accountPrototypeFindByIdAccessTokens(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeFindByIdAccessTokens'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeFindByIdComposes(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeFindByIdComposes'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeFindByIdComposes'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/composes/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeFindByIdDownloads(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeFindByIdDownloads'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeFindByIdDownloads'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/downloads/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for feature.
	  * @param id Account id
	  * @param fk Foreign key for feature
	  */
	 accountPrototypeFindByIdFeature(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeFindByIdFeature');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdFeature');
		 }
		 const baseUrl = `/Accounts/{id}/feature/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for genre.
	  * @param id Account id
	  * @param fk Foreign key for genre
	  */
	 accountPrototypeFindByIdGenre(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeFindByIdGenre');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdGenre');
		 }
		 const baseUrl = `/Accounts/{id}/genre/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for makeSubscription.
	  * @param id Account id
	  * @param fk Foreign key for makeSubscription
	  */
	 accountPrototypeFindByIdMakeSubscription(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeFindByIdMakeSubscription'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeFindByIdMakeSubscription'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/makeSubscription/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for mood.
	  * @param id Account id
	  * @param fk Foreign key for mood
	  */
	 accountPrototypeFindByIdMood(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeFindByIdMood');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdMood');
		 }
		 const baseUrl = `/Accounts/{id}/mood/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeFindByIdPlaylist(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeFindByIdPlaylist'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeFindByIdPlaylist'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/playlist/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for price.
	  * @param id Account id
	  * @param fk Foreign key for price
	  */
	 accountPrototypeFindByIdPrice(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeFindByIdPrice');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdPrice');
		 }
		 const baseUrl = `/Accounts/{id}/price/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeFindByIdProject(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeFindByIdProject');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdProject');
		 }
		 const baseUrl = `/Accounts/{id}/project/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeFindByIdRoles(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeFindByIdRoles');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdRoles');
		 }
		 const baseUrl = `/Accounts/{id}/roles/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries accessTokens of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetAccessTokens(
		 params: { id: string; filter?: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetAccessTokens');
		 }
		 const baseUrl = `/Accounts/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation businessType.
	  * @param id Account id
	  * @param refresh
	  */
	 accountPrototypeGetBusinessType(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetBusinessType');
		 }
		 const baseUrl = `/Accounts/{id}/businessType`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches hasOne relation cart.
	  * @param id Account id
	  * @param refresh
	  */
	 accountPrototypeGetCart(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetCart');
		 }
		 const baseUrl = `/Accounts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries composes of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetComposes(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetComposes');
		 }
		 const baseUrl = `/Accounts/{id}/composes`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries downloads of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetDownloads(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetDownloads');
		 }
		 const baseUrl = `/Accounts/{id}/downloads`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries feature of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetFeature(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetFeature');
		 }
		 const baseUrl = `/Accounts/{id}/feature`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries genre of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetGenre(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetGenre');
		 }
		 const baseUrl = `/Accounts/{id}/genre`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries makeSubscription of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetMakeSubscription(
		 params: { id: string; filter?: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeGetMakeSubscription'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/makeSubscription`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries mood of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetMood(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetMood');
		 }
		 const baseUrl = `/Accounts/{id}/mood`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries playlist of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetPlaylist(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetPlaylist');
		 }
		 const baseUrl = `/Accounts/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries price of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetPrice(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetPrice');
		 }
		 const baseUrl = `/Accounts/{id}/price`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries project of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetProject(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetProject');
		 }
		 const baseUrl = `/Accounts/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries roles of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetRoles(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeGetRoles');
		 }
		 const baseUrl = `/Accounts/{id}/roles`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  * @param data
	  */
	 accountPrototypeLinkComposes(
		 params: { id: string; fk: string; data?: ComposeTrack },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeLinkComposes');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeLinkComposes');
		 }
		 const baseUrl = `/Accounts/{id}/composes/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  * @param data
	  */
	 accountPrototypeLinkDownloads(
		 params: { id: string; fk: string; data?: Download },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeLinkDownloads');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeLinkDownloads');
		 }
		 const baseUrl = `/Accounts/{id}/downloads/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 accountPrototypeLinkPlaylist(
		 params: { id: string; fk: string; data?: AccountPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeLinkPlaylist');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeLinkPlaylist');
		 }
		 const baseUrl = `/Accounts/{id}/playlist/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  * @param data
	  */
	 accountPrototypeLinkProject(
		 params: { id: string; fk: string; data?: AccountProject },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeLinkProject');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeLinkProject');
		 }
		 const baseUrl = `/Accounts/{id}/project/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  * @param data
	  */
	 accountPrototypeLinkRoles(
		 params: { id: string; fk: string; data?: RoleMapping },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeLinkRoles');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeLinkRoles');
		 }
		 const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Account id
	  * @param data An object of model property name/value pairs
	  */
	 accountPrototypePatchAttributes(
		 params: { id: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypePatchAttributes');
		 }
		 const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the composes relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeUnlinkComposes(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUnlinkComposes');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkComposes');
		 }
		 const baseUrl = `/Accounts/{id}/composes/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the downloads relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeUnlinkDownloads(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUnlinkDownloads');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkDownloads');
		 }
		 const baseUrl = `/Accounts/{id}/downloads/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the playlist relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeUnlinkPlaylist(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUnlinkPlaylist');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkPlaylist');
		 }
		 const baseUrl = `/Accounts/{id}/playlist/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the project relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeUnlinkProject(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUnlinkProject');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkProject');
		 }
		 const baseUrl = `/Accounts/{id}/project/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the roles relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeUnlinkRoles(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUnlinkRoles');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkRoles');
		 }
		 const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for accessTokens.
	  * @param id Account id
	  * @param fk Foreign key for accessTokens
	  * @param data
	  */
	 accountPrototypeUpdateByIdAccessTokens(
		 params: { id: string; fk: string; data?: AccountToken },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  * @param data
	  */
	 accountPrototypeUpdateByIdComposes(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeUpdateByIdComposes'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeUpdateByIdComposes'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/composes/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  * @param data
	  */
	 accountPrototypeUpdateByIdDownloads(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeUpdateByIdDownloads'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeUpdateByIdDownloads'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/downloads/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for feature.
	  * @param id Account id
	  * @param fk Foreign key for feature
	  * @param data
	  */
	 accountPrototypeUpdateByIdFeature(
		 params: { id: string; fk: string; data?: Feature },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeUpdateByIdFeature'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeUpdateByIdFeature'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/feature/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for genre.
	  * @param id Account id
	  * @param fk Foreign key for genre
	  * @param data
	  */
	 accountPrototypeUpdateByIdGenre(
		 params: { id: string; fk: string; data?: Genre },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdGenre');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdGenre');
		 }
		 const baseUrl = `/Accounts/{id}/genre/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for makeSubscription.
	  * @param id Account id
	  * @param fk Foreign key for makeSubscription
	  * @param data
	  */
	 accountPrototypeUpdateByIdMakeSubscription(
		 params: { id: string; fk: string; data?: Subscription },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeUpdateByIdMakeSubscription'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeUpdateByIdMakeSubscription'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/makeSubscription/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for mood.
	  * @param id Account id
	  * @param fk Foreign key for mood
	  * @param data
	  */
	 accountPrototypeUpdateByIdMood(
		 params: { id: string; fk: string; data?: Mood },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdMood');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdMood');
		 }
		 const baseUrl = `/Accounts/{id}/mood/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 accountPrototypeUpdateByIdPlaylist(
		 params: { id: string; fk: string; data?: Playlist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeUpdateByIdPlaylist'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeUpdateByIdPlaylist'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/playlist/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for price.
	  * @param id Account id
	  * @param fk Foreign key for price
	  * @param data
	  */
	 accountPrototypeUpdateByIdPrice(
		 params: { id: string; fk: string; data?: Price },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdPrice');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdPrice');
		 }
		 const baseUrl = `/Accounts/{id}/price/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  * @param data
	  */
	 accountPrototypeUpdateByIdProject(
		 params: { id: string; fk: string; data?: Project },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPrototypeUpdateByIdProject'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling accountPrototypeUpdateByIdProject'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/project/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  * @param data
	  */
	 accountPrototypeUpdateByIdRoles(
		 params: { id: string; fk: string; data?: Role },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdRoles');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdRoles');
		 }
		 const baseUrl = `/Accounts/{id}/roles/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update cart of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeUpdateCart(params: { id: string; data?: Cart }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeUpdateCart');
		 }
		 const baseUrl = `/Accounts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Trigger user's identity verification with configured verifyOptions
	  * @param id Account id
	  */
	 accountPrototypeVerify(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPrototypeVerify');
		 }
		 const baseUrl = `/Accounts/{id}/verify`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountReplaceByIdPostAccountsidReplace(
		 params: { id: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace'
			 );
		 }
		 const baseUrl = `/Accounts/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountReplaceByIdPutAccountsid(
		 params: { id: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountReplaceByIdPutAccountsid');
		 }
		 const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountReplaceOrCreatePostAccountsReplaceOrCreate(
		 params: { data?: Account },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Accounts/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountReplaceOrCreatePutAccounts(params: { data?: Account }, options?: any): FetchArgs {
		 const baseUrl = `/Accounts`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Reset password for a user with email.
	  * @param options
	  */
	 accountResetPassword(params: { options: any }, options?: any): FetchArgs {
		 // verify required parameter "options" is set
		 if (params['options'] == null) {
			 throw new Error('Missing required parameter options when calling accountResetPassword');
		 }
		 const baseUrl = `/Accounts/reset`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['options']) {
			 fetchOptions.body = JSON.stringify(params['options'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Reset user's password via a password-reset token.
	  * @param newPassword
	  */
	 accountSetPassword(params: { newPassword: string }, options?: any): FetchArgs {
		 // verify required parameter "newPassword" is set
		 if (params['newPassword'] == null) {
			 throw new Error('Missing required parameter newPassword when calling accountSetPassword');
		 }
		 const baseUrl = `/Accounts/reset-password`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 newPassword: params['newPassword'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountUpdateAll(params: { where?: string; data?: Account }, options?: any): FetchArgs {
		 const baseUrl = `/Accounts/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountUpsertWithWhere(params: { where?: string; data?: Account }, options?: any): FetchArgs {
		 const baseUrl = `/Accounts/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * AccountApi - functional programming interface
  */
 export const AccountApiFp = {
	 /**
	  *
	  * @summary Change a user's password.
	  * @param oldPassword
	  * @param newPassword
	  */
	 accountChangePassword(
		 params: { oldPassword: string; newPassword: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountChangePassword(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Confirm a user registration with identity verification token.
	  * @param uid
	  * @param token
	  * @param redirect
	  */
	 accountConfirm(
		 params: { uid: string; token: string; redirect?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountConfirm(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountCreate(
		 params: { data?: any },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountCreateChangeStreamGetAccountsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountCreateChangeStreamPostAccountsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountExistsGetAccountsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountExistsHeadAccountsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Login a user with username/email and password.
	  * @param credentials
	  * @param include Related objects to include in the response. See the description of return value for more details.
	  */
	 accountLogin(
		 params: { credentials: any; include?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountLogin(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Logout a user with access token.
	  */
	 accountLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountLogout(options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPatchOrCreate(
		 params: { data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts accessTokens of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountAccessTokens(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts composes of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountComposes(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountComposes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts downloads of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountDownloads(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountDownloads(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts feature of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountFeature(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountFeature(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts genre of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountGenre(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountGenre(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts makeSubscription of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountMakeSubscription(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountMakeSubscription(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts mood of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountMood(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountMood(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts playlist of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountPlaylist(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts price of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountPrice(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountPrice(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts project of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountProject(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountProject(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts roles of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountRoles(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in accessTokens of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateAccessTokens(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in cart of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateCart(
		 params: { id: string; data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in composes of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateComposes(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateComposes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in downloads of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateDownloads(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateDownloads(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in feature of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateFeature(
		 params: { id: string; data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateFeature(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in genre of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateGenre(
		 params: { id: string; data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateGenre(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in makeSubscription of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateMakeSubscription(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateMakeSubscription(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in mood of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateMood(
		 params: { id: string; data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateMood(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in playlist of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreatePlaylist(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreatePlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in price of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreatePrice(
		 params: { id: string; data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreatePrice(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in project of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateProject(
		 params: { id: string; data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateProject(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in roles of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateRoles(
		 params: { id: string; data?: Role },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all accessTokens of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteAccessTokens(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all composes of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteComposes(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteComposes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all downloads of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteDownloads(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteDownloads(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all feature of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteFeature(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteFeature(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all genre of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteGenre(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteGenre(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all makeSubscription of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteMakeSubscription(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteMakeSubscription(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all mood of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteMood(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteMood(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all playlist of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeletePlaylist(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeletePlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all price of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeletePrice(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeletePrice(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all project of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteProject(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteProject(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all roles of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteRoles(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for accessTokens.
	  * @param id Account id
	  * @param fk Foreign key for accessTokens
	  */
	 accountPrototypeDestroyByIdAccessTokens(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeDestroyByIdComposes(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdComposes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeDestroyByIdDownloads(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdDownloads(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for feature.
	  * @param id Account id
	  * @param fk Foreign key for feature
	  */
	 accountPrototypeDestroyByIdFeature(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdFeature(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for genre.
	  * @param id Account id
	  * @param fk Foreign key for genre
	  */
	 accountPrototypeDestroyByIdGenre(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdGenre(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for makeSubscription.
	  * @param id Account id
	  * @param fk Foreign key for makeSubscription
	  */
	 accountPrototypeDestroyByIdMakeSubscription(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdMakeSubscription(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for mood.
	  * @param id Account id
	  * @param fk Foreign key for mood
	  */
	 accountPrototypeDestroyByIdMood(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdMood(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeDestroyByIdPlaylist(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdPlaylist(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for price.
	  * @param id Account id
	  * @param fk Foreign key for price
	  */
	 accountPrototypeDestroyByIdPrice(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdPrice(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeDestroyByIdProject(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdProject(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeDestroyByIdRoles(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes cart of this model.
	  * @param id Account id
	  */
	 accountPrototypeDestroyCart(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of composes relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeExistsComposes(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsComposes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of downloads relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeExistsDownloads(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsDownloads(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of playlist relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeExistsPlaylist(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of project relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeExistsProject(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsProject(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of roles relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeExistsRoles(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for accessTokens.
	  * @param id Account id
	  * @param fk Foreign key for accessTokens
	  */
	 accountPrototypeFindByIdAccessTokens(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeFindByIdComposes(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdComposes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeFindByIdDownloads(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdDownloads(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for feature.
	  * @param id Account id
	  * @param fk Foreign key for feature
	  */
	 accountPrototypeFindByIdFeature(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdFeature(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for genre.
	  * @param id Account id
	  * @param fk Foreign key for genre
	  */
	 accountPrototypeFindByIdGenre(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdGenre(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for makeSubscription.
	  * @param id Account id
	  * @param fk Foreign key for makeSubscription
	  */
	 accountPrototypeFindByIdMakeSubscription(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdMakeSubscription(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for mood.
	  * @param id Account id
	  * @param fk Foreign key for mood
	  */
	 accountPrototypeFindByIdMood(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdMood(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeFindByIdPlaylist(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for price.
	  * @param id Account id
	  * @param fk Foreign key for price
	  */
	 accountPrototypeFindByIdPrice(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdPrice(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeFindByIdProject(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdProject(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeFindByIdRoles(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries accessTokens of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetAccessTokens(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountToken>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation businessType.
	  * @param id Account id
	  * @param refresh
	  */
	 accountPrototypeGetBusinessType(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetBusinessType(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches hasOne relation cart.
	  * @param id Account id
	  * @param refresh
	  */
	 accountPrototypeGetCart(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries composes of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetComposes(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetComposes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries downloads of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetDownloads(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetDownloads(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries feature of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetFeature(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Feature>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetFeature(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries genre of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetGenre(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Genre>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetGenre(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries makeSubscription of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetMakeSubscription(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Subscription>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetMakeSubscription(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries mood of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetMood(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Mood>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetMood(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries playlist of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetPlaylist(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Playlist>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries price of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetPrice(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Price>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetPrice(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries project of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetProject(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Project>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetProject(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries roles of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetRoles(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Role>> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  * @param data
	  */
	 accountPrototypeLinkComposes(
		 params: { id: string; fk: string; data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkComposes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  * @param data
	  */
	 accountPrototypeLinkDownloads(
		 params: { id: string; fk: string; data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkDownloads(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 accountPrototypeLinkPlaylist(
		 params: { id: string; fk: string; data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  * @param data
	  */
	 accountPrototypeLinkProject(
		 params: { id: string; fk: string; data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkProject(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  * @param data
	  */
	 accountPrototypeLinkRoles(
		 params: { id: string; fk: string; data?: RoleMapping },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Account id
	  * @param data An object of model property name/value pairs
	  */
	 accountPrototypePatchAttributes(
		 params: { id: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the composes relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeUnlinkComposes(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkComposes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the downloads relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeUnlinkDownloads(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkDownloads(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the playlist relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeUnlinkPlaylist(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the project relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeUnlinkProject(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkProject(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the roles relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeUnlinkRoles(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for accessTokens.
	  * @param id Account id
	  * @param fk Foreign key for accessTokens
	  * @param data
	  */
	 accountPrototypeUpdateByIdAccessTokens(
		 params: { id: string; fk: string; data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  * @param data
	  */
	 accountPrototypeUpdateByIdComposes(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdComposes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  * @param data
	  */
	 accountPrototypeUpdateByIdDownloads(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdDownloads(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for feature.
	  * @param id Account id
	  * @param fk Foreign key for feature
	  * @param data
	  */
	 accountPrototypeUpdateByIdFeature(
		 params: { id: string; fk: string; data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdFeature(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for genre.
	  * @param id Account id
	  * @param fk Foreign key for genre
	  * @param data
	  */
	 accountPrototypeUpdateByIdGenre(
		 params: { id: string; fk: string; data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdGenre(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for makeSubscription.
	  * @param id Account id
	  * @param fk Foreign key for makeSubscription
	  * @param data
	  */
	 accountPrototypeUpdateByIdMakeSubscription(
		 params: { id: string; fk: string; data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdMakeSubscription(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for mood.
	  * @param id Account id
	  * @param fk Foreign key for mood
	  * @param data
	  */
	 accountPrototypeUpdateByIdMood(
		 params: { id: string; fk: string; data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdMood(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 accountPrototypeUpdateByIdPlaylist(
		 params: { id: string; fk: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdPlaylist(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for price.
	  * @param id Account id
	  * @param fk Foreign key for price
	  * @param data
	  */
	 accountPrototypeUpdateByIdPrice(
		 params: { id: string; fk: string; data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdPrice(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  * @param data
	  */
	 accountPrototypeUpdateByIdProject(
		 params: { id: string; fk: string; data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdProject(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  * @param data
	  */
	 accountPrototypeUpdateByIdRoles(
		 params: { id: string; fk: string; data?: Role },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdRoles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update cart of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeUpdateCart(
		 params: { id: string; data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Trigger user's identity verification with configured verifyOptions
	  * @param id Account id
	  */
	 accountPrototypeVerify(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountReplaceByIdPostAccountsidReplace(
		 params: { id: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountReplaceByIdPutAccountsid(
		 params: { id: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountReplaceOrCreatePostAccountsReplaceOrCreate(
		 params: { data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountReplaceOrCreatePutAccounts(
		 params: { data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Reset password for a user with email.
	  * @param options
	  */
	 accountResetPassword(
		 params: { options: any },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountResetPassword(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Reset user's password via a password-reset token.
	  * @param newPassword
	  */
	 accountSetPassword(
		 params: { newPassword: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountApiFetchParamCreator.accountSetPassword(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountUpdateAll(
		 params: { where?: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = AccountApiFetchParamCreator.accountUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountUpsertWithWhere(
		 params: { where?: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * AccountApi - object-oriented interface
  */
 export class AccountApi extends BaseAPI {
	 /**
	  *
	  * @summary Change a user's password.
	  * @param oldPassword
	  * @param newPassword
	  */
	 accountChangePassword(params: { oldPassword: string; newPassword: string }, options?: any) {
		 return AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Confirm a user registration with identity verification token.
	  * @param uid
	  * @param token
	  * @param redirect
	  */
	 accountConfirm(params: { uid: string; token: string; redirect?: string }, options?: any) {
		 return AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountCount(params: { where?: string }, options?: any) {
		 return AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountCreate(params: { data?: Account }, options?: any) {
		 return AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountCreateChangeStreamGetAccountsChangeStream(params: { options?: string }, options?: any) {
		 return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountCreateChangeStreamPostAccountsChangeStream(params: { options?: string }, options?: any) {
		 return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountDeleteById(params: { id: string }, options?: any) {
		 return AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountExistsGetAccountsidExists(params: { id: string }, options?: any) {
		 return AccountApiFp.accountExistsGetAccountsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountExistsHeadAccountsid(params: { id: string }, options?: any) {
		 return AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountFind(params: { filter?: string }, options?: any) {
		 return AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountFindById(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountFindOne(params: { filter?: string }, options?: any) {
		 return AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Login a user with username/email and password.
	  * @param credentials
	  * @param include Related objects to include in the response. See the description of return value for more details.
	  */
	 accountLogin(params: { credentials: any; include?: string }, options?: any) {
		 return AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Logout a user with access token.
	  */
	 accountLogout(options?: any) {
		 return AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPatchOrCreate(params: { data?: Account }, options?: any) {
		 return AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts accessTokens of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountAccessTokens(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Counts composes of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountComposes(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountComposes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts downloads of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountDownloads(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountDownloads(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts feature of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountFeature(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountFeature(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts genre of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountGenre(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountGenre(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts makeSubscription of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountMakeSubscription(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountMakeSubscription(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Counts mood of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountMood(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountMood(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts playlist of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountPlaylist(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts price of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountPrice(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountPrice(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts project of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountProject(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountProject(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts roles of Account.
	  * @param id Account id
	  * @param where Criteria to match model instances
	  */
	 accountPrototypeCountRoles(params: { id: string; where?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeCountRoles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in accessTokens of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateAccessTokens(params: { id: string; data?: AccountToken }, options?: any) {
		 return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Creates a new instance in cart of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateCart(params: { id: string; data?: Cart }, options?: any) {
		 return AccountApiFp.accountPrototypeCreateCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in composes of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateComposes(params: { id: string; data?: Track }, options?: any) {
		 return AccountApiFp.accountPrototypeCreateComposes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in downloads of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateDownloads(params: { id: string; data?: Track }, options?: any) {
		 return AccountApiFp.accountPrototypeCreateDownloads(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in feature of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateFeature(params: { id: string; data?: Feature }, options?: any) {
		 return AccountApiFp.accountPrototypeCreateFeature(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in genre of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateGenre(params: { id: string; data?: Genre }, options?: any) {
		 return AccountApiFp.accountPrototypeCreateGenre(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in makeSubscription of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateMakeSubscription(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeCreateMakeSubscription(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Creates a new instance in mood of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateMood(params: { id: string; data?: Mood }, options?: any) {
		 return AccountApiFp.accountPrototypeCreateMood(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in playlist of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreatePlaylist(params: { id: string; data?: Playlist }, options?: any) {
		 return AccountApiFp.accountPrototypeCreatePlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in price of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreatePrice(params: { id: string; data?: Price }, options?: any) {
		 return AccountApiFp.accountPrototypeCreatePrice(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in project of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateProject(params: { id: string; data?: Project }, options?: any) {
		 return AccountApiFp.accountPrototypeCreateProject(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in roles of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeCreateRoles(params: { id: string; data?: Role }, options?: any) {
		 return AccountApiFp.accountPrototypeCreateRoles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all accessTokens of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteAccessTokens(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Deletes all composes of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteComposes(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeleteComposes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all downloads of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteDownloads(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeleteDownloads(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all feature of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteFeature(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeleteFeature(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all genre of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteGenre(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeleteGenre(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all makeSubscription of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteMakeSubscription(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeleteMakeSubscription(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Deletes all mood of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteMood(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeleteMood(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all playlist of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeletePlaylist(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeletePlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all price of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeletePrice(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeletePrice(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all project of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteProject(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeleteProject(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all roles of this model.
	  * @param id Account id
	  */
	 accountPrototypeDeleteRoles(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDeleteRoles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for accessTokens.
	  * @param id Account id
	  * @param fk Foreign key for accessTokens
	  */
	 accountPrototypeDestroyByIdAccessTokens(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeDestroyByIdComposes(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdComposes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeDestroyByIdDownloads(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdDownloads(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for feature.
	  * @param id Account id
	  * @param fk Foreign key for feature
	  */
	 accountPrototypeDestroyByIdFeature(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdFeature(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for genre.
	  * @param id Account id
	  * @param fk Foreign key for genre
	  */
	 accountPrototypeDestroyByIdGenre(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdGenre(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for makeSubscription.
	  * @param id Account id
	  * @param fk Foreign key for makeSubscription
	  */
	 accountPrototypeDestroyByIdMakeSubscription(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdMakeSubscription(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for mood.
	  * @param id Account id
	  * @param fk Foreign key for mood
	  */
	 accountPrototypeDestroyByIdMood(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdMood(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeDestroyByIdPlaylist(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdPlaylist(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for price.
	  * @param id Account id
	  * @param fk Foreign key for price
	  */
	 accountPrototypeDestroyByIdPrice(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdPrice(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeDestroyByIdProject(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdProject(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeDestroyByIdRoles(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Deletes cart of this model.
	  * @param id Account id
	  */
	 accountPrototypeDestroyCart(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeDestroyCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of composes relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeExistsComposes(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeExistsComposes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of downloads relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeExistsDownloads(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeExistsDownloads(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of playlist relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeExistsPlaylist(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeExistsPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of project relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeExistsProject(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeExistsProject(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of roles relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeExistsRoles(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeExistsRoles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for accessTokens.
	  * @param id Account id
	  * @param fk Foreign key for accessTokens
	  */
	 accountPrototypeFindByIdAccessTokens(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeFindByIdComposes(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdComposes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeFindByIdDownloads(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdDownloads(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a related item by id for feature.
	  * @param id Account id
	  * @param fk Foreign key for feature
	  */
	 accountPrototypeFindByIdFeature(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdFeature(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for genre.
	  * @param id Account id
	  * @param fk Foreign key for genre
	  */
	 accountPrototypeFindByIdGenre(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdGenre(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for makeSubscription.
	  * @param id Account id
	  * @param fk Foreign key for makeSubscription
	  */
	 accountPrototypeFindByIdMakeSubscription(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdMakeSubscription(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a related item by id for mood.
	  * @param id Account id
	  * @param fk Foreign key for mood
	  */
	 accountPrototypeFindByIdMood(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdMood(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeFindByIdPlaylist(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdPlaylist(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a related item by id for price.
	  * @param id Account id
	  * @param fk Foreign key for price
	  */
	 accountPrototypeFindByIdPrice(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdPrice(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeFindByIdProject(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdProject(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeFindByIdRoles(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries accessTokens of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetAccessTokens(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation businessType.
	  * @param id Account id
	  * @param refresh
	  */
	 accountPrototypeGetBusinessType(params: { id: string; refresh?: boolean }, options?: any) {
		 return AccountApiFp.accountPrototypeGetBusinessType(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches hasOne relation cart.
	  * @param id Account id
	  * @param refresh
	  */
	 accountPrototypeGetCart(params: { id: string; refresh?: boolean }, options?: any) {
		 return AccountApiFp.accountPrototypeGetCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries composes of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetComposes(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetComposes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries downloads of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetDownloads(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetDownloads(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries feature of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetFeature(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetFeature(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries genre of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetGenre(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetGenre(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries makeSubscription of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetMakeSubscription(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetMakeSubscription(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Queries mood of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetMood(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetMood(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries playlist of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetPlaylist(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries price of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetPrice(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetPrice(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries project of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetProject(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetProject(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries roles of Account.
	  * @param id Account id
	  * @param filter
	  */
	 accountPrototypeGetRoles(params: { id: string; filter?: string }, options?: any) {
		 return AccountApiFp.accountPrototypeGetRoles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  * @param data
	  */
	 accountPrototypeLinkComposes(
		 params: { id: string; fk: string; data?: ComposeTrack },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeLinkComposes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  * @param data
	  */
	 accountPrototypeLinkDownloads(
		 params: { id: string; fk: string; data?: Download },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeLinkDownloads(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 accountPrototypeLinkPlaylist(
		 params: { id: string; fk: string; data?: AccountPlaylist },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeLinkPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  * @param data
	  */
	 accountPrototypeLinkProject(
		 params: { id: string; fk: string; data?: AccountProject },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeLinkProject(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  * @param data
	  */
	 accountPrototypeLinkRoles(params: { id: string; fk: string; data?: RoleMapping }, options?: any) {
		 return AccountApiFp.accountPrototypeLinkRoles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Account id
	  * @param data An object of model property name/value pairs
	  */
	 accountPrototypePatchAttributes(params: { id: string; data?: Account }, options?: any) {
		 return AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the composes relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  */
	 accountPrototypeUnlinkComposes(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeUnlinkComposes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the downloads relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  */
	 accountPrototypeUnlinkDownloads(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeUnlinkDownloads(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the playlist relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  */
	 accountPrototypeUnlinkPlaylist(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeUnlinkPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the project relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for project
	  */
	 accountPrototypeUnlinkProject(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeUnlinkProject(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the roles relation to an item by id.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  */
	 accountPrototypeUnlinkRoles(params: { id: string; fk: string }, options?: any) {
		 return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for accessTokens.
	  * @param id Account id
	  * @param fk Foreign key for accessTokens
	  * @param data
	  */
	 accountPrototypeUpdateByIdAccessTokens(
		 params: { id: string; fk: string; data?: AccountToken },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for composes.
	  * @param id Account id
	  * @param fk Foreign key for composes
	  * @param data
	  */
	 accountPrototypeUpdateByIdComposes(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeUpdateByIdComposes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for downloads.
	  * @param id Account id
	  * @param fk Foreign key for downloads
	  * @param data
	  */
	 accountPrototypeUpdateByIdDownloads(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeUpdateByIdDownloads(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for feature.
	  * @param id Account id
	  * @param fk Foreign key for feature
	  * @param data
	  */
	 accountPrototypeUpdateByIdFeature(
		 params: { id: string; fk: string; data?: Feature },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeUpdateByIdFeature(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for genre.
	  * @param id Account id
	  * @param fk Foreign key for genre
	  * @param data
	  */
	 accountPrototypeUpdateByIdGenre(params: { id: string; fk: string; data?: Genre }, options?: any) {
		 return AccountApiFp.accountPrototypeUpdateByIdGenre(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for makeSubscription.
	  * @param id Account id
	  * @param fk Foreign key for makeSubscription
	  * @param data
	  */
	 accountPrototypeUpdateByIdMakeSubscription(
		 params: { id: string; fk: string; data?: Subscription },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeUpdateByIdMakeSubscription(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for mood.
	  * @param id Account id
	  * @param fk Foreign key for mood
	  * @param data
	  */
	 accountPrototypeUpdateByIdMood(params: { id: string; fk: string; data?: Mood }, options?: any) {
		 return AccountApiFp.accountPrototypeUpdateByIdMood(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for playlist.
	  * @param id Account id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 accountPrototypeUpdateByIdPlaylist(
		 params: { id: string; fk: string; data?: Playlist },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeUpdateByIdPlaylist(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for price.
	  * @param id Account id
	  * @param fk Foreign key for price
	  * @param data
	  */
	 accountPrototypeUpdateByIdPrice(params: { id: string; fk: string; data?: Price }, options?: any) {
		 return AccountApiFp.accountPrototypeUpdateByIdPrice(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for project.
	  * @param id Account id
	  * @param fk Foreign key for project
	  * @param data
	  */
	 accountPrototypeUpdateByIdProject(
		 params: { id: string; fk: string; data?: Project },
		 options?: any
	 ) {
		 return AccountApiFp.accountPrototypeUpdateByIdProject(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for roles.
	  * @param id Account id
	  * @param fk Foreign key for roles
	  * @param data
	  */
	 accountPrototypeUpdateByIdRoles(params: { id: string; fk: string; data?: Role }, options?: any) {
		 return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update cart of this model.
	  * @param id Account id
	  * @param data
	  */
	 accountPrototypeUpdateCart(params: { id: string; data?: Cart }, options?: any) {
		 return AccountApiFp.accountPrototypeUpdateCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Trigger user's identity verification with configured verifyOptions
	  * @param id Account id
	  */
	 accountPrototypeVerify(params: { id: string }, options?: any) {
		 return AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountReplaceByIdPostAccountsidReplace(params: { id: string; data?: Account }, options?: any) {
		 return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountReplaceByIdPutAccountsid(params: { id: string; data?: Account }, options?: any) {
		 return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountReplaceOrCreatePostAccountsReplaceOrCreate(params: { data?: Account }, options?: any) {
		 return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountReplaceOrCreatePutAccounts(params: { data?: Account }, options?: any) {
		 return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Reset password for a user with email.
	  * @param options
	  */
	 accountResetPassword(params: { options: any }, options?: any) {
		 return AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Reset user's password via a password-reset token.
	  * @param newPassword
	  */
	 accountSetPassword(params: { newPassword: string }, options?: any) {
		 return AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountUpdateAll(params: { where?: string; data?: Account }, options?: any) {
		 return AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountUpsertWithWhere(params: { where?: string; data?: Account }, options?: any) {
		 return AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * AccountApi - factory interface
  */
 export const AccountApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Change a user's password.
		  * @param oldPassword
		  * @param newPassword
		  */
		 accountChangePassword(params: { oldPassword: string; newPassword: string }, options?: any) {
			 return AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Confirm a user registration with identity verification token.
		  * @param uid
		  * @param token
		  * @param redirect
		  */
		 accountConfirm(params: { uid: string; token: string; redirect?: string }, options?: any) {
			 return AccountApiFp.accountConfirm(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 accountCount(params: { where?: string }, options?: any) {
			 return AccountApiFp.accountCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 accountCreate(params: { data?: Account }, options?: any) {
			 return AccountApiFp.accountCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountCreateChangeStreamGetAccountsChangeStream(params: { options?: string }, options?: any) {
			 return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountCreateChangeStreamPostAccountsChangeStream(params: { options?: string }, options?: any) {
			 return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 accountDeleteById(params: { id: string }, options?: any) {
			 return AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountExistsGetAccountsidExists(params: { id: string }, options?: any) {
			 return AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountExistsHeadAccountsid(params: { id: string }, options?: any) {
			 return AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountFind(params: { filter?: string }, options?: any) {
			 return AccountApiFp.accountFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 accountFindById(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountFindOne(params: { filter?: string }, options?: any) {
			 return AccountApiFp.accountFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Login a user with username/email and password.
		  * @param credentials
		  * @param include Related objects to include in the response. See the description of return value for more details.
		  */
		 accountLogin(params: { credentials: any; include?: string }, options?: any) {
			 return AccountApiFp.accountLogin(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Logout a user with access token.
		  */
		 accountLogout(options?: any) {
			 return AccountApiFp.accountLogout(options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountPatchOrCreate(params: { data?: Account }, options?: any) {
			 return AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts accessTokens of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountAccessTokens(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts composes of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountComposes(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts downloads of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountDownloads(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts feature of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountFeature(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountFeature(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts genre of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountGenre(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountGenre(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts makeSubscription of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountMakeSubscription(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountMakeSubscription(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts mood of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountMood(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountMood(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts playlist of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountPlaylist(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts price of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountPrice(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountPrice(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts project of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountProject(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts roles of Account.
		  * @param id Account id
		  * @param where Criteria to match model instances
		  */
		 accountPrototypeCountRoles(params: { id: string; where?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeCountRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in accessTokens of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateAccessTokens(params: { id: string; data?: AccountToken }, options?: any) {
			 return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in cart of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateCart(params: { id: string; data?: Cart }, options?: any) {
			 return AccountApiFp.accountPrototypeCreateCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in composes of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateComposes(params: { id: string; data?: Track }, options?: any) {
			 return AccountApiFp.accountPrototypeCreateComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in downloads of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateDownloads(params: { id: string; data?: Track }, options?: any) {
			 return AccountApiFp.accountPrototypeCreateDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in feature of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateFeature(params: { id: string; data?: Feature }, options?: any) {
			 return AccountApiFp.accountPrototypeCreateFeature(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in genre of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateGenre(params: { id: string; data?: Genre }, options?: any) {
			 return AccountApiFp.accountPrototypeCreateGenre(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in makeSubscription of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateMakeSubscription(
			 params: { id: string; data?: Subscription },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeCreateMakeSubscription(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in mood of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateMood(params: { id: string; data?: Mood }, options?: any) {
			 return AccountApiFp.accountPrototypeCreateMood(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in playlist of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreatePlaylist(params: { id: string; data?: Playlist }, options?: any) {
			 return AccountApiFp.accountPrototypeCreatePlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in price of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreatePrice(params: { id: string; data?: Price }, options?: any) {
			 return AccountApiFp.accountPrototypeCreatePrice(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in project of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateProject(params: { id: string; data?: Project }, options?: any) {
			 return AccountApiFp.accountPrototypeCreateProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in roles of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeCreateRoles(params: { id: string; data?: Role }, options?: any) {
			 return AccountApiFp.accountPrototypeCreateRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all accessTokens of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeleteAccessTokens(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all composes of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeleteComposes(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeleteComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all downloads of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeleteDownloads(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeleteDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all feature of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeleteFeature(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeleteFeature(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all genre of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeleteGenre(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeleteGenre(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all makeSubscription of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeleteMakeSubscription(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeleteMakeSubscription(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all mood of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeleteMood(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeleteMood(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all playlist of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeletePlaylist(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeletePlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all price of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeletePrice(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeletePrice(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all project of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeleteProject(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeleteProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all roles of this model.
		  * @param id Account id
		  */
		 accountPrototypeDeleteRoles(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDeleteRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for accessTokens.
		  * @param id Account id
		  * @param fk Foreign key for accessTokens
		  */
		 accountPrototypeDestroyByIdAccessTokens(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for composes.
		  * @param id Account id
		  * @param fk Foreign key for composes
		  */
		 accountPrototypeDestroyByIdComposes(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for downloads.
		  * @param id Account id
		  * @param fk Foreign key for downloads
		  */
		 accountPrototypeDestroyByIdDownloads(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for feature.
		  * @param id Account id
		  * @param fk Foreign key for feature
		  */
		 accountPrototypeDestroyByIdFeature(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdFeature(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for genre.
		  * @param id Account id
		  * @param fk Foreign key for genre
		  */
		 accountPrototypeDestroyByIdGenre(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdGenre(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for makeSubscription.
		  * @param id Account id
		  * @param fk Foreign key for makeSubscription
		  */
		 accountPrototypeDestroyByIdMakeSubscription(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdMakeSubscription(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a related item by id for mood.
		  * @param id Account id
		  * @param fk Foreign key for mood
		  */
		 accountPrototypeDestroyByIdMood(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdMood(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for playlist.
		  * @param id Account id
		  * @param fk Foreign key for playlist
		  */
		 accountPrototypeDestroyByIdPlaylist(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for price.
		  * @param id Account id
		  * @param fk Foreign key for price
		  */
		 accountPrototypeDestroyByIdPrice(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdPrice(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for project.
		  * @param id Account id
		  * @param fk Foreign key for project
		  */
		 accountPrototypeDestroyByIdProject(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for roles.
		  * @param id Account id
		  * @param fk Foreign key for roles
		  */
		 accountPrototypeDestroyByIdRoles(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes cart of this model.
		  * @param id Account id
		  */
		 accountPrototypeDestroyCart(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeDestroyCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of composes relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for composes
		  */
		 accountPrototypeExistsComposes(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeExistsComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of downloads relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for downloads
		  */
		 accountPrototypeExistsDownloads(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeExistsDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of playlist relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for playlist
		  */
		 accountPrototypeExistsPlaylist(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeExistsPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of project relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for project
		  */
		 accountPrototypeExistsProject(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeExistsProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of roles relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for roles
		  */
		 accountPrototypeExistsRoles(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeExistsRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for accessTokens.
		  * @param id Account id
		  * @param fk Foreign key for accessTokens
		  */
		 accountPrototypeFindByIdAccessTokens(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for composes.
		  * @param id Account id
		  * @param fk Foreign key for composes
		  */
		 accountPrototypeFindByIdComposes(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for downloads.
		  * @param id Account id
		  * @param fk Foreign key for downloads
		  */
		 accountPrototypeFindByIdDownloads(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for feature.
		  * @param id Account id
		  * @param fk Foreign key for feature
		  */
		 accountPrototypeFindByIdFeature(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdFeature(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for genre.
		  * @param id Account id
		  * @param fk Foreign key for genre
		  */
		 accountPrototypeFindByIdGenre(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdGenre(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for makeSubscription.
		  * @param id Account id
		  * @param fk Foreign key for makeSubscription
		  */
		 accountPrototypeFindByIdMakeSubscription(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdMakeSubscription(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Find a related item by id for mood.
		  * @param id Account id
		  * @param fk Foreign key for mood
		  */
		 accountPrototypeFindByIdMood(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdMood(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for playlist.
		  * @param id Account id
		  * @param fk Foreign key for playlist
		  */
		 accountPrototypeFindByIdPlaylist(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for price.
		  * @param id Account id
		  * @param fk Foreign key for price
		  */
		 accountPrototypeFindByIdPrice(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdPrice(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for project.
		  * @param id Account id
		  * @param fk Foreign key for project
		  */
		 accountPrototypeFindByIdProject(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for roles.
		  * @param id Account id
		  * @param fk Foreign key for roles
		  */
		 accountPrototypeFindByIdRoles(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries accessTokens of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetAccessTokens(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation businessType.
		  * @param id Account id
		  * @param refresh
		  */
		 accountPrototypeGetBusinessType(params: { id: string; refresh?: boolean }, options?: any) {
			 return AccountApiFp.accountPrototypeGetBusinessType(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches hasOne relation cart.
		  * @param id Account id
		  * @param refresh
		  */
		 accountPrototypeGetCart(params: { id: string; refresh?: boolean }, options?: any) {
			 return AccountApiFp.accountPrototypeGetCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries composes of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetComposes(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries downloads of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetDownloads(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries feature of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetFeature(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetFeature(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries genre of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetGenre(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetGenre(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries makeSubscription of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetMakeSubscription(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetMakeSubscription(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries mood of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetMood(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetMood(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries playlist of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetPlaylist(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries price of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetPrice(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetPrice(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries project of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetProject(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries roles of Account.
		  * @param id Account id
		  * @param filter
		  */
		 accountPrototypeGetRoles(params: { id: string; filter?: string }, options?: any) {
			 return AccountApiFp.accountPrototypeGetRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for composes.
		  * @param id Account id
		  * @param fk Foreign key for composes
		  * @param data
		  */
		 accountPrototypeLinkComposes(
			 params: { id: string; fk: string; data?: ComposeTrack },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeLinkComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for downloads.
		  * @param id Account id
		  * @param fk Foreign key for downloads
		  * @param data
		  */
		 accountPrototypeLinkDownloads(
			 params: { id: string; fk: string; data?: Download },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeLinkDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for playlist.
		  * @param id Account id
		  * @param fk Foreign key for playlist
		  * @param data
		  */
		 accountPrototypeLinkPlaylist(
			 params: { id: string; fk: string; data?: AccountPlaylist },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeLinkPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for project.
		  * @param id Account id
		  * @param fk Foreign key for project
		  * @param data
		  */
		 accountPrototypeLinkProject(
			 params: { id: string; fk: string; data?: AccountProject },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeLinkProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for roles.
		  * @param id Account id
		  * @param fk Foreign key for roles
		  * @param data
		  */
		 accountPrototypeLinkRoles(
			 params: { id: string; fk: string; data?: RoleMapping },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeLinkRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Account id
		  * @param data An object of model property name/value pairs
		  */
		 accountPrototypePatchAttributes(params: { id: string; data?: Account }, options?: any) {
			 return AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the composes relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for composes
		  */
		 accountPrototypeUnlinkComposes(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeUnlinkComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the downloads relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for downloads
		  */
		 accountPrototypeUnlinkDownloads(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeUnlinkDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the playlist relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for playlist
		  */
		 accountPrototypeUnlinkPlaylist(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeUnlinkPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the project relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for project
		  */
		 accountPrototypeUnlinkProject(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeUnlinkProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the roles relation to an item by id.
		  * @param id Account id
		  * @param fk Foreign key for roles
		  */
		 accountPrototypeUnlinkRoles(params: { id: string; fk: string }, options?: any) {
			 return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for accessTokens.
		  * @param id Account id
		  * @param fk Foreign key for accessTokens
		  * @param data
		  */
		 accountPrototypeUpdateByIdAccessTokens(
			 params: { id: string; fk: string; data?: AccountToken },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for composes.
		  * @param id Account id
		  * @param fk Foreign key for composes
		  * @param data
		  */
		 accountPrototypeUpdateByIdComposes(
			 params: { id: string; fk: string; data?: Track },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdComposes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for downloads.
		  * @param id Account id
		  * @param fk Foreign key for downloads
		  * @param data
		  */
		 accountPrototypeUpdateByIdDownloads(
			 params: { id: string; fk: string; data?: Track },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for feature.
		  * @param id Account id
		  * @param fk Foreign key for feature
		  * @param data
		  */
		 accountPrototypeUpdateByIdFeature(
			 params: { id: string; fk: string; data?: Feature },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdFeature(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for genre.
		  * @param id Account id
		  * @param fk Foreign key for genre
		  * @param data
		  */
		 accountPrototypeUpdateByIdGenre(
			 params: { id: string; fk: string; data?: Genre },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdGenre(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for makeSubscription.
		  * @param id Account id
		  * @param fk Foreign key for makeSubscription
		  * @param data
		  */
		 accountPrototypeUpdateByIdMakeSubscription(
			 params: { id: string; fk: string; data?: Subscription },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdMakeSubscription(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update a related item by id for mood.
		  * @param id Account id
		  * @param fk Foreign key for mood
		  * @param data
		  */
		 accountPrototypeUpdateByIdMood(params: { id: string; fk: string; data?: Mood }, options?: any) {
			 return AccountApiFp.accountPrototypeUpdateByIdMood(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for playlist.
		  * @param id Account id
		  * @param fk Foreign key for playlist
		  * @param data
		  */
		 accountPrototypeUpdateByIdPlaylist(
			 params: { id: string; fk: string; data?: Playlist },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for price.
		  * @param id Account id
		  * @param fk Foreign key for price
		  * @param data
		  */
		 accountPrototypeUpdateByIdPrice(
			 params: { id: string; fk: string; data?: Price },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdPrice(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for project.
		  * @param id Account id
		  * @param fk Foreign key for project
		  * @param data
		  */
		 accountPrototypeUpdateByIdProject(
			 params: { id: string; fk: string; data?: Project },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for roles.
		  * @param id Account id
		  * @param fk Foreign key for roles
		  * @param data
		  */
		 accountPrototypeUpdateByIdRoles(
			 params: { id: string; fk: string; data?: Role },
			 options?: any
		 ) {
			 return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update cart of this model.
		  * @param id Account id
		  * @param data
		  */
		 accountPrototypeUpdateCart(params: { id: string; data?: Cart }, options?: any) {
			 return AccountApiFp.accountPrototypeUpdateCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Trigger user's identity verification with configured verifyOptions
		  * @param id Account id
		  */
		 accountPrototypeVerify(params: { id: string }, options?: any) {
			 return AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountReplaceByIdPostAccountsidReplace(params: { id: string; data?: Account }, options?: any) {
			 return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountReplaceByIdPutAccountsid(params: { id: string; data?: Account }, options?: any) {
			 return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountReplaceOrCreatePostAccountsReplaceOrCreate(params: { data?: Account }, options?: any) {
			 return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountReplaceOrCreatePutAccounts(params: { data?: Account }, options?: any) {
			 return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Reset password for a user with email.
		  * @param options
		  */
		 accountResetPassword(params: { options: any }, options?: any) {
			 return AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Reset user's password via a password-reset token.
		  * @param newPassword
		  */
		 accountSetPassword(params: { newPassword: string }, options?: any) {
			 return AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountUpdateAll(params: { where?: string; data?: Account }, options?: any) {
			 return AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountUpsertWithWhere(params: { where?: string; data?: Account }, options?: any) {
			 return AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * AccountPlaylistApi - fetch parameter creator
  */
 export const AccountPlaylistApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountPlaylistCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountPlaylists/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistCreate(params: { data?: AccountPlaylist }, options?: any): FetchArgs {
		 const baseUrl = `/AccountPlaylists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountPlaylists/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountPlaylists/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountPlaylistDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPlaylistDeleteById');
		 }
		 const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountPlaylistExistsGetAccountPlaylistsidExists(
		 params: { id: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPlaylistExistsGetAccountPlaylistsidExists'
			 );
		 }
		 const baseUrl = `/AccountPlaylists/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountPlaylistExistsHeadAccountPlaylistsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPlaylistExistsHeadAccountPlaylistsid'
			 );
		 }
		 const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountPlaylistFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountPlaylists`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountPlaylistFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountPlaylistFindById');
		 }
		 const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountPlaylistFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountPlaylists/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistPatchOrCreate(params: { data?: AccountPlaylist }, options?: any): FetchArgs {
		 const baseUrl = `/AccountPlaylists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id AccountPlaylist id
	  * @param refresh
	  */
	 accountPlaylistPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPlaylistPrototypeGetAccount'
			 );
		 }
		 const baseUrl = `/AccountPlaylists/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation playlist.
	  * @param id AccountPlaylist id
	  * @param refresh
	  */
	 accountPlaylistPrototypeGetPlaylist(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPlaylistPrototypeGetPlaylist'
			 );
		 }
		 const baseUrl = `/AccountPlaylists/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountPlaylist id
	  * @param data An object of model property name/value pairs
	  */
	 accountPlaylistPrototypePatchAttributes(
		 params: { id: string; data?: AccountPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPlaylistPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(
		 params: { id: string; data?: AccountPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPlaylistReplaceByIdPostAccountPlaylistsidReplace'
			 );
		 }
		 const baseUrl = `/AccountPlaylists/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceByIdPutAccountPlaylistsid(
		 params: { id: string; data?: AccountPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountPlaylistReplaceByIdPutAccountPlaylistsid'
			 );
		 }
		 const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(
		 params: { data?: AccountPlaylist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountPlaylists/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceOrCreatePutAccountPlaylists(
		 params: { data?: AccountPlaylist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountPlaylists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountPlaylistUpdateAll(
		 params: { where?: string; data?: AccountPlaylist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountPlaylists/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountPlaylistUpsertWithWhere(
		 params: { where?: string; data?: AccountPlaylist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountPlaylists/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * AccountPlaylistApi - functional programming interface
  */
 export const AccountPlaylistApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountPlaylistCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistCreate(
		 params: { data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 AccountPlaylistApiFetchParamCreator.accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 AccountPlaylistApiFetchParamCreator.accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountPlaylistDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistDeleteById(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountPlaylistExistsGetAccountPlaylistsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs =
			 AccountPlaylistApiFetchParamCreator.accountPlaylistExistsGetAccountPlaylistsidExists(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountPlaylistExistsHeadAccountPlaylistsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs =
			 AccountPlaylistApiFetchParamCreator.accountPlaylistExistsHeadAccountPlaylistsid(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountPlaylistFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountPlaylist>> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountPlaylistFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountPlaylistFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistPatchOrCreate(
		 params: { data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistPatchOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id AccountPlaylist id
	  * @param refresh
	  */
	 accountPlaylistPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistPrototypeGetAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation playlist.
	  * @param id AccountPlaylist id
	  * @param refresh
	  */
	 accountPlaylistPrototypeGetPlaylist(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistPrototypeGetPlaylist(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountPlaylist id
	  * @param data An object of model property name/value pairs
	  */
	 accountPlaylistPrototypePatchAttributes(
		 params: { id: string; data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(
		 params: { id: string; data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs =
			 AccountPlaylistApiFetchParamCreator.accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceByIdPutAccountPlaylistsid(
		 params: { id: string; data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs =
			 AccountPlaylistApiFetchParamCreator.accountPlaylistReplaceByIdPutAccountPlaylistsid(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(
		 params: { data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs =
			 AccountPlaylistApiFetchParamCreator.accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceOrCreatePutAccountPlaylists(
		 params: { data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs =
			 AccountPlaylistApiFetchParamCreator.accountPlaylistReplaceOrCreatePutAccountPlaylists(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountPlaylistUpdateAll(
		 params: { where?: string; data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountPlaylistUpsertWithWhere(
		 params: { where?: string; data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs = AccountPlaylistApiFetchParamCreator.accountPlaylistUpsertWithWhere(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * AccountPlaylistApi - object-oriented interface
  */
 export class AccountPlaylistApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountPlaylistCount(params: { where?: string }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistCreate(params: { data?: AccountPlaylist }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return AccountPlaylistApiFp.accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return AccountPlaylistApiFp.accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountPlaylistDeleteById(params: { id: string }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistDeleteById(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountPlaylistExistsGetAccountPlaylistsidExists(params: { id: string }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistExistsGetAccountPlaylistsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountPlaylistExistsHeadAccountPlaylistsid(params: { id: string }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistExistsHeadAccountPlaylistsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountPlaylistFind(params: { filter?: string }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountPlaylistFindById(params: { id: string; filter?: string }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountPlaylistFindOne(params: { filter?: string }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistPatchOrCreate(params: { data?: AccountPlaylist }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistPatchOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id AccountPlaylist id
	  * @param refresh
	  */
	 accountPlaylistPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistPrototypeGetAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation playlist.
	  * @param id AccountPlaylist id
	  * @param refresh
	  */
	 accountPlaylistPrototypeGetPlaylist(params: { id: string; refresh?: boolean }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistPrototypeGetPlaylist(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountPlaylist id
	  * @param data An object of model property name/value pairs
	  */
	 accountPlaylistPrototypePatchAttributes(
		 params: { id: string; data?: AccountPlaylist },
		 options?: any
	 ) {
		 return AccountPlaylistApiFp.accountPlaylistPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(
		 params: { id: string; data?: AccountPlaylist },
		 options?: any
	 ) {
		 return AccountPlaylistApiFp.accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceByIdPutAccountPlaylistsid(
		 params: { id: string; data?: AccountPlaylist },
		 options?: any
	 ) {
		 return AccountPlaylistApiFp.accountPlaylistReplaceByIdPutAccountPlaylistsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(
		 params: { data?: AccountPlaylist },
		 options?: any
	 ) {
		 return AccountPlaylistApiFp.accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountPlaylistReplaceOrCreatePutAccountPlaylists(
		 params: { data?: AccountPlaylist },
		 options?: any
	 ) {
		 return AccountPlaylistApiFp.accountPlaylistReplaceOrCreatePutAccountPlaylists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountPlaylistUpdateAll(params: { where?: string; data?: AccountPlaylist }, options?: any) {
		 return AccountPlaylistApiFp.accountPlaylistUpdateAll(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountPlaylistUpsertWithWhere(
		 params: { where?: string; data?: AccountPlaylist },
		 options?: any
	 ) {
		 return AccountPlaylistApiFp.accountPlaylistUpsertWithWhere(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
 }
 
 /**
  * AccountPlaylistApi - factory interface
  */
 export const AccountPlaylistApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 accountPlaylistCount(params: { where?: string }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 accountPlaylistCreate(params: { data?: AccountPlaylist }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return AccountPlaylistApiFp.accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return AccountPlaylistApiFp.accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 accountPlaylistDeleteById(params: { id: string }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountPlaylistExistsGetAccountPlaylistsidExists(params: { id: string }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistExistsGetAccountPlaylistsidExists(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountPlaylistExistsHeadAccountPlaylistsid(params: { id: string }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistExistsHeadAccountPlaylistsid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountPlaylistFind(params: { filter?: string }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 accountPlaylistFindById(params: { id: string; filter?: string }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountPlaylistFindOne(params: { filter?: string }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountPlaylistPatchOrCreate(params: { data?: AccountPlaylist }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation account.
		  * @param id AccountPlaylist id
		  * @param refresh
		  */
		 accountPlaylistPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistPrototypeGetAccount(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation playlist.
		  * @param id AccountPlaylist id
		  * @param refresh
		  */
		 accountPlaylistPrototypeGetPlaylist(params: { id: string; refresh?: boolean }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistPrototypeGetPlaylist(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id AccountPlaylist id
		  * @param data An object of model property name/value pairs
		  */
		 accountPlaylistPrototypePatchAttributes(
			 params: { id: string; data?: AccountPlaylist },
			 options?: any
		 ) {
			 return AccountPlaylistApiFp.accountPlaylistPrototypePatchAttributes(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(
			 params: { id: string; data?: AccountPlaylist },
			 options?: any
		 ) {
			 return AccountPlaylistApiFp.accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountPlaylistReplaceByIdPutAccountPlaylistsid(
			 params: { id: string; data?: AccountPlaylist },
			 options?: any
		 ) {
			 return AccountPlaylistApiFp.accountPlaylistReplaceByIdPutAccountPlaylistsid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(
			 params: { data?: AccountPlaylist },
			 options?: any
		 ) {
			 return AccountPlaylistApiFp.accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountPlaylistReplaceOrCreatePutAccountPlaylists(
			 params: { data?: AccountPlaylist },
			 options?: any
		 ) {
			 return AccountPlaylistApiFp.accountPlaylistReplaceOrCreatePutAccountPlaylists(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountPlaylistUpdateAll(params: { where?: string; data?: AccountPlaylist }, options?: any) {
			 return AccountPlaylistApiFp.accountPlaylistUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountPlaylistUpsertWithWhere(
			 params: { where?: string; data?: AccountPlaylist },
			 options?: any
		 ) {
			 return AccountPlaylistApiFp.accountPlaylistUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * AccountProjectApi - fetch parameter creator
  */
 export const AccountProjectApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountProjectCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountProjects/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountProjectCreate(params: { data?: AccountProject }, options?: any): FetchArgs {
		 const baseUrl = `/AccountProjects`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountProjectCreateChangeStreamGetAccountProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountProjects/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountProjectCreateChangeStreamPostAccountProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountProjects/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountProjectDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountProjectDeleteById');
		 }
		 const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountProjectExistsGetAccountProjectsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountProjectExistsGetAccountProjectsidExists'
			 );
		 }
		 const baseUrl = `/AccountProjects/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountProjectExistsHeadAccountProjectsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountProjectExistsHeadAccountProjectsid'
			 );
		 }
		 const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountProjectFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountProjects`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountProjectFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountProjectFindById');
		 }
		 const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountProjectFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountProjects/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountProjectPatchOrCreate(params: { data?: AccountProject }, options?: any): FetchArgs {
		 const baseUrl = `/AccountProjects`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id AccountProject id
	  * @param refresh
	  */
	 accountProjectPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountProjectPrototypeGetAccount'
			 );
		 }
		 const baseUrl = `/AccountProjects/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation project.
	  * @param id AccountProject id
	  * @param refresh
	  */
	 accountProjectPrototypeGetProject(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountProjectPrototypeGetProject'
			 );
		 }
		 const baseUrl = `/AccountProjects/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountProject id
	  * @param data An object of model property name/value pairs
	  */
	 accountProjectPrototypePatchAttributes(
		 params: { id: string; data?: AccountProject },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountProjectPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountProjectReplaceByIdPostAccountProjectsidReplace(
		 params: { id: string; data?: AccountProject },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountProjectReplaceByIdPostAccountProjectsidReplace'
			 );
		 }
		 const baseUrl = `/AccountProjects/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountProjectReplaceByIdPutAccountProjectsid(
		 params: { id: string; data?: AccountProject },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountProjectReplaceByIdPutAccountProjectsid'
			 );
		 }
		 const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(
		 params: { data?: AccountProject },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountProjects/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountProjectReplaceOrCreatePutAccountProjects(
		 params: { data?: AccountProject },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountProjects`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountProjectUpdateAll(
		 params: { where?: string; data?: AccountProject },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountProjects/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountProjectUpsertWithWhere(
		 params: { where?: string; data?: AccountProject },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountProjects/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * AccountProjectApi - functional programming interface
  */
 export const AccountProjectApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountProjectCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountProjectCreate(
		 params: { data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountProjectCreateChangeStreamGetAccountProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 AccountProjectApiFetchParamCreator.accountProjectCreateChangeStreamGetAccountProjectsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountProjectCreateChangeStreamPostAccountProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 AccountProjectApiFetchParamCreator.accountProjectCreateChangeStreamPostAccountProjectsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountProjectDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountProjectExistsGetAccountProjectsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs =
			 AccountProjectApiFetchParamCreator.accountProjectExistsGetAccountProjectsidExists(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountProjectExistsHeadAccountProjectsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectExistsHeadAccountProjectsid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountProjectFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountProject>> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountProjectFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountProjectFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountProjectPatchOrCreate(
		 params: { data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectPatchOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id AccountProject id
	  * @param refresh
	  */
	 accountProjectPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectPrototypeGetAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation project.
	  * @param id AccountProject id
	  * @param refresh
	  */
	 accountProjectPrototypeGetProject(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectPrototypeGetProject(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountProject id
	  * @param data An object of model property name/value pairs
	  */
	 accountProjectPrototypePatchAttributes(
		 params: { id: string; data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountProjectReplaceByIdPostAccountProjectsidReplace(
		 params: { id: string; data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs =
			 AccountProjectApiFetchParamCreator.accountProjectReplaceByIdPostAccountProjectsidReplace(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountProjectReplaceByIdPutAccountProjectsid(
		 params: { id: string; data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs =
			 AccountProjectApiFetchParamCreator.accountProjectReplaceByIdPutAccountProjectsid(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(
		 params: { data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs =
			 AccountProjectApiFetchParamCreator.accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountProjectReplaceOrCreatePutAccountProjects(
		 params: { data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs =
			 AccountProjectApiFetchParamCreator.accountProjectReplaceOrCreatePutAccountProjects(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountProjectUpdateAll(
		 params: { where?: string; data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountProjectUpsertWithWhere(
		 params: { where?: string; data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs = AccountProjectApiFetchParamCreator.accountProjectUpsertWithWhere(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * AccountProjectApi - object-oriented interface
  */
 export class AccountProjectApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountProjectCount(params: { where?: string }, options?: any) {
		 return AccountProjectApiFp.accountProjectCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountProjectCreate(params: { data?: AccountProject }, options?: any) {
		 return AccountProjectApiFp.accountProjectCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountProjectCreateChangeStreamGetAccountProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return AccountProjectApiFp.accountProjectCreateChangeStreamGetAccountProjectsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountProjectCreateChangeStreamPostAccountProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return AccountProjectApiFp.accountProjectCreateChangeStreamPostAccountProjectsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountProjectDeleteById(params: { id: string }, options?: any) {
		 return AccountProjectApiFp.accountProjectDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountProjectExistsGetAccountProjectsidExists(params: { id: string }, options?: any) {
		 return AccountProjectApiFp.accountProjectExistsGetAccountProjectsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountProjectExistsHeadAccountProjectsid(params: { id: string }, options?: any) {
		 return AccountProjectApiFp.accountProjectExistsHeadAccountProjectsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountProjectFind(params: { filter?: string }, options?: any) {
		 return AccountProjectApiFp.accountProjectFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountProjectFindById(params: { id: string; filter?: string }, options?: any) {
		 return AccountProjectApiFp.accountProjectFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountProjectFindOne(params: { filter?: string }, options?: any) {
		 return AccountProjectApiFp.accountProjectFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountProjectPatchOrCreate(params: { data?: AccountProject }, options?: any) {
		 return AccountProjectApiFp.accountProjectPatchOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id AccountProject id
	  * @param refresh
	  */
	 accountProjectPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
		 return AccountProjectApiFp.accountProjectPrototypeGetAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation project.
	  * @param id AccountProject id
	  * @param refresh
	  */
	 accountProjectPrototypeGetProject(params: { id: string; refresh?: boolean }, options?: any) {
		 return AccountProjectApiFp.accountProjectPrototypeGetProject(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountProject id
	  * @param data An object of model property name/value pairs
	  */
	 accountProjectPrototypePatchAttributes(
		 params: { id: string; data?: AccountProject },
		 options?: any
	 ) {
		 return AccountProjectApiFp.accountProjectPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountProjectReplaceByIdPostAccountProjectsidReplace(
		 params: { id: string; data?: AccountProject },
		 options?: any
	 ) {
		 return AccountProjectApiFp.accountProjectReplaceByIdPostAccountProjectsidReplace(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountProjectReplaceByIdPutAccountProjectsid(
		 params: { id: string; data?: AccountProject },
		 options?: any
	 ) {
		 return AccountProjectApiFp.accountProjectReplaceByIdPutAccountProjectsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(
		 params: { data?: AccountProject },
		 options?: any
	 ) {
		 return AccountProjectApiFp.accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountProjectReplaceOrCreatePutAccountProjects(
		 params: { data?: AccountProject },
		 options?: any
	 ) {
		 return AccountProjectApiFp.accountProjectReplaceOrCreatePutAccountProjects(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountProjectUpdateAll(params: { where?: string; data?: AccountProject }, options?: any) {
		 return AccountProjectApiFp.accountProjectUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountProjectUpsertWithWhere(params: { where?: string; data?: AccountProject }, options?: any) {
		 return AccountProjectApiFp.accountProjectUpsertWithWhere(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
 }
 
 /**
  * AccountProjectApi - factory interface
  */
 export const AccountProjectApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 accountProjectCount(params: { where?: string }, options?: any) {
			 return AccountProjectApiFp.accountProjectCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 accountProjectCreate(params: { data?: AccountProject }, options?: any) {
			 return AccountProjectApiFp.accountProjectCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountProjectCreateChangeStreamGetAccountProjectsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return AccountProjectApiFp.accountProjectCreateChangeStreamGetAccountProjectsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountProjectCreateChangeStreamPostAccountProjectsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return AccountProjectApiFp.accountProjectCreateChangeStreamPostAccountProjectsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 accountProjectDeleteById(params: { id: string }, options?: any) {
			 return AccountProjectApiFp.accountProjectDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountProjectExistsGetAccountProjectsidExists(params: { id: string }, options?: any) {
			 return AccountProjectApiFp.accountProjectExistsGetAccountProjectsidExists(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountProjectExistsHeadAccountProjectsid(params: { id: string }, options?: any) {
			 return AccountProjectApiFp.accountProjectExistsHeadAccountProjectsid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountProjectFind(params: { filter?: string }, options?: any) {
			 return AccountProjectApiFp.accountProjectFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 accountProjectFindById(params: { id: string; filter?: string }, options?: any) {
			 return AccountProjectApiFp.accountProjectFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountProjectFindOne(params: { filter?: string }, options?: any) {
			 return AccountProjectApiFp.accountProjectFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountProjectPatchOrCreate(params: { data?: AccountProject }, options?: any) {
			 return AccountProjectApiFp.accountProjectPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation account.
		  * @param id AccountProject id
		  * @param refresh
		  */
		 accountProjectPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
			 return AccountProjectApiFp.accountProjectPrototypeGetAccount(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation project.
		  * @param id AccountProject id
		  * @param refresh
		  */
		 accountProjectPrototypeGetProject(params: { id: string; refresh?: boolean }, options?: any) {
			 return AccountProjectApiFp.accountProjectPrototypeGetProject(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id AccountProject id
		  * @param data An object of model property name/value pairs
		  */
		 accountProjectPrototypePatchAttributes(
			 params: { id: string; data?: AccountProject },
			 options?: any
		 ) {
			 return AccountProjectApiFp.accountProjectPrototypePatchAttributes(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountProjectReplaceByIdPostAccountProjectsidReplace(
			 params: { id: string; data?: AccountProject },
			 options?: any
		 ) {
			 return AccountProjectApiFp.accountProjectReplaceByIdPostAccountProjectsidReplace(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountProjectReplaceByIdPutAccountProjectsid(
			 params: { id: string; data?: AccountProject },
			 options?: any
		 ) {
			 return AccountProjectApiFp.accountProjectReplaceByIdPutAccountProjectsid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(
			 params: { data?: AccountProject },
			 options?: any
		 ) {
			 return AccountProjectApiFp.accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountProjectReplaceOrCreatePutAccountProjects(
			 params: { data?: AccountProject },
			 options?: any
		 ) {
			 return AccountProjectApiFp.accountProjectReplaceOrCreatePutAccountProjects(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountProjectUpdateAll(params: { where?: string; data?: AccountProject }, options?: any) {
			 return AccountProjectApiFp.accountProjectUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountProjectUpsertWithWhere(
			 params: { where?: string; data?: AccountProject },
			 options?: any
		 ) {
			 return AccountProjectApiFp.accountProjectUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * AccountSubscriptionApi - fetch parameter creator
  */
 export const AccountSubscriptionApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountSubscriptionCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountSubscriptions/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionCreate(params: { data?: AccountSubscription }, options?: any): FetchArgs {
		 const baseUrl = `/AccountSubscriptions`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountSubscriptions/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountSubscriptions/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountSubscriptionDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountSubscriptionDeleteById');
		 }
		 const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountSubscriptionExistsGetAccountSubscriptionsidExists(
		 params: { id: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountSubscriptionExistsGetAccountSubscriptionsidExists'
			 );
		 }
		 const baseUrl = `/AccountSubscriptions/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountSubscriptionExistsHeadAccountSubscriptionsid(
		 params: { id: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountSubscriptionExistsHeadAccountSubscriptionsid'
			 );
		 }
		 const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountSubscriptionFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountSubscriptions`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountSubscriptionFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountSubscriptionFindById');
		 }
		 const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountSubscriptionFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountSubscriptions/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionPatchOrCreate(
		 params: { data?: AccountSubscription },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountSubscriptions`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id AccountSubscription id
	  * @param refresh
	  */
	 accountSubscriptionPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountSubscriptionPrototypeGetAccount'
			 );
		 }
		 const baseUrl = `/AccountSubscriptions/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation subscription.
	  * @param id AccountSubscription id
	  * @param refresh
	  */
	 accountSubscriptionPrototypeGetSubscription(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountSubscriptionPrototypeGetSubscription'
			 );
		 }
		 const baseUrl = `/AccountSubscriptions/{id}/subscription`.replace(
			 `{${'id'}}`,
			 `${params['id']}`
		 );
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountSubscription id
	  * @param data An object of model property name/value pairs
	  */
	 accountSubscriptionPrototypePatchAttributes(
		 params: { id: string; data?: AccountSubscription },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountSubscriptionPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(
		 params: { id: string; data?: AccountSubscription },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace'
			 );
		 }
		 const baseUrl = `/AccountSubscriptions/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceByIdPutAccountSubscriptionsid(
		 params: { id: string; data?: AccountSubscription },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountSubscriptionReplaceByIdPutAccountSubscriptionsid'
			 );
		 }
		 const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(
		 params: { data?: AccountSubscription },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountSubscriptions/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceOrCreatePutAccountSubscriptions(
		 params: { data?: AccountSubscription },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountSubscriptions`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountSubscriptionUpdateAll(
		 params: { where?: string; data?: AccountSubscription },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountSubscriptions/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountSubscriptionUpsertWithWhere(
		 params: { where?: string; data?: AccountSubscription },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountSubscriptions/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * AccountSubscriptionApi - functional programming interface
  */
 export const AccountSubscriptionApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountSubscriptionCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountSubscriptionApiFetchParamCreator.accountSubscriptionCount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionCreate(
		 params: { data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs = AccountSubscriptionApiFetchParamCreator.accountSubscriptionCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountSubscriptionDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountSubscriptionApiFetchParamCreator.accountSubscriptionDeleteById(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountSubscriptionExistsGetAccountSubscriptionsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionExistsGetAccountSubscriptionsidExists(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountSubscriptionExistsHeadAccountSubscriptionsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionExistsHeadAccountSubscriptionsid(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountSubscriptionFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountSubscription>> {
		 const fetchArgs = AccountSubscriptionApiFetchParamCreator.accountSubscriptionFind(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountSubscriptionFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs = AccountSubscriptionApiFetchParamCreator.accountSubscriptionFindById(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountSubscriptionFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs = AccountSubscriptionApiFetchParamCreator.accountSubscriptionFindOne(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionPatchOrCreate(
		 params: { data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs = AccountSubscriptionApiFetchParamCreator.accountSubscriptionPatchOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id AccountSubscription id
	  * @param refresh
	  */
	 accountSubscriptionPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionPrototypeGetAccount(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation subscription.
	  * @param id AccountSubscription id
	  * @param refresh
	  */
	 accountSubscriptionPrototypeGetSubscription(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionPrototypeGetSubscription(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountSubscription id
	  * @param data An object of model property name/value pairs
	  */
	 accountSubscriptionPrototypePatchAttributes(
		 params: { id: string; data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionPrototypePatchAttributes(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(
		 params: { id: string; data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceByIdPutAccountSubscriptionsid(
		 params: { id: string; data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionReplaceByIdPutAccountSubscriptionsid(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(
		 params: { data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceOrCreatePutAccountSubscriptions(
		 params: { data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs =
			 AccountSubscriptionApiFetchParamCreator.accountSubscriptionReplaceOrCreatePutAccountSubscriptions(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountSubscriptionUpdateAll(
		 params: { where?: string; data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = AccountSubscriptionApiFetchParamCreator.accountSubscriptionUpdateAll(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountSubscriptionUpsertWithWhere(
		 params: { where?: string; data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs = AccountSubscriptionApiFetchParamCreator.accountSubscriptionUpsertWithWhere(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * AccountSubscriptionApi - object-oriented interface
  */
 export class AccountSubscriptionApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountSubscriptionCount(params: { where?: string }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionCount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionCreate(params: { data?: AccountSubscription }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountSubscriptionDeleteById(params: { id: string }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionDeleteById(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountSubscriptionExistsGetAccountSubscriptionsidExists(params: { id: string }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionExistsGetAccountSubscriptionsidExists(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountSubscriptionExistsHeadAccountSubscriptionsid(params: { id: string }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionExistsHeadAccountSubscriptionsid(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountSubscriptionFind(params: { filter?: string }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionFind(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountSubscriptionFindById(params: { id: string; filter?: string }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionFindById(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountSubscriptionFindOne(params: { filter?: string }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionFindOne(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionPatchOrCreate(params: { data?: AccountSubscription }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionPatchOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id AccountSubscription id
	  * @param refresh
	  */
	 accountSubscriptionPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
		 return AccountSubscriptionApiFp.accountSubscriptionPrototypeGetAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation subscription.
	  * @param id AccountSubscription id
	  * @param refresh
	  */
	 accountSubscriptionPrototypeGetSubscription(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionPrototypeGetSubscription(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountSubscription id
	  * @param data An object of model property name/value pairs
	  */
	 accountSubscriptionPrototypePatchAttributes(
		 params: { id: string; data?: AccountSubscription },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(
		 params: { id: string; data?: AccountSubscription },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceByIdPutAccountSubscriptionsid(
		 params: { id: string; data?: AccountSubscription },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionReplaceByIdPutAccountSubscriptionsid(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(
		 params: { data?: AccountSubscription },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountSubscriptionReplaceOrCreatePutAccountSubscriptions(
		 params: { data?: AccountSubscription },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionReplaceOrCreatePutAccountSubscriptions(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountSubscriptionUpdateAll(
		 params: { where?: string; data?: AccountSubscription },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionUpdateAll(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountSubscriptionUpsertWithWhere(
		 params: { where?: string; data?: AccountSubscription },
		 options?: any
	 ) {
		 return AccountSubscriptionApiFp.accountSubscriptionUpsertWithWhere(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
 }
 
 /**
  * AccountSubscriptionApi - factory interface
  */
 export const AccountSubscriptionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 accountSubscriptionCount(params: { where?: string }, options?: any) {
			 return AccountSubscriptionApiFp.accountSubscriptionCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 accountSubscriptionCreate(params: { data?: AccountSubscription }, options?: any) {
			 return AccountSubscriptionApiFp.accountSubscriptionCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 accountSubscriptionDeleteById(params: { id: string }, options?: any) {
			 return AccountSubscriptionApiFp.accountSubscriptionDeleteById(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountSubscriptionExistsGetAccountSubscriptionsidExists(
			 params: { id: string },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionExistsGetAccountSubscriptionsidExists(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountSubscriptionExistsHeadAccountSubscriptionsid(params: { id: string }, options?: any) {
			 return AccountSubscriptionApiFp.accountSubscriptionExistsHeadAccountSubscriptionsid(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountSubscriptionFind(params: { filter?: string }, options?: any) {
			 return AccountSubscriptionApiFp.accountSubscriptionFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 accountSubscriptionFindById(params: { id: string; filter?: string }, options?: any) {
			 return AccountSubscriptionApiFp.accountSubscriptionFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountSubscriptionFindOne(params: { filter?: string }, options?: any) {
			 return AccountSubscriptionApiFp.accountSubscriptionFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountSubscriptionPatchOrCreate(params: { data?: AccountSubscription }, options?: any) {
			 return AccountSubscriptionApiFp.accountSubscriptionPatchOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation account.
		  * @param id AccountSubscription id
		  * @param refresh
		  */
		 accountSubscriptionPrototypeGetAccount(
			 params: { id: string; refresh?: boolean },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionPrototypeGetAccount(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation subscription.
		  * @param id AccountSubscription id
		  * @param refresh
		  */
		 accountSubscriptionPrototypeGetSubscription(
			 params: { id: string; refresh?: boolean },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionPrototypeGetSubscription(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id AccountSubscription id
		  * @param data An object of model property name/value pairs
		  */
		 accountSubscriptionPrototypePatchAttributes(
			 params: { id: string; data?: AccountSubscription },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionPrototypePatchAttributes(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(
			 params: { id: string; data?: AccountSubscription },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountSubscriptionReplaceByIdPutAccountSubscriptionsid(
			 params: { id: string; data?: AccountSubscription },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionReplaceByIdPutAccountSubscriptionsid(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(
			 params: { data?: AccountSubscription },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountSubscriptionReplaceOrCreatePutAccountSubscriptions(
			 params: { data?: AccountSubscription },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionReplaceOrCreatePutAccountSubscriptions(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountSubscriptionUpdateAll(
			 params: { where?: string; data?: AccountSubscription },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionUpdateAll(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountSubscriptionUpsertWithWhere(
			 params: { where?: string; data?: AccountSubscription },
			 options?: any
		 ) {
			 return AccountSubscriptionApiFp.accountSubscriptionUpsertWithWhere(params, options)(
				 fetch,
				 basePath
			 );
		 },
	 };
 };
 
 /**
  * AccountTokenApi - fetch parameter creator
  */
 export const AccountTokenApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountTokenCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountTokens/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountTokenCreate(params: { data?: AccountToken }, options?: any): FetchArgs {
		 const baseUrl = `/AccountTokens`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountTokenCreateChangeStreamGetAccountTokensChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountTokens/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountTokenCreateChangeStreamPostAccountTokensChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountTokens/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountTokenDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountTokenDeleteById');
		 }
		 const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountTokenExistsGetAccountTokensidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountTokenExistsGetAccountTokensidExists'
			 );
		 }
		 const baseUrl = `/AccountTokens/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountTokenExistsHeadAccountTokensid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountTokenExistsHeadAccountTokensid'
			 );
		 }
		 const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountTokenFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountTokens`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountTokenFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountTokenFindById');
		 }
		 const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountTokenFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/AccountTokens/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountTokenPatchOrCreate(params: { data?: AccountToken }, options?: any): FetchArgs {
		 const baseUrl = `/AccountTokens`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation user.
	  * @param id AccountToken id
	  * @param refresh
	  */
	 accountTokenPrototypeGetUser(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling accountTokenPrototypeGetUser');
		 }
		 const baseUrl = `/AccountTokens/{id}/user`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountToken id
	  * @param data An object of model property name/value pairs
	  */
	 accountTokenPrototypePatchAttributes(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountTokenPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountTokenReplaceByIdPostAccountTokensidReplace(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountTokenReplaceByIdPostAccountTokensidReplace'
			 );
		 }
		 const baseUrl = `/AccountTokens/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountTokenReplaceByIdPutAccountTokensid(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling accountTokenReplaceByIdPutAccountTokensid'
			 );
		 }
		 const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(
		 params: { data?: AccountToken },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountTokens/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountTokenReplaceOrCreatePutAccountTokens(
		 params: { data?: AccountToken },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountTokens`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountTokenUpdateAll(params: { where?: string; data?: AccountToken }, options?: any): FetchArgs {
		 const baseUrl = `/AccountTokens/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountTokenUpsertWithWhere(
		 params: { where?: string; data?: AccountToken },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/AccountTokens/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * AccountTokenApi - functional programming interface
  */
 export const AccountTokenApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountTokenCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountTokenCreate(
		 params: { data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountTokenCreateChangeStreamGetAccountTokensChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamGetAccountTokensChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountTokenCreateChangeStreamPostAccountTokensChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamPostAccountTokensChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountTokenDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountTokenExistsGetAccountTokensidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenExistsGetAccountTokensidExists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountTokenExistsHeadAccountTokensid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenExistsHeadAccountTokensid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountTokenFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountToken>> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountTokenFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountTokenFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountTokenPatchOrCreate(
		 params: { data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation user.
	  * @param id AccountToken id
	  * @param refresh
	  */
	 accountTokenPrototypeGetUser(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPrototypeGetUser(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountToken id
	  * @param data An object of model property name/value pairs
	  */
	 accountTokenPrototypePatchAttributes(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountTokenReplaceByIdPostAccountTokensidReplace(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs =
			 AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPostAccountTokensidReplace(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountTokenReplaceByIdPutAccountTokensid(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPutAccountTokensid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(
		 params: { data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs =
			 AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountTokenReplaceOrCreatePutAccountTokens(
		 params: { data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePutAccountTokens(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountTokenUpdateAll(
		 params: { where?: string; data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountTokenUpsertWithWhere(
		 params: { where?: string; data?: AccountToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
		 const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * AccountTokenApi - object-oriented interface
  */
 export class AccountTokenApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 accountTokenCount(params: { where?: string }, options?: any) {
		 return AccountTokenApiFp.accountTokenCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 accountTokenCreate(params: { data?: AccountToken }, options?: any) {
		 return AccountTokenApiFp.accountTokenCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountTokenCreateChangeStreamGetAccountTokensChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 accountTokenCreateChangeStreamPostAccountTokensChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 accountTokenDeleteById(params: { id: string }, options?: any) {
		 return AccountTokenApiFp.accountTokenDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountTokenExistsGetAccountTokensidExists(params: { id: string }, options?: any) {
		 return AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 accountTokenExistsHeadAccountTokensid(params: { id: string }, options?: any) {
		 return AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountTokenFind(params: { filter?: string }, options?: any) {
		 return AccountTokenApiFp.accountTokenFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 accountTokenFindById(params: { id: string; filter?: string }, options?: any) {
		 return AccountTokenApiFp.accountTokenFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 accountTokenFindOne(params: { filter?: string }, options?: any) {
		 return AccountTokenApiFp.accountTokenFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountTokenPatchOrCreate(params: { data?: AccountToken }, options?: any) {
		 return AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation user.
	  * @param id AccountToken id
	  * @param refresh
	  */
	 accountTokenPrototypeGetUser(params: { id: string; refresh?: boolean }, options?: any) {
		 return AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id AccountToken id
	  * @param data An object of model property name/value pairs
	  */
	 accountTokenPrototypePatchAttributes(params: { id: string; data?: AccountToken }, options?: any) {
		 return AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountTokenReplaceByIdPostAccountTokensidReplace(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ) {
		 return AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 accountTokenReplaceByIdPutAccountTokensid(
		 params: { id: string; data?: AccountToken },
		 options?: any
	 ) {
		 return AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(
		 params: { data?: AccountToken },
		 options?: any
	 ) {
		 return AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 accountTokenReplaceOrCreatePutAccountTokens(params: { data?: AccountToken }, options?: any) {
		 return AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountTokenUpdateAll(params: { where?: string; data?: AccountToken }, options?: any) {
		 return AccountTokenApiFp.accountTokenUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 accountTokenUpsertWithWhere(params: { where?: string; data?: AccountToken }, options?: any) {
		 return AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
 }
 
 /**
  * AccountTokenApi - factory interface
  */
 export const AccountTokenApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 accountTokenCount(params: { where?: string }, options?: any) {
			 return AccountTokenApiFp.accountTokenCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 accountTokenCreate(params: { data?: AccountToken }, options?: any) {
			 return AccountTokenApiFp.accountTokenCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountTokenCreateChangeStreamGetAccountTokensChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 accountTokenCreateChangeStreamPostAccountTokensChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 accountTokenDeleteById(params: { id: string }, options?: any) {
			 return AccountTokenApiFp.accountTokenDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountTokenExistsGetAccountTokensidExists(params: { id: string }, options?: any) {
			 return AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 accountTokenExistsHeadAccountTokensid(params: { id: string }, options?: any) {
			 return AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountTokenFind(params: { filter?: string }, options?: any) {
			 return AccountTokenApiFp.accountTokenFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 accountTokenFindById(params: { id: string; filter?: string }, options?: any) {
			 return AccountTokenApiFp.accountTokenFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 accountTokenFindOne(params: { filter?: string }, options?: any) {
			 return AccountTokenApiFp.accountTokenFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountTokenPatchOrCreate(params: { data?: AccountToken }, options?: any) {
			 return AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation user.
		  * @param id AccountToken id
		  * @param refresh
		  */
		 accountTokenPrototypeGetUser(params: { id: string; refresh?: boolean }, options?: any) {
			 return AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id AccountToken id
		  * @param data An object of model property name/value pairs
		  */
		 accountTokenPrototypePatchAttributes(
			 params: { id: string; data?: AccountToken },
			 options?: any
		 ) {
			 return AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountTokenReplaceByIdPostAccountTokensidReplace(
			 params: { id: string; data?: AccountToken },
			 options?: any
		 ) {
			 return AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 accountTokenReplaceByIdPutAccountTokensid(
			 params: { id: string; data?: AccountToken },
			 options?: any
		 ) {
			 return AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(
			 params: { data?: AccountToken },
			 options?: any
		 ) {
			 return AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 accountTokenReplaceOrCreatePutAccountTokens(params: { data?: AccountToken }, options?: any) {
			 return AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountTokenUpdateAll(params: { where?: string; data?: AccountToken }, options?: any) {
			 return AccountTokenApiFp.accountTokenUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 accountTokenUpsertWithWhere(params: { where?: string; data?: AccountToken }, options?: any) {
			 return AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * ArtistApi - fetch parameter creator
  */
 export const ArtistApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 artistCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Artists/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 artistCreate(params: { data?: Artist }, options?: any): FetchArgs {
		 const baseUrl = `/Artists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 artistCreateChangeStreamGetArtistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Artists/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 artistCreateChangeStreamPostArtistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Artists/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 artistDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling artistDeleteById');
		 }
		 const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 artistExistsGetArtistsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling artistExistsGetArtistsidExists');
		 }
		 const baseUrl = `/Artists/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 artistExistsHeadArtistsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling artistExistsHeadArtistsid');
		 }
		 const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 artistFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Artists`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 artistFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling artistFindById');
		 }
		 const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 artistFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Artists/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 artistPatchOrCreate(params: { data?: Artist }, options?: any): FetchArgs {
		 const baseUrl = `/Artists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Artist id
	  * @param data An object of model property name/value pairs
	  */
	 artistPrototypePatchAttributes(params: { id: string; data?: Artist }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling artistPrototypePatchAttributes');
		 }
		 const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 artistReplaceByIdPostArtistsidReplace(
		 params: { id: string; data?: Artist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling artistReplaceByIdPostArtistsidReplace'
			 );
		 }
		 const baseUrl = `/Artists/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 artistReplaceByIdPutArtistsid(params: { id: string; data?: Artist }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling artistReplaceByIdPutArtistsid');
		 }
		 const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 artistReplaceOrCreatePostArtistsReplaceOrCreate(
		 params: { data?: Artist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Artists/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 artistReplaceOrCreatePutArtists(params: { data?: Artist }, options?: any): FetchArgs {
		 const baseUrl = `/Artists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 artistUpdateAll(params: { where?: string; data?: Artist }, options?: any): FetchArgs {
		 const baseUrl = `/Artists/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 artistUpsertWithWhere(params: { where?: string; data?: Artist }, options?: any): FetchArgs {
		 const baseUrl = `/Artists/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * ArtistApi - functional programming interface
  */
 export const ArtistApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 artistCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 artistCreate(
		 params: { data?: Artist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 artistCreateChangeStreamGetArtistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistCreateChangeStreamGetArtistsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 artistCreateChangeStreamPostArtistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistCreateChangeStreamPostArtistsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 artistDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 artistExistsGetArtistsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistExistsGetArtistsidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 artistExistsHeadArtistsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistExistsHeadArtistsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 artistFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Artist>> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 artistFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 artistFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 artistPatchOrCreate(
		 params: { data?: Artist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Artist id
	  * @param data An object of model property name/value pairs
	  */
	 artistPrototypePatchAttributes(
		 params: { id: string; data?: Artist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistPrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 artistReplaceByIdPostArtistsidReplace(
		 params: { id: string; data?: Artist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistReplaceByIdPostArtistsidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 artistReplaceByIdPutArtistsid(
		 params: { id: string; data?: Artist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistReplaceByIdPutArtistsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 artistReplaceOrCreatePostArtistsReplaceOrCreate(
		 params: { data?: Artist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistReplaceOrCreatePostArtistsReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 artistReplaceOrCreatePutArtists(
		 params: { data?: Artist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistReplaceOrCreatePutArtists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 artistUpdateAll(
		 params: { where?: string; data?: Artist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 artistUpsertWithWhere(
		 params: { where?: string; data?: Artist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Artist> {
		 const fetchArgs = ArtistApiFetchParamCreator.artistUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * ArtistApi - object-oriented interface
  */
 export class ArtistApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 artistCount(params: { where?: string }, options?: any) {
		 return ArtistApiFp.artistCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 artistCreate(params: { data?: Artist }, options?: any) {
		 return ArtistApiFp.artistCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 artistCreateChangeStreamGetArtistsChangeStream(params: { options?: string }, options?: any) {
		 return ArtistApiFp.artistCreateChangeStreamGetArtistsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 artistCreateChangeStreamPostArtistsChangeStream(params: { options?: string }, options?: any) {
		 return ArtistApiFp.artistCreateChangeStreamPostArtistsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 artistDeleteById(params: { id: string }, options?: any) {
		 return ArtistApiFp.artistDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 artistExistsGetArtistsidExists(params: { id: string }, options?: any) {
		 return ArtistApiFp.artistExistsGetArtistsidExists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 artistExistsHeadArtistsid(params: { id: string }, options?: any) {
		 return ArtistApiFp.artistExistsHeadArtistsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 artistFind(params: { filter?: string }, options?: any) {
		 return ArtistApiFp.artistFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 artistFindById(params: { id: string; filter?: string }, options?: any) {
		 return ArtistApiFp.artistFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 artistFindOne(params: { filter?: string }, options?: any) {
		 return ArtistApiFp.artistFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 artistPatchOrCreate(params: { data?: Artist }, options?: any) {
		 return ArtistApiFp.artistPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Artist id
	  * @param data An object of model property name/value pairs
	  */
	 artistPrototypePatchAttributes(params: { id: string; data?: Artist }, options?: any) {
		 return ArtistApiFp.artistPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 artistReplaceByIdPostArtistsidReplace(params: { id: string; data?: Artist }, options?: any) {
		 return ArtistApiFp.artistReplaceByIdPostArtistsidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 artistReplaceByIdPutArtistsid(params: { id: string; data?: Artist }, options?: any) {
		 return ArtistApiFp.artistReplaceByIdPutArtistsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 artistReplaceOrCreatePostArtistsReplaceOrCreate(params: { data?: Artist }, options?: any) {
		 return ArtistApiFp.artistReplaceOrCreatePostArtistsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 artistReplaceOrCreatePutArtists(params: { data?: Artist }, options?: any) {
		 return ArtistApiFp.artistReplaceOrCreatePutArtists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 artistUpdateAll(params: { where?: string; data?: Artist }, options?: any) {
		 return ArtistApiFp.artistUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 artistUpsertWithWhere(params: { where?: string; data?: Artist }, options?: any) {
		 return ArtistApiFp.artistUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * ArtistApi - factory interface
  */
 export const ArtistApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 artistCount(params: { where?: string }, options?: any) {
			 return ArtistApiFp.artistCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 artistCreate(params: { data?: Artist }, options?: any) {
			 return ArtistApiFp.artistCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 artistCreateChangeStreamGetArtistsChangeStream(params: { options?: string }, options?: any) {
			 return ArtistApiFp.artistCreateChangeStreamGetArtistsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 artistCreateChangeStreamPostArtistsChangeStream(params: { options?: string }, options?: any) {
			 return ArtistApiFp.artistCreateChangeStreamPostArtistsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 artistDeleteById(params: { id: string }, options?: any) {
			 return ArtistApiFp.artistDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 artistExistsGetArtistsidExists(params: { id: string }, options?: any) {
			 return ArtistApiFp.artistExistsGetArtistsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 artistExistsHeadArtistsid(params: { id: string }, options?: any) {
			 return ArtistApiFp.artistExistsHeadArtistsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 artistFind(params: { filter?: string }, options?: any) {
			 return ArtistApiFp.artistFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 artistFindById(params: { id: string; filter?: string }, options?: any) {
			 return ArtistApiFp.artistFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 artistFindOne(params: { filter?: string }, options?: any) {
			 return ArtistApiFp.artistFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 artistPatchOrCreate(params: { data?: Artist }, options?: any) {
			 return ArtistApiFp.artistPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Artist id
		  * @param data An object of model property name/value pairs
		  */
		 artistPrototypePatchAttributes(params: { id: string; data?: Artist }, options?: any) {
			 return ArtistApiFp.artistPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 artistReplaceByIdPostArtistsidReplace(params: { id: string; data?: Artist }, options?: any) {
			 return ArtistApiFp.artistReplaceByIdPostArtistsidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 artistReplaceByIdPutArtistsid(params: { id: string; data?: Artist }, options?: any) {
			 return ArtistApiFp.artistReplaceByIdPutArtistsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 artistReplaceOrCreatePostArtistsReplaceOrCreate(params: { data?: Artist }, options?: any) {
			 return ArtistApiFp.artistReplaceOrCreatePostArtistsReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 artistReplaceOrCreatePutArtists(params: { data?: Artist }, options?: any) {
			 return ArtistApiFp.artistReplaceOrCreatePutArtists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 artistUpdateAll(params: { where?: string; data?: Artist }, options?: any) {
			 return ArtistApiFp.artistUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 artistUpsertWithWhere(params: { where?: string; data?: Artist }, options?: any) {
			 return ArtistApiFp.artistUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * BillApi - fetch parameter creator
  */
 export const BillApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 billCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Bills/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 billCreate(params: { data?: Bill }, options?: any): FetchArgs {
		 const baseUrl = `/Bills`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 billCreateChangeStreamGetBillsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Bills/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 billCreateChangeStreamPostBillsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Bills/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 billDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling billDeleteById');
		 }
		 const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 billExistsGetBillsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling billExistsGetBillsidExists');
		 }
		 const baseUrl = `/Bills/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 billExistsHeadBillsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling billExistsHeadBillsid');
		 }
		 const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 billFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Bills`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 billFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling billFindById');
		 }
		 const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 billFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Bills/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 billPatchOrCreate(params: { data?: Bill }, options?: any): FetchArgs {
		 const baseUrl = `/Bills`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Bill id
	  * @param data An object of model property name/value pairs
	  */
	 billPrototypePatchAttributes(params: { id: string; data?: Bill }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling billPrototypePatchAttributes');
		 }
		 const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 billReplaceByIdPostBillsidReplace(params: { id: string; data?: Bill }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling billReplaceByIdPostBillsidReplace'
			 );
		 }
		 const baseUrl = `/Bills/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 billReplaceByIdPutBillsid(params: { id: string; data?: Bill }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling billReplaceByIdPutBillsid');
		 }
		 const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 billReplaceOrCreatePostBillsReplaceOrCreate(params: { data?: Bill }, options?: any): FetchArgs {
		 const baseUrl = `/Bills/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 billReplaceOrCreatePutBills(params: { data?: Bill }, options?: any): FetchArgs {
		 const baseUrl = `/Bills`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 billUpdateAll(params: { where?: string; data?: Bill }, options?: any): FetchArgs {
		 const baseUrl = `/Bills/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 billUpsertWithWhere(params: { where?: string; data?: Bill }, options?: any): FetchArgs {
		 const baseUrl = `/Bills/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * BillApi - functional programming interface
  */
 export const BillApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 billCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = BillApiFetchParamCreator.billCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 billCreate(
		 params: { data?: Bill },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 billCreateChangeStreamGetBillsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = BillApiFetchParamCreator.billCreateChangeStreamGetBillsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 billCreateChangeStreamPostBillsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = BillApiFetchParamCreator.billCreateChangeStreamPostBillsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 billDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = BillApiFetchParamCreator.billDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 billExistsGetBillsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = BillApiFetchParamCreator.billExistsGetBillsidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 billExistsHeadBillsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = BillApiFetchParamCreator.billExistsHeadBillsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 billFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Bill>> {
		 const fetchArgs = BillApiFetchParamCreator.billFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 billFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 billFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 billPatchOrCreate(
		 params: { data?: Bill },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Bill id
	  * @param data An object of model property name/value pairs
	  */
	 billPrototypePatchAttributes(
		 params: { id: string; data?: Bill },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billPrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 billReplaceByIdPostBillsidReplace(
		 params: { id: string; data?: Bill },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billReplaceByIdPostBillsidReplace(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 billReplaceByIdPutBillsid(
		 params: { id: string; data?: Bill },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billReplaceByIdPutBillsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 billReplaceOrCreatePostBillsReplaceOrCreate(
		 params: { data?: Bill },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billReplaceOrCreatePostBillsReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 billReplaceOrCreatePutBills(
		 params: { data?: Bill },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billReplaceOrCreatePutBills(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 billUpdateAll(
		 params: { where?: string; data?: Bill },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = BillApiFetchParamCreator.billUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 billUpsertWithWhere(
		 params: { where?: string; data?: Bill },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Bill> {
		 const fetchArgs = BillApiFetchParamCreator.billUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * BillApi - object-oriented interface
  */
 export class BillApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 billCount(params: { where?: string }, options?: any) {
		 return BillApiFp.billCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 billCreate(params: { data?: Bill }, options?: any) {
		 return BillApiFp.billCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 billCreateChangeStreamGetBillsChangeStream(params: { options?: string }, options?: any) {
		 return BillApiFp.billCreateChangeStreamGetBillsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 billCreateChangeStreamPostBillsChangeStream(params: { options?: string }, options?: any) {
		 return BillApiFp.billCreateChangeStreamPostBillsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 billDeleteById(params: { id: string }, options?: any) {
		 return BillApiFp.billDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 billExistsGetBillsidExists(params: { id: string }, options?: any) {
		 return BillApiFp.billExistsGetBillsidExists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 billExistsHeadBillsid(params: { id: string }, options?: any) {
		 return BillApiFp.billExistsHeadBillsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 billFind(params: { filter?: string }, options?: any) {
		 return BillApiFp.billFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 billFindById(params: { id: string; filter?: string }, options?: any) {
		 return BillApiFp.billFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 billFindOne(params: { filter?: string }, options?: any) {
		 return BillApiFp.billFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 billPatchOrCreate(params: { data?: Bill }, options?: any) {
		 return BillApiFp.billPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Bill id
	  * @param data An object of model property name/value pairs
	  */
	 billPrototypePatchAttributes(params: { id: string; data?: Bill }, options?: any) {
		 return BillApiFp.billPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 billReplaceByIdPostBillsidReplace(params: { id: string; data?: Bill }, options?: any) {
		 return BillApiFp.billReplaceByIdPostBillsidReplace(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 billReplaceByIdPutBillsid(params: { id: string; data?: Bill }, options?: any) {
		 return BillApiFp.billReplaceByIdPutBillsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 billReplaceOrCreatePostBillsReplaceOrCreate(params: { data?: Bill }, options?: any) {
		 return BillApiFp.billReplaceOrCreatePostBillsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 billReplaceOrCreatePutBills(params: { data?: Bill }, options?: any) {
		 return BillApiFp.billReplaceOrCreatePutBills(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 billUpdateAll(params: { where?: string; data?: Bill }, options?: any) {
		 return BillApiFp.billUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 billUpsertWithWhere(params: { where?: string; data?: Bill }, options?: any) {
		 return BillApiFp.billUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * BillApi - factory interface
  */
 export const BillApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 billCount(params: { where?: string }, options?: any) {
			 return BillApiFp.billCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 billCreate(params: { data?: Bill }, options?: any) {
			 return BillApiFp.billCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 billCreateChangeStreamGetBillsChangeStream(params: { options?: string }, options?: any) {
			 return BillApiFp.billCreateChangeStreamGetBillsChangeStream(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 billCreateChangeStreamPostBillsChangeStream(params: { options?: string }, options?: any) {
			 return BillApiFp.billCreateChangeStreamPostBillsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 billDeleteById(params: { id: string }, options?: any) {
			 return BillApiFp.billDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 billExistsGetBillsidExists(params: { id: string }, options?: any) {
			 return BillApiFp.billExistsGetBillsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 billExistsHeadBillsid(params: { id: string }, options?: any) {
			 return BillApiFp.billExistsHeadBillsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 billFind(params: { filter?: string }, options?: any) {
			 return BillApiFp.billFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 billFindById(params: { id: string; filter?: string }, options?: any) {
			 return BillApiFp.billFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 billFindOne(params: { filter?: string }, options?: any) {
			 return BillApiFp.billFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 billPatchOrCreate(params: { data?: Bill }, options?: any) {
			 return BillApiFp.billPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Bill id
		  * @param data An object of model property name/value pairs
		  */
		 billPrototypePatchAttributes(params: { id: string; data?: Bill }, options?: any) {
			 return BillApiFp.billPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 billReplaceByIdPostBillsidReplace(params: { id: string; data?: Bill }, options?: any) {
			 return BillApiFp.billReplaceByIdPostBillsidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 billReplaceByIdPutBillsid(params: { id: string; data?: Bill }, options?: any) {
			 return BillApiFp.billReplaceByIdPutBillsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 billReplaceOrCreatePostBillsReplaceOrCreate(params: { data?: Bill }, options?: any) {
			 return BillApiFp.billReplaceOrCreatePostBillsReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 billReplaceOrCreatePutBills(params: { data?: Bill }, options?: any) {
			 return BillApiFp.billReplaceOrCreatePutBills(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 billUpdateAll(params: { where?: string; data?: Bill }, options?: any) {
			 return BillApiFp.billUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 billUpsertWithWhere(params: { where?: string; data?: Bill }, options?: any) {
			 return BillApiFp.billUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * BusinessTypeApi - fetch parameter creator
  */
 export const BusinessTypeApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 businessTypeCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/BusinessTypes/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 businessTypeCreate(params: { data?: BusinessType }, options?: any): FetchArgs {
		 const baseUrl = `/BusinessTypes`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 businessTypeCreateChangeStreamGetBusinessTypesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/BusinessTypes/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 businessTypeCreateChangeStreamPostBusinessTypesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/BusinessTypes/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 businessTypeDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling businessTypeDeleteById');
		 }
		 const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 businessTypeExistsGetBusinessTypesidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypeExistsGetBusinessTypesidExists'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 businessTypeExistsHeadBusinessTypesid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypeExistsHeadBusinessTypesid'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 businessTypeFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/BusinessTypes`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 businessTypeFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling businessTypeFindById');
		 }
		 const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 businessTypeFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/BusinessTypes/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 businessTypePatchOrCreate(params: { data?: BusinessType }, options?: any): FetchArgs {
		 const baseUrl = `/BusinessTypes`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts account of BusinessType.
	  * @param id BusinessType id
	  * @param where Criteria to match model instances
	  */
	 businessTypePrototypeCountAccount(
		 params: { id: string; where?: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypePrototypeCountAccount'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}/account/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in account of this model.
	  * @param id BusinessType id
	  * @param data
	  */
	 businessTypePrototypeCreateAccount(
		 params: { id: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypePrototypeCreateAccount'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all account of this model.
	  * @param id BusinessType id
	  */
	 businessTypePrototypeDeleteAccount(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypePrototypeDeleteAccount'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for account.
	  * @param id BusinessType id
	  * @param fk Foreign key for account
	  */
	 businessTypePrototypeDestroyByIdAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypePrototypeDestroyByIdAccount'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling businessTypePrototypeDestroyByIdAccount'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}/account/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for account.
	  * @param id BusinessType id
	  * @param fk Foreign key for account
	  */
	 businessTypePrototypeFindByIdAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypePrototypeFindByIdAccount'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling businessTypePrototypeFindByIdAccount'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}/account/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries account of BusinessType.
	  * @param id BusinessType id
	  * @param filter
	  */
	 businessTypePrototypeGetAccount(
		 params: { id: string; filter?: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling businessTypePrototypeGetAccount');
		 }
		 const baseUrl = `/BusinessTypes/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id BusinessType id
	  * @param data An object of model property name/value pairs
	  */
	 businessTypePrototypePatchAttributes(
		 params: { id: string; data?: BusinessType },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypePrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for account.
	  * @param id BusinessType id
	  * @param fk Foreign key for account
	  * @param data
	  */
	 businessTypePrototypeUpdateByIdAccount(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypePrototypeUpdateByIdAccount'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling businessTypePrototypeUpdateByIdAccount'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}/account/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 businessTypeReplaceByIdPostBusinessTypesidReplace(
		 params: { id: string; data?: BusinessType },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypeReplaceByIdPostBusinessTypesidReplace'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 businessTypeReplaceByIdPutBusinessTypesid(
		 params: { id: string; data?: BusinessType },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling businessTypeReplaceByIdPutBusinessTypesid'
			 );
		 }
		 const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(
		 params: { data?: BusinessType },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/BusinessTypes/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 businessTypeReplaceOrCreatePutBusinessTypes(
		 params: { data?: BusinessType },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/BusinessTypes`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 businessTypeUpdateAll(params: { where?: string; data?: BusinessType }, options?: any): FetchArgs {
		 const baseUrl = `/BusinessTypes/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 businessTypeUpsertWithWhere(
		 params: { where?: string; data?: BusinessType },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/BusinessTypes/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * BusinessTypeApi - functional programming interface
  */
 export const BusinessTypeApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 businessTypeCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 businessTypeCreate(
		 params: { data?: BusinessType },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 businessTypeCreateChangeStreamGetBusinessTypesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 BusinessTypeApiFetchParamCreator.businessTypeCreateChangeStreamGetBusinessTypesChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 businessTypeCreateChangeStreamPostBusinessTypesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 BusinessTypeApiFetchParamCreator.businessTypeCreateChangeStreamPostBusinessTypesChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 businessTypeDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 businessTypeExistsGetBusinessTypesidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeExistsGetBusinessTypesidExists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 businessTypeExistsHeadBusinessTypesid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeExistsHeadBusinessTypesid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 businessTypeFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BusinessType>> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 businessTypeFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 businessTypeFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 businessTypePatchOrCreate(
		 params: { data?: BusinessType },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypePatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts account of BusinessType.
	  * @param id BusinessType id
	  * @param where Criteria to match model instances
	  */
	 businessTypePrototypeCountAccount(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypePrototypeCountAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in account of this model.
	  * @param id BusinessType id
	  * @param data
	  */
	 businessTypePrototypeCreateAccount(
		 params: { id: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypePrototypeCreateAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all account of this model.
	  * @param id BusinessType id
	  */
	 businessTypePrototypeDeleteAccount(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypePrototypeDeleteAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for account.
	  * @param id BusinessType id
	  * @param fk Foreign key for account
	  */
	 businessTypePrototypeDestroyByIdAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypePrototypeDestroyByIdAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for account.
	  * @param id BusinessType id
	  * @param fk Foreign key for account
	  */
	 businessTypePrototypeFindByIdAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypePrototypeFindByIdAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries account of BusinessType.
	  * @param id BusinessType id
	  * @param filter
	  */
	 businessTypePrototypeGetAccount(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypePrototypeGetAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id BusinessType id
	  * @param data An object of model property name/value pairs
	  */
	 businessTypePrototypePatchAttributes(
		 params: { id: string; data?: BusinessType },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypePrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for account.
	  * @param id BusinessType id
	  * @param fk Foreign key for account
	  * @param data
	  */
	 businessTypePrototypeUpdateByIdAccount(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypePrototypeUpdateByIdAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 businessTypeReplaceByIdPostBusinessTypesidReplace(
		 params: { id: string; data?: BusinessType },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs =
			 BusinessTypeApiFetchParamCreator.businessTypeReplaceByIdPostBusinessTypesidReplace(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 businessTypeReplaceByIdPutBusinessTypesid(
		 params: { id: string; data?: BusinessType },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeReplaceByIdPutBusinessTypesid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(
		 params: { data?: BusinessType },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs =
			 BusinessTypeApiFetchParamCreator.businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 businessTypeReplaceOrCreatePutBusinessTypes(
		 params: { data?: BusinessType },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeReplaceOrCreatePutBusinessTypes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 businessTypeUpdateAll(
		 params: { where?: string; data?: BusinessType },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 businessTypeUpsertWithWhere(
		 params: { where?: string; data?: BusinessType },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessType> {
		 const fetchArgs = BusinessTypeApiFetchParamCreator.businessTypeUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * BusinessTypeApi - object-oriented interface
  */
 export class BusinessTypeApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 businessTypeCount(params: { where?: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypeCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 businessTypeCreate(params: { data?: BusinessType }, options?: any) {
		 return BusinessTypeApiFp.businessTypeCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 businessTypeCreateChangeStreamGetBusinessTypesChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return BusinessTypeApiFp.businessTypeCreateChangeStreamGetBusinessTypesChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 businessTypeCreateChangeStreamPostBusinessTypesChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return BusinessTypeApiFp.businessTypeCreateChangeStreamPostBusinessTypesChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 businessTypeDeleteById(params: { id: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypeDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 businessTypeExistsGetBusinessTypesidExists(params: { id: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypeExistsGetBusinessTypesidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 businessTypeExistsHeadBusinessTypesid(params: { id: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypeExistsHeadBusinessTypesid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 businessTypeFind(params: { filter?: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypeFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 businessTypeFindById(params: { id: string; filter?: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypeFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 businessTypeFindOne(params: { filter?: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypeFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 businessTypePatchOrCreate(params: { data?: BusinessType }, options?: any) {
		 return BusinessTypeApiFp.businessTypePatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts account of BusinessType.
	  * @param id BusinessType id
	  * @param where Criteria to match model instances
	  */
	 businessTypePrototypeCountAccount(params: { id: string; where?: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypePrototypeCountAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Creates a new instance in account of this model.
	  * @param id BusinessType id
	  * @param data
	  */
	 businessTypePrototypeCreateAccount(params: { id: string; data?: Account }, options?: any) {
		 return BusinessTypeApiFp.businessTypePrototypeCreateAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Deletes all account of this model.
	  * @param id BusinessType id
	  */
	 businessTypePrototypeDeleteAccount(params: { id: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypePrototypeDeleteAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for account.
	  * @param id BusinessType id
	  * @param fk Foreign key for account
	  */
	 businessTypePrototypeDestroyByIdAccount(params: { id: string; fk: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypePrototypeDestroyByIdAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a related item by id for account.
	  * @param id BusinessType id
	  * @param fk Foreign key for account
	  */
	 businessTypePrototypeFindByIdAccount(params: { id: string; fk: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypePrototypeFindByIdAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Queries account of BusinessType.
	  * @param id BusinessType id
	  * @param filter
	  */
	 businessTypePrototypeGetAccount(params: { id: string; filter?: string }, options?: any) {
		 return BusinessTypeApiFp.businessTypePrototypeGetAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id BusinessType id
	  * @param data An object of model property name/value pairs
	  */
	 businessTypePrototypePatchAttributes(params: { id: string; data?: BusinessType }, options?: any) {
		 return BusinessTypeApiFp.businessTypePrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for account.
	  * @param id BusinessType id
	  * @param fk Foreign key for account
	  * @param data
	  */
	 businessTypePrototypeUpdateByIdAccount(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ) {
		 return BusinessTypeApiFp.businessTypePrototypeUpdateByIdAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 businessTypeReplaceByIdPostBusinessTypesidReplace(
		 params: { id: string; data?: BusinessType },
		 options?: any
	 ) {
		 return BusinessTypeApiFp.businessTypeReplaceByIdPostBusinessTypesidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 businessTypeReplaceByIdPutBusinessTypesid(
		 params: { id: string; data?: BusinessType },
		 options?: any
	 ) {
		 return BusinessTypeApiFp.businessTypeReplaceByIdPutBusinessTypesid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(
		 params: { data?: BusinessType },
		 options?: any
	 ) {
		 return BusinessTypeApiFp.businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 businessTypeReplaceOrCreatePutBusinessTypes(params: { data?: BusinessType }, options?: any) {
		 return BusinessTypeApiFp.businessTypeReplaceOrCreatePutBusinessTypes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 businessTypeUpdateAll(params: { where?: string; data?: BusinessType }, options?: any) {
		 return BusinessTypeApiFp.businessTypeUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 businessTypeUpsertWithWhere(params: { where?: string; data?: BusinessType }, options?: any) {
		 return BusinessTypeApiFp.businessTypeUpsertWithWhere(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
 }
 
 /**
  * BusinessTypeApi - factory interface
  */
 export const BusinessTypeApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 businessTypeCount(params: { where?: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypeCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 businessTypeCreate(params: { data?: BusinessType }, options?: any) {
			 return BusinessTypeApiFp.businessTypeCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 businessTypeCreateChangeStreamGetBusinessTypesChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return BusinessTypeApiFp.businessTypeCreateChangeStreamGetBusinessTypesChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 businessTypeCreateChangeStreamPostBusinessTypesChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return BusinessTypeApiFp.businessTypeCreateChangeStreamPostBusinessTypesChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 businessTypeDeleteById(params: { id: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypeDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 businessTypeExistsGetBusinessTypesidExists(params: { id: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypeExistsGetBusinessTypesidExists(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 businessTypeExistsHeadBusinessTypesid(params: { id: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypeExistsHeadBusinessTypesid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 businessTypeFind(params: { filter?: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypeFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 businessTypeFindById(params: { id: string; filter?: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypeFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 businessTypeFindOne(params: { filter?: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypeFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 businessTypePatchOrCreate(params: { data?: BusinessType }, options?: any) {
			 return BusinessTypeApiFp.businessTypePatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts account of BusinessType.
		  * @param id BusinessType id
		  * @param where Criteria to match model instances
		  */
		 businessTypePrototypeCountAccount(params: { id: string; where?: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypePrototypeCountAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in account of this model.
		  * @param id BusinessType id
		  * @param data
		  */
		 businessTypePrototypeCreateAccount(params: { id: string; data?: Account }, options?: any) {
			 return BusinessTypeApiFp.businessTypePrototypeCreateAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all account of this model.
		  * @param id BusinessType id
		  */
		 businessTypePrototypeDeleteAccount(params: { id: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypePrototypeDeleteAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for account.
		  * @param id BusinessType id
		  * @param fk Foreign key for account
		  */
		 businessTypePrototypeDestroyByIdAccount(params: { id: string; fk: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypePrototypeDestroyByIdAccount(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Find a related item by id for account.
		  * @param id BusinessType id
		  * @param fk Foreign key for account
		  */
		 businessTypePrototypeFindByIdAccount(params: { id: string; fk: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypePrototypeFindByIdAccount(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Queries account of BusinessType.
		  * @param id BusinessType id
		  * @param filter
		  */
		 businessTypePrototypeGetAccount(params: { id: string; filter?: string }, options?: any) {
			 return BusinessTypeApiFp.businessTypePrototypeGetAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id BusinessType id
		  * @param data An object of model property name/value pairs
		  */
		 businessTypePrototypePatchAttributes(
			 params: { id: string; data?: BusinessType },
			 options?: any
		 ) {
			 return BusinessTypeApiFp.businessTypePrototypePatchAttributes(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update a related item by id for account.
		  * @param id BusinessType id
		  * @param fk Foreign key for account
		  * @param data
		  */
		 businessTypePrototypeUpdateByIdAccount(
			 params: { id: string; fk: string; data?: Account },
			 options?: any
		 ) {
			 return BusinessTypeApiFp.businessTypePrototypeUpdateByIdAccount(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 businessTypeReplaceByIdPostBusinessTypesidReplace(
			 params: { id: string; data?: BusinessType },
			 options?: any
		 ) {
			 return BusinessTypeApiFp.businessTypeReplaceByIdPostBusinessTypesidReplace(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 businessTypeReplaceByIdPutBusinessTypesid(
			 params: { id: string; data?: BusinessType },
			 options?: any
		 ) {
			 return BusinessTypeApiFp.businessTypeReplaceByIdPutBusinessTypesid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(
			 params: { data?: BusinessType },
			 options?: any
		 ) {
			 return BusinessTypeApiFp.businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 businessTypeReplaceOrCreatePutBusinessTypes(params: { data?: BusinessType }, options?: any) {
			 return BusinessTypeApiFp.businessTypeReplaceOrCreatePutBusinessTypes(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 businessTypeUpdateAll(params: { where?: string; data?: BusinessType }, options?: any) {
			 return BusinessTypeApiFp.businessTypeUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 businessTypeUpsertWithWhere(params: { where?: string; data?: BusinessType }, options?: any) {
			 return BusinessTypeApiFp.businessTypeUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * CartApi - fetch parameter creator
  */
 export const CartApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 cartCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Carts/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 cartCreate(params: { data?: Cart }, options?: any): FetchArgs {
		 const baseUrl = `/Carts`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 cartCreateChangeStreamGetCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Carts/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 cartCreateChangeStreamPostCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Carts/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 cartDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartDeleteById');
		 }
		 const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 cartExistsGetCartsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartExistsGetCartsidExists');
		 }
		 const baseUrl = `/Carts/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 cartExistsHeadCartsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartExistsHeadCartsid');
		 }
		 const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 cartFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Carts`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 cartFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartFindById');
		 }
		 const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 cartFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Carts/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 cartPatchOrCreate(params: { data?: Cart }, options?: any): FetchArgs {
		 const baseUrl = `/Carts`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts tracks of Cart.
	  * @param id Cart id
	  * @param where Criteria to match model instances
	  */
	 cartPrototypeCountTracks(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartPrototypeCountTracks');
		 }
		 const baseUrl = `/Carts/{id}/tracks/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in tracks of this model.
	  * @param id Cart id
	  * @param data
	  */
	 cartPrototypeCreateTracks(params: { id: string; data?: Track }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartPrototypeCreateTracks');
		 }
		 const baseUrl = `/Carts/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all tracks of this model.
	  * @param id Cart id
	  */
	 cartPrototypeDeleteTracks(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartPrototypeDeleteTracks');
		 }
		 const baseUrl = `/Carts/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for tracks.
	  * @param id Cart id
	  * @param fk Foreign key for tracks
	  */
	 cartPrototypeDestroyByIdTracks(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartPrototypeDestroyByIdTracks');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling cartPrototypeDestroyByIdTracks');
		 }
		 const baseUrl = `/Carts/{id}/tracks/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for tracks.
	  * @param id Cart id
	  * @param fk Foreign key for tracks
	  */
	 cartPrototypeFindByIdTracks(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartPrototypeFindByIdTracks');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling cartPrototypeFindByIdTracks');
		 }
		 const baseUrl = `/Carts/{id}/tracks/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Cart id
	  * @param refresh
	  */
	 cartPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartPrototypeGetAccount');
		 }
		 const baseUrl = `/Carts/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries tracks of Cart.
	  * @param id Cart id
	  * @param filter
	  */
	 cartPrototypeGetTracks(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartPrototypeGetTracks');
		 }
		 const baseUrl = `/Carts/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Cart id
	  * @param data An object of model property name/value pairs
	  */
	 cartPrototypePatchAttributes(params: { id: string; data?: Cart }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartPrototypePatchAttributes');
		 }
		 const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for tracks.
	  * @param id Cart id
	  * @param fk Foreign key for tracks
	  * @param data
	  */
	 cartPrototypeUpdateByIdTracks(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartPrototypeUpdateByIdTracks');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling cartPrototypeUpdateByIdTracks');
		 }
		 const baseUrl = `/Carts/{id}/tracks/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 cartReplaceByIdPostCartsidReplace(params: { id: string; data?: Cart }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling cartReplaceByIdPostCartsidReplace'
			 );
		 }
		 const baseUrl = `/Carts/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 cartReplaceByIdPutCartsid(params: { id: string; data?: Cart }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling cartReplaceByIdPutCartsid');
		 }
		 const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 cartReplaceOrCreatePostCartsReplaceOrCreate(params: { data?: Cart }, options?: any): FetchArgs {
		 const baseUrl = `/Carts/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 cartReplaceOrCreatePutCarts(params: { data?: Cart }, options?: any): FetchArgs {
		 const baseUrl = `/Carts`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 cartUpdateAll(params: { where?: string; data?: Cart }, options?: any): FetchArgs {
		 const baseUrl = `/Carts/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 cartUpsertWithWhere(params: { where?: string; data?: Cart }, options?: any): FetchArgs {
		 const baseUrl = `/Carts/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * CartApi - functional programming interface
  */
 export const CartApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 cartCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = CartApiFetchParamCreator.cartCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 cartCreate(
		 params: { data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 cartCreateChangeStreamGetCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = CartApiFetchParamCreator.cartCreateChangeStreamGetCartsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 cartCreateChangeStreamPostCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = CartApiFetchParamCreator.cartCreateChangeStreamPostCartsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 cartDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = CartApiFetchParamCreator.cartDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 cartExistsGetCartsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = CartApiFetchParamCreator.cartExistsGetCartsidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 cartExistsHeadCartsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = CartApiFetchParamCreator.cartExistsHeadCartsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 cartFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Cart>> {
		 const fetchArgs = CartApiFetchParamCreator.cartFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 cartFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 cartFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 cartPatchOrCreate(
		 params: { data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts tracks of Cart.
	  * @param id Cart id
	  * @param where Criteria to match model instances
	  */
	 cartPrototypeCountTracks(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = CartApiFetchParamCreator.cartPrototypeCountTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in tracks of this model.
	  * @param id Cart id
	  * @param data
	  */
	 cartPrototypeCreateTracks(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = CartApiFetchParamCreator.cartPrototypeCreateTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all tracks of this model.
	  * @param id Cart id
	  */
	 cartPrototypeDeleteTracks(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = CartApiFetchParamCreator.cartPrototypeDeleteTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for tracks.
	  * @param id Cart id
	  * @param fk Foreign key for tracks
	  */
	 cartPrototypeDestroyByIdTracks(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = CartApiFetchParamCreator.cartPrototypeDestroyByIdTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for tracks.
	  * @param id Cart id
	  * @param fk Foreign key for tracks
	  */
	 cartPrototypeFindByIdTracks(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = CartApiFetchParamCreator.cartPrototypeFindByIdTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Cart id
	  * @param refresh
	  */
	 cartPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = CartApiFetchParamCreator.cartPrototypeGetAccount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries tracks of Cart.
	  * @param id Cart id
	  * @param filter
	  */
	 cartPrototypeGetTracks(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
		 const fetchArgs = CartApiFetchParamCreator.cartPrototypeGetTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Cart id
	  * @param data An object of model property name/value pairs
	  */
	 cartPrototypePatchAttributes(
		 params: { id: string; data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartPrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for tracks.
	  * @param id Cart id
	  * @param fk Foreign key for tracks
	  * @param data
	  */
	 cartPrototypeUpdateByIdTracks(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = CartApiFetchParamCreator.cartPrototypeUpdateByIdTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 cartReplaceByIdPostCartsidReplace(
		 params: { id: string; data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartReplaceByIdPostCartsidReplace(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 cartReplaceByIdPutCartsid(
		 params: { id: string; data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartReplaceByIdPutCartsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 cartReplaceOrCreatePostCartsReplaceOrCreate(
		 params: { data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartReplaceOrCreatePostCartsReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 cartReplaceOrCreatePutCarts(
		 params: { data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartReplaceOrCreatePutCarts(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 cartUpdateAll(
		 params: { where?: string; data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = CartApiFetchParamCreator.cartUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 cartUpsertWithWhere(
		 params: { where?: string; data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = CartApiFetchParamCreator.cartUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * CartApi - object-oriented interface
  */
 export class CartApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 cartCount(params: { where?: string }, options?: any) {
		 return CartApiFp.cartCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 cartCreate(params: { data?: Cart }, options?: any) {
		 return CartApiFp.cartCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 cartCreateChangeStreamGetCartsChangeStream(params: { options?: string }, options?: any) {
		 return CartApiFp.cartCreateChangeStreamGetCartsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 cartCreateChangeStreamPostCartsChangeStream(params: { options?: string }, options?: any) {
		 return CartApiFp.cartCreateChangeStreamPostCartsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 cartDeleteById(params: { id: string }, options?: any) {
		 return CartApiFp.cartDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 cartExistsGetCartsidExists(params: { id: string }, options?: any) {
		 return CartApiFp.cartExistsGetCartsidExists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 cartExistsHeadCartsid(params: { id: string }, options?: any) {
		 return CartApiFp.cartExistsHeadCartsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 cartFind(params: { filter?: string }, options?: any) {
		 return CartApiFp.cartFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 cartFindById(params: { id: string; filter?: string }, options?: any) {
		 return CartApiFp.cartFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 cartFindOne(params: { filter?: string }, options?: any) {
		 return CartApiFp.cartFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 cartPatchOrCreate(params: { data?: Cart }, options?: any) {
		 return CartApiFp.cartPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts tracks of Cart.
	  * @param id Cart id
	  * @param where Criteria to match model instances
	  */
	 cartPrototypeCountTracks(params: { id: string; where?: string }, options?: any) {
		 return CartApiFp.cartPrototypeCountTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in tracks of this model.
	  * @param id Cart id
	  * @param data
	  */
	 cartPrototypeCreateTracks(params: { id: string; data?: Track }, options?: any) {
		 return CartApiFp.cartPrototypeCreateTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all tracks of this model.
	  * @param id Cart id
	  */
	 cartPrototypeDeleteTracks(params: { id: string }, options?: any) {
		 return CartApiFp.cartPrototypeDeleteTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for tracks.
	  * @param id Cart id
	  * @param fk Foreign key for tracks
	  */
	 cartPrototypeDestroyByIdTracks(params: { id: string; fk: string }, options?: any) {
		 return CartApiFp.cartPrototypeDestroyByIdTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for tracks.
	  * @param id Cart id
	  * @param fk Foreign key for tracks
	  */
	 cartPrototypeFindByIdTracks(params: { id: string; fk: string }, options?: any) {
		 return CartApiFp.cartPrototypeFindByIdTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Cart id
	  * @param refresh
	  */
	 cartPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
		 return CartApiFp.cartPrototypeGetAccount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries tracks of Cart.
	  * @param id Cart id
	  * @param filter
	  */
	 cartPrototypeGetTracks(params: { id: string; filter?: string }, options?: any) {
		 return CartApiFp.cartPrototypeGetTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Cart id
	  * @param data An object of model property name/value pairs
	  */
	 cartPrototypePatchAttributes(params: { id: string; data?: Cart }, options?: any) {
		 return CartApiFp.cartPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for tracks.
	  * @param id Cart id
	  * @param fk Foreign key for tracks
	  * @param data
	  */
	 cartPrototypeUpdateByIdTracks(params: { id: string; fk: string; data?: Track }, options?: any) {
		 return CartApiFp.cartPrototypeUpdateByIdTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 cartReplaceByIdPostCartsidReplace(params: { id: string; data?: Cart }, options?: any) {
		 return CartApiFp.cartReplaceByIdPostCartsidReplace(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 cartReplaceByIdPutCartsid(params: { id: string; data?: Cart }, options?: any) {
		 return CartApiFp.cartReplaceByIdPutCartsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 cartReplaceOrCreatePostCartsReplaceOrCreate(params: { data?: Cart }, options?: any) {
		 return CartApiFp.cartReplaceOrCreatePostCartsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 cartReplaceOrCreatePutCarts(params: { data?: Cart }, options?: any) {
		 return CartApiFp.cartReplaceOrCreatePutCarts(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 cartUpdateAll(params: { where?: string; data?: Cart }, options?: any) {
		 return CartApiFp.cartUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 cartUpsertWithWhere(params: { where?: string; data?: Cart }, options?: any) {
		 return CartApiFp.cartUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * CartApi - factory interface
  */
 export const CartApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 cartCount(params: { where?: string }, options?: any) {
			 return CartApiFp.cartCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 cartCreate(params: { data?: Cart }, options?: any) {
			 return CartApiFp.cartCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 cartCreateChangeStreamGetCartsChangeStream(params: { options?: string }, options?: any) {
			 return CartApiFp.cartCreateChangeStreamGetCartsChangeStream(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 cartCreateChangeStreamPostCartsChangeStream(params: { options?: string }, options?: any) {
			 return CartApiFp.cartCreateChangeStreamPostCartsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 cartDeleteById(params: { id: string }, options?: any) {
			 return CartApiFp.cartDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 cartExistsGetCartsidExists(params: { id: string }, options?: any) {
			 return CartApiFp.cartExistsGetCartsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 cartExistsHeadCartsid(params: { id: string }, options?: any) {
			 return CartApiFp.cartExistsHeadCartsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 cartFind(params: { filter?: string }, options?: any) {
			 return CartApiFp.cartFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 cartFindById(params: { id: string; filter?: string }, options?: any) {
			 return CartApiFp.cartFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 cartFindOne(params: { filter?: string }, options?: any) {
			 return CartApiFp.cartFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 cartPatchOrCreate(params: { data?: Cart }, options?: any) {
			 return CartApiFp.cartPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts tracks of Cart.
		  * @param id Cart id
		  * @param where Criteria to match model instances
		  */
		 cartPrototypeCountTracks(params: { id: string; where?: string }, options?: any) {
			 return CartApiFp.cartPrototypeCountTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in tracks of this model.
		  * @param id Cart id
		  * @param data
		  */
		 cartPrototypeCreateTracks(params: { id: string; data?: Track }, options?: any) {
			 return CartApiFp.cartPrototypeCreateTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all tracks of this model.
		  * @param id Cart id
		  */
		 cartPrototypeDeleteTracks(params: { id: string }, options?: any) {
			 return CartApiFp.cartPrototypeDeleteTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for tracks.
		  * @param id Cart id
		  * @param fk Foreign key for tracks
		  */
		 cartPrototypeDestroyByIdTracks(params: { id: string; fk: string }, options?: any) {
			 return CartApiFp.cartPrototypeDestroyByIdTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for tracks.
		  * @param id Cart id
		  * @param fk Foreign key for tracks
		  */
		 cartPrototypeFindByIdTracks(params: { id: string; fk: string }, options?: any) {
			 return CartApiFp.cartPrototypeFindByIdTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation account.
		  * @param id Cart id
		  * @param refresh
		  */
		 cartPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
			 return CartApiFp.cartPrototypeGetAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries tracks of Cart.
		  * @param id Cart id
		  * @param filter
		  */
		 cartPrototypeGetTracks(params: { id: string; filter?: string }, options?: any) {
			 return CartApiFp.cartPrototypeGetTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Cart id
		  * @param data An object of model property name/value pairs
		  */
		 cartPrototypePatchAttributes(params: { id: string; data?: Cart }, options?: any) {
			 return CartApiFp.cartPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for tracks.
		  * @param id Cart id
		  * @param fk Foreign key for tracks
		  * @param data
		  */
		 cartPrototypeUpdateByIdTracks(params: { id: string; fk: string; data?: Track }, options?: any) {
			 return CartApiFp.cartPrototypeUpdateByIdTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 cartReplaceByIdPostCartsidReplace(params: { id: string; data?: Cart }, options?: any) {
			 return CartApiFp.cartReplaceByIdPostCartsidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 cartReplaceByIdPutCartsid(params: { id: string; data?: Cart }, options?: any) {
			 return CartApiFp.cartReplaceByIdPutCartsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 cartReplaceOrCreatePostCartsReplaceOrCreate(params: { data?: Cart }, options?: any) {
			 return CartApiFp.cartReplaceOrCreatePostCartsReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 cartReplaceOrCreatePutCarts(params: { data?: Cart }, options?: any) {
			 return CartApiFp.cartReplaceOrCreatePutCarts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 cartUpdateAll(params: { where?: string; data?: Cart }, options?: any) {
			 return CartApiFp.cartUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 cartUpsertWithWhere(params: { where?: string; data?: Cart }, options?: any) {
			 return CartApiFp.cartUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * ComposeTrackApi - fetch parameter creator
  */
 export const ComposeTrackApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 composeTrackCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/ComposeTracks/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 composeTrackCreate(params: { data?: ComposeTrack }, options?: any): FetchArgs {
		 const baseUrl = `/ComposeTracks`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 composeTrackCreateChangeStreamGetComposeTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/ComposeTracks/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 composeTrackCreateChangeStreamPostComposeTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/ComposeTracks/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 composeTrackDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling composeTrackDeleteById');
		 }
		 const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 composeTrackExistsGetComposeTracksidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling composeTrackExistsGetComposeTracksidExists'
			 );
		 }
		 const baseUrl = `/ComposeTracks/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 composeTrackExistsHeadComposeTracksid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling composeTrackExistsHeadComposeTracksid'
			 );
		 }
		 const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 composeTrackFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/ComposeTracks`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 composeTrackFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling composeTrackFindById');
		 }
		 const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 composeTrackFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/ComposeTracks/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 composeTrackPatchOrCreate(params: { data?: ComposeTrack }, options?: any): FetchArgs {
		 const baseUrl = `/ComposeTracks`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id ComposeTrack id
	  * @param refresh
	  */
	 composeTrackPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling composeTrackPrototypeGetAccount');
		 }
		 const baseUrl = `/ComposeTracks/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id ComposeTrack id
	  * @param refresh
	  */
	 composeTrackPrototypeGetTrack(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling composeTrackPrototypeGetTrack');
		 }
		 const baseUrl = `/ComposeTracks/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id ComposeTrack id
	  * @param data An object of model property name/value pairs
	  */
	 composeTrackPrototypePatchAttributes(
		 params: { id: string; data?: ComposeTrack },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling composeTrackPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 composeTrackReplaceByIdPostComposeTracksidReplace(
		 params: { id: string; data?: ComposeTrack },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling composeTrackReplaceByIdPostComposeTracksidReplace'
			 );
		 }
		 const baseUrl = `/ComposeTracks/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 composeTrackReplaceByIdPutComposeTracksid(
		 params: { id: string; data?: ComposeTrack },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling composeTrackReplaceByIdPutComposeTracksid'
			 );
		 }
		 const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(
		 params: { data?: ComposeTrack },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/ComposeTracks/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 composeTrackReplaceOrCreatePutComposeTracks(
		 params: { data?: ComposeTrack },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/ComposeTracks`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 composeTrackUpdateAll(params: { where?: string; data?: ComposeTrack }, options?: any): FetchArgs {
		 const baseUrl = `/ComposeTracks/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 composeTrackUpsertWithWhere(
		 params: { where?: string; data?: ComposeTrack },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/ComposeTracks/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * ComposeTrackApi - functional programming interface
  */
 export const ComposeTrackApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 composeTrackCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 composeTrackCreate(
		 params: { data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 composeTrackCreateChangeStreamGetComposeTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 ComposeTrackApiFetchParamCreator.composeTrackCreateChangeStreamGetComposeTracksChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 composeTrackCreateChangeStreamPostComposeTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 ComposeTrackApiFetchParamCreator.composeTrackCreateChangeStreamPostComposeTracksChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 composeTrackDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 composeTrackExistsGetComposeTracksidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackExistsGetComposeTracksidExists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 composeTrackExistsHeadComposeTracksid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackExistsHeadComposeTracksid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 composeTrackFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComposeTrack>> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 composeTrackFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 composeTrackFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 composeTrackPatchOrCreate(
		 params: { data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id ComposeTrack id
	  * @param refresh
	  */
	 composeTrackPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackPrototypeGetAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id ComposeTrack id
	  * @param refresh
	  */
	 composeTrackPrototypeGetTrack(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackPrototypeGetTrack(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id ComposeTrack id
	  * @param data An object of model property name/value pairs
	  */
	 composeTrackPrototypePatchAttributes(
		 params: { id: string; data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 composeTrackReplaceByIdPostComposeTracksidReplace(
		 params: { id: string; data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs =
			 ComposeTrackApiFetchParamCreator.composeTrackReplaceByIdPostComposeTracksidReplace(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 composeTrackReplaceByIdPutComposeTracksid(
		 params: { id: string; data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackReplaceByIdPutComposeTracksid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(
		 params: { data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs =
			 ComposeTrackApiFetchParamCreator.composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 composeTrackReplaceOrCreatePutComposeTracks(
		 params: { data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackReplaceOrCreatePutComposeTracks(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 composeTrackUpdateAll(
		 params: { where?: string; data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 composeTrackUpsertWithWhere(
		 params: { where?: string; data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = ComposeTrackApiFetchParamCreator.composeTrackUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * ComposeTrackApi - object-oriented interface
  */
 export class ComposeTrackApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 composeTrackCount(params: { where?: string }, options?: any) {
		 return ComposeTrackApiFp.composeTrackCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 composeTrackCreate(params: { data?: ComposeTrack }, options?: any) {
		 return ComposeTrackApiFp.composeTrackCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 composeTrackCreateChangeStreamGetComposeTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return ComposeTrackApiFp.composeTrackCreateChangeStreamGetComposeTracksChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 composeTrackCreateChangeStreamPostComposeTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return ComposeTrackApiFp.composeTrackCreateChangeStreamPostComposeTracksChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 composeTrackDeleteById(params: { id: string }, options?: any) {
		 return ComposeTrackApiFp.composeTrackDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 composeTrackExistsGetComposeTracksidExists(params: { id: string }, options?: any) {
		 return ComposeTrackApiFp.composeTrackExistsGetComposeTracksidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 composeTrackExistsHeadComposeTracksid(params: { id: string }, options?: any) {
		 return ComposeTrackApiFp.composeTrackExistsHeadComposeTracksid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 composeTrackFind(params: { filter?: string }, options?: any) {
		 return ComposeTrackApiFp.composeTrackFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 composeTrackFindById(params: { id: string; filter?: string }, options?: any) {
		 return ComposeTrackApiFp.composeTrackFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 composeTrackFindOne(params: { filter?: string }, options?: any) {
		 return ComposeTrackApiFp.composeTrackFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 composeTrackPatchOrCreate(params: { data?: ComposeTrack }, options?: any) {
		 return ComposeTrackApiFp.composeTrackPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id ComposeTrack id
	  * @param refresh
	  */
	 composeTrackPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
		 return ComposeTrackApiFp.composeTrackPrototypeGetAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id ComposeTrack id
	  * @param refresh
	  */
	 composeTrackPrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
		 return ComposeTrackApiFp.composeTrackPrototypeGetTrack(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id ComposeTrack id
	  * @param data An object of model property name/value pairs
	  */
	 composeTrackPrototypePatchAttributes(params: { id: string; data?: ComposeTrack }, options?: any) {
		 return ComposeTrackApiFp.composeTrackPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 composeTrackReplaceByIdPostComposeTracksidReplace(
		 params: { id: string; data?: ComposeTrack },
		 options?: any
	 ) {
		 return ComposeTrackApiFp.composeTrackReplaceByIdPostComposeTracksidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 composeTrackReplaceByIdPutComposeTracksid(
		 params: { id: string; data?: ComposeTrack },
		 options?: any
	 ) {
		 return ComposeTrackApiFp.composeTrackReplaceByIdPutComposeTracksid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(
		 params: { data?: ComposeTrack },
		 options?: any
	 ) {
		 return ComposeTrackApiFp.composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 composeTrackReplaceOrCreatePutComposeTracks(params: { data?: ComposeTrack }, options?: any) {
		 return ComposeTrackApiFp.composeTrackReplaceOrCreatePutComposeTracks(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 composeTrackUpdateAll(params: { where?: string; data?: ComposeTrack }, options?: any) {
		 return ComposeTrackApiFp.composeTrackUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 composeTrackUpsertWithWhere(params: { where?: string; data?: ComposeTrack }, options?: any) {
		 return ComposeTrackApiFp.composeTrackUpsertWithWhere(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
 }
 
 /**
  * ComposeTrackApi - factory interface
  */
 export const ComposeTrackApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 composeTrackCount(params: { where?: string }, options?: any) {
			 return ComposeTrackApiFp.composeTrackCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 composeTrackCreate(params: { data?: ComposeTrack }, options?: any) {
			 return ComposeTrackApiFp.composeTrackCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 composeTrackCreateChangeStreamGetComposeTracksChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return ComposeTrackApiFp.composeTrackCreateChangeStreamGetComposeTracksChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 composeTrackCreateChangeStreamPostComposeTracksChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return ComposeTrackApiFp.composeTrackCreateChangeStreamPostComposeTracksChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 composeTrackDeleteById(params: { id: string }, options?: any) {
			 return ComposeTrackApiFp.composeTrackDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 composeTrackExistsGetComposeTracksidExists(params: { id: string }, options?: any) {
			 return ComposeTrackApiFp.composeTrackExistsGetComposeTracksidExists(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 composeTrackExistsHeadComposeTracksid(params: { id: string }, options?: any) {
			 return ComposeTrackApiFp.composeTrackExistsHeadComposeTracksid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 composeTrackFind(params: { filter?: string }, options?: any) {
			 return ComposeTrackApiFp.composeTrackFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 composeTrackFindById(params: { id: string; filter?: string }, options?: any) {
			 return ComposeTrackApiFp.composeTrackFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 composeTrackFindOne(params: { filter?: string }, options?: any) {
			 return ComposeTrackApiFp.composeTrackFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 composeTrackPatchOrCreate(params: { data?: ComposeTrack }, options?: any) {
			 return ComposeTrackApiFp.composeTrackPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation account.
		  * @param id ComposeTrack id
		  * @param refresh
		  */
		 composeTrackPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
			 return ComposeTrackApiFp.composeTrackPrototypeGetAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation track.
		  * @param id ComposeTrack id
		  * @param refresh
		  */
		 composeTrackPrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
			 return ComposeTrackApiFp.composeTrackPrototypeGetTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id ComposeTrack id
		  * @param data An object of model property name/value pairs
		  */
		 composeTrackPrototypePatchAttributes(
			 params: { id: string; data?: ComposeTrack },
			 options?: any
		 ) {
			 return ComposeTrackApiFp.composeTrackPrototypePatchAttributes(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 composeTrackReplaceByIdPostComposeTracksidReplace(
			 params: { id: string; data?: ComposeTrack },
			 options?: any
		 ) {
			 return ComposeTrackApiFp.composeTrackReplaceByIdPostComposeTracksidReplace(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 composeTrackReplaceByIdPutComposeTracksid(
			 params: { id: string; data?: ComposeTrack },
			 options?: any
		 ) {
			 return ComposeTrackApiFp.composeTrackReplaceByIdPutComposeTracksid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(
			 params: { data?: ComposeTrack },
			 options?: any
		 ) {
			 return ComposeTrackApiFp.composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 composeTrackReplaceOrCreatePutComposeTracks(params: { data?: ComposeTrack }, options?: any) {
			 return ComposeTrackApiFp.composeTrackReplaceOrCreatePutComposeTracks(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 composeTrackUpdateAll(params: { where?: string; data?: ComposeTrack }, options?: any) {
			 return ComposeTrackApiFp.composeTrackUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 composeTrackUpsertWithWhere(params: { where?: string; data?: ComposeTrack }, options?: any) {
			 return ComposeTrackApiFp.composeTrackUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * ContainerApi - fetch parameter creator
  */
 export const ContainerApiFetchParamCreator = {
	 /**
	  *
	  * @param options
	  */
	 containerCreateContainer(params: { options?: any }, options?: any): FetchArgs {
		 const baseUrl = `/Containers`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['options']) {
			 fetchOptions.body = JSON.stringify(params['options'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @param container
	  */
	 containerDestroyContainer(params: { container: string }, options?: any): FetchArgs {
		 // verify required parameter "container" is set
		 if (params['container'] == null) {
			 throw new Error(
				 'Missing required parameter container when calling containerDestroyContainer'
			 );
		 }
		 const baseUrl = `/Containers/{container}`.replace(`{${'container'}}`, `${params['container']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @param container
	  * @param file
	  */
	 containerDownload(params: { container: string; file: string }, options?: any): FetchArgs {
		 // verify required parameter "container" is set
		 if (params['container'] == null) {
			 throw new Error('Missing required parameter container when calling containerDownload');
		 }
		 // verify required parameter "file" is set
		 if (params['file'] == null) {
			 throw new Error('Missing required parameter file when calling containerDownload');
		 }
		 const baseUrl = `/Containers/{container}/download/{file}`
			 .replace(`{${'container'}}`, `${params['container']}`)
			 .replace(`{${'file'}}`, `${params['file']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @param container
	  */
	 containerGetContainer(params: { container: string }, options?: any): FetchArgs {
		 // verify required parameter "container" is set
		 if (params['container'] == null) {
			 throw new Error('Missing required parameter container when calling containerGetContainer');
		 }
		 const baseUrl = `/Containers/{container}`.replace(`{${'container'}}`, `${params['container']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  */
	 containerGetContainers(options?: any): FetchArgs {
		 const baseUrl = `/Containers`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @param container
	  * @param file
	  */
	 containerGetFile(params: { container: string; file: string }, options?: any): FetchArgs {
		 // verify required parameter "container" is set
		 if (params['container'] == null) {
			 throw new Error('Missing required parameter container when calling containerGetFile');
		 }
		 // verify required parameter "file" is set
		 if (params['file'] == null) {
			 throw new Error('Missing required parameter file when calling containerGetFile');
		 }
		 const baseUrl = `/Containers/{container}/files/{file}`
			 .replace(`{${'container'}}`, `${params['container']}`)
			 .replace(`{${'file'}}`, `${params['file']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @param container
	  */
	 containerGetFiles(params: { container: string }, options?: any): FetchArgs {
		 // verify required parameter "container" is set
		 if (params['container'] == null) {
			 throw new Error('Missing required parameter container when calling containerGetFiles');
		 }
		 const baseUrl = `/Containers/{container}/files`.replace(
			 `{${'container'}}`,
			 `${params['container']}`
		 );
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @param container
	  * @param file
	  */
	 containerRemoveFile(params: { container: string; file: string }, options?: any): FetchArgs {
		 // verify required parameter "container" is set
		 if (params['container'] == null) {
			 throw new Error('Missing required parameter container when calling containerRemoveFile');
		 }
		 // verify required parameter "file" is set
		 if (params['file'] == null) {
			 throw new Error('Missing required parameter file when calling containerRemoveFile');
		 }
		 const baseUrl = `/Containers/{container}/files/{file}`
			 .replace(`{${'container'}}`, `${params['container']}`)
			 .replace(`{${'file'}}`, `${params['file']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @param container
	  */
	 containerUpload(params: { container: string }, options?: any): FetchArgs {
		 // verify required parameter "container" is set
		 if (params['container'] == null) {
			 throw new Error('Missing required parameter container when calling containerUpload');
		 }
		 const baseUrl = `/Containers/{container}/upload`.replace(
			 `{${'container'}}`,
			 `${params['container']}`
		 );
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * ContainerApi - functional programming interface
  */
 export const ContainerApiFp = {
	 /**
	  *
	  * @param options
	  */
	 containerCreateContainer(
		 params: { options?: any },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ContainerApiFetchParamCreator.containerCreateContainer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @param container
	  */
	 containerDestroyContainer(
		 params: { container: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
		 const fetchArgs = ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @param container
	  * @param file
	  */
	 containerDownload(
		 params: { container: string; file: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ContainerApiFetchParamCreator.containerDownload(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @param container
	  */
	 containerGetContainer(
		 params: { container: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ContainerApiFetchParamCreator.containerGetContainer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  */
	 containerGetContainers(
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
		 const fetchArgs = ContainerApiFetchParamCreator.containerGetContainers(options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @param container
	  * @param file
	  */
	 containerGetFile(
		 params: { container: string; file: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ContainerApiFetchParamCreator.containerGetFile(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @param container
	  */
	 containerGetFiles(
		 params: { container: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
		 const fetchArgs = ContainerApiFetchParamCreator.containerGetFiles(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @param container
	  * @param file
	  */
	 containerRemoveFile(
		 params: { container: string; file: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
		 const fetchArgs = ContainerApiFetchParamCreator.containerRemoveFile(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @param container
	  */
	 containerUpload(
		 params: { container: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
		 const fetchArgs = ContainerApiFetchParamCreator.containerUpload(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * ContainerApi - object-oriented interface
  */
 export class ContainerApi extends BaseAPI {
	 /**
	  *
	  * @param options
	  */
	 containerCreateContainer(params: { options?: any }, options?: any) {
		 return ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @param container
	  */
	 containerDestroyContainer(params: { container: string }, options?: any) {
		 return ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @param container
	  * @param file
	  */
	 containerDownload(params: { container: string; file: string }, options?: any) {
		 return ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @param container
	  */
	 containerGetContainer(params: { container: string }, options?: any) {
		 return ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  */
	 containerGetContainers(options?: any) {
		 return ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @param container
	  * @param file
	  */
	 containerGetFile(params: { container: string; file: string }, options?: any) {
		 return ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @param container
	  */
	 containerGetFiles(params: { container: string }, options?: any) {
		 return ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @param container
	  * @param file
	  */
	 containerRemoveFile(params: { container: string; file: string }, options?: any) {
		 return ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @param container
	  */
	 containerUpload(params: { container: string }, options?: any) {
		 return ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * ContainerApi - factory interface
  */
 export const ContainerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @param options
		  */
		 containerCreateContainer(params: { options?: any }, options?: any) {
			 return ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @param container
		  */
		 containerDestroyContainer(params: { container: string }, options?: any) {
			 return ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @param container
		  * @param file
		  */
		 containerDownload(params: { container: string; file: string }, options?: any) {
			 return ContainerApiFp.containerDownload(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @param container
		  */
		 containerGetContainer(params: { container: string }, options?: any) {
			 return ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  */
		 containerGetContainers(options?: any) {
			 return ContainerApiFp.containerGetContainers(options)(fetch, basePath);
		 },
		 /**
		  *
		  * @param container
		  * @param file
		  */
		 containerGetFile(params: { container: string; file: string }, options?: any) {
			 return ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @param container
		  */
		 containerGetFiles(params: { container: string }, options?: any) {
			 return ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @param container
		  * @param file
		  */
		 containerRemoveFile(params: { container: string; file: string }, options?: any) {
			 return ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @param container
		  */
		 containerUpload(params: { container: string }, options?: any) {
			 return ContainerApiFp.containerUpload(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * DownloadApi - fetch parameter creator
  */
 export const DownloadApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 downloadCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Downloads/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 downloadCreate(params: { data?: Download }, options?: any): FetchArgs {
		 const baseUrl = `/Downloads`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 downloadCreateChangeStreamGetDownloadsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Downloads/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 downloadCreateChangeStreamPostDownloadsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Downloads/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 downloadDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling downloadDeleteById');
		 }
		 const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 downloadExistsGetDownloadsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling downloadExistsGetDownloadsidExists'
			 );
		 }
		 const baseUrl = `/Downloads/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 downloadExistsHeadDownloadsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling downloadExistsHeadDownloadsid');
		 }
		 const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 downloadFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Downloads`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 downloadFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling downloadFindById');
		 }
		 const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 downloadFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Downloads/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 downloadPatchOrCreate(params: { data?: Download }, options?: any): FetchArgs {
		 const baseUrl = `/Downloads`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation listeners.
	  * @param id Download id
	  * @param refresh
	  */
	 downloadPrototypeGetListeners(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling downloadPrototypeGetListeners');
		 }
		 const baseUrl = `/Downloads/{id}/listeners`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation trackDownload.
	  * @param id Download id
	  * @param refresh
	  */
	 downloadPrototypeGetTrackDownload(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling downloadPrototypeGetTrackDownload'
			 );
		 }
		 const baseUrl = `/Downloads/{id}/trackDownload`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Download id
	  * @param data An object of model property name/value pairs
	  */
	 downloadPrototypePatchAttributes(
		 params: { id: string; data?: Download },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling downloadPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 downloadReplaceByIdPostDownloadsidReplace(
		 params: { id: string; data?: Download },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling downloadReplaceByIdPostDownloadsidReplace'
			 );
		 }
		 const baseUrl = `/Downloads/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 downloadReplaceByIdPutDownloadsid(
		 params: { id: string; data?: Download },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling downloadReplaceByIdPutDownloadsid'
			 );
		 }
		 const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 downloadReplaceOrCreatePostDownloadsReplaceOrCreate(
		 params: { data?: Download },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Downloads/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 downloadReplaceOrCreatePutDownloads(params: { data?: Download }, options?: any): FetchArgs {
		 const baseUrl = `/Downloads`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 downloadUpdateAll(params: { where?: string; data?: Download }, options?: any): FetchArgs {
		 const baseUrl = `/Downloads/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 downloadUpsertWithWhere(params: { where?: string; data?: Download }, options?: any): FetchArgs {
		 const baseUrl = `/Downloads/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * DownloadApi - functional programming interface
  */
 export const DownloadApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 downloadCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 downloadCreate(
		 params: { data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 downloadCreateChangeStreamGetDownloadsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 DownloadApiFetchParamCreator.downloadCreateChangeStreamGetDownloadsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 downloadCreateChangeStreamPostDownloadsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 DownloadApiFetchParamCreator.downloadCreateChangeStreamPostDownloadsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 downloadDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 downloadExistsGetDownloadsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadExistsGetDownloadsidExists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 downloadExistsHeadDownloadsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadExistsHeadDownloadsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 downloadFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Download>> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 downloadFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 downloadFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 downloadPatchOrCreate(
		 params: { data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation listeners.
	  * @param id Download id
	  * @param refresh
	  */
	 downloadPrototypeGetListeners(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadPrototypeGetListeners(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation trackDownload.
	  * @param id Download id
	  * @param refresh
	  */
	 downloadPrototypeGetTrackDownload(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadPrototypeGetTrackDownload(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Download id
	  * @param data An object of model property name/value pairs
	  */
	 downloadPrototypePatchAttributes(
		 params: { id: string; data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 downloadReplaceByIdPostDownloadsidReplace(
		 params: { id: string; data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadReplaceByIdPostDownloadsidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 downloadReplaceByIdPutDownloadsid(
		 params: { id: string; data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadReplaceByIdPutDownloadsid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 downloadReplaceOrCreatePostDownloadsReplaceOrCreate(
		 params: { data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs =
			 DownloadApiFetchParamCreator.downloadReplaceOrCreatePostDownloadsReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 downloadReplaceOrCreatePutDownloads(
		 params: { data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadReplaceOrCreatePutDownloads(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 downloadUpdateAll(
		 params: { where?: string; data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 downloadUpsertWithWhere(
		 params: { where?: string; data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = DownloadApiFetchParamCreator.downloadUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * DownloadApi - object-oriented interface
  */
 export class DownloadApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 downloadCount(params: { where?: string }, options?: any) {
		 return DownloadApiFp.downloadCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 downloadCreate(params: { data?: Download }, options?: any) {
		 return DownloadApiFp.downloadCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 downloadCreateChangeStreamGetDownloadsChangeStream(params: { options?: string }, options?: any) {
		 return DownloadApiFp.downloadCreateChangeStreamGetDownloadsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 downloadCreateChangeStreamPostDownloadsChangeStream(params: { options?: string }, options?: any) {
		 return DownloadApiFp.downloadCreateChangeStreamPostDownloadsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 downloadDeleteById(params: { id: string }, options?: any) {
		 return DownloadApiFp.downloadDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 downloadExistsGetDownloadsidExists(params: { id: string }, options?: any) {
		 return DownloadApiFp.downloadExistsGetDownloadsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 downloadExistsHeadDownloadsid(params: { id: string }, options?: any) {
		 return DownloadApiFp.downloadExistsHeadDownloadsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 downloadFind(params: { filter?: string }, options?: any) {
		 return DownloadApiFp.downloadFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 downloadFindById(params: { id: string; filter?: string }, options?: any) {
		 return DownloadApiFp.downloadFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 downloadFindOne(params: { filter?: string }, options?: any) {
		 return DownloadApiFp.downloadFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 downloadPatchOrCreate(params: { data?: Download }, options?: any) {
		 return DownloadApiFp.downloadPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation listeners.
	  * @param id Download id
	  * @param refresh
	  */
	 downloadPrototypeGetListeners(params: { id: string; refresh?: boolean }, options?: any) {
		 return DownloadApiFp.downloadPrototypeGetListeners(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation trackDownload.
	  * @param id Download id
	  * @param refresh
	  */
	 downloadPrototypeGetTrackDownload(params: { id: string; refresh?: boolean }, options?: any) {
		 return DownloadApiFp.downloadPrototypeGetTrackDownload(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Download id
	  * @param data An object of model property name/value pairs
	  */
	 downloadPrototypePatchAttributes(params: { id: string; data?: Download }, options?: any) {
		 return DownloadApiFp.downloadPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 downloadReplaceByIdPostDownloadsidReplace(
		 params: { id: string; data?: Download },
		 options?: any
	 ) {
		 return DownloadApiFp.downloadReplaceByIdPostDownloadsidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 downloadReplaceByIdPutDownloadsid(params: { id: string; data?: Download }, options?: any) {
		 return DownloadApiFp.downloadReplaceByIdPutDownloadsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params: { data?: Download }, options?: any) {
		 return DownloadApiFp.downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 downloadReplaceOrCreatePutDownloads(params: { data?: Download }, options?: any) {
		 return DownloadApiFp.downloadReplaceOrCreatePutDownloads(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 downloadUpdateAll(params: { where?: string; data?: Download }, options?: any) {
		 return DownloadApiFp.downloadUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 downloadUpsertWithWhere(params: { where?: string; data?: Download }, options?: any) {
		 return DownloadApiFp.downloadUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * DownloadApi - factory interface
  */
 export const DownloadApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 downloadCount(params: { where?: string }, options?: any) {
			 return DownloadApiFp.downloadCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 downloadCreate(params: { data?: Download }, options?: any) {
			 return DownloadApiFp.downloadCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 downloadCreateChangeStreamGetDownloadsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return DownloadApiFp.downloadCreateChangeStreamGetDownloadsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 downloadCreateChangeStreamPostDownloadsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return DownloadApiFp.downloadCreateChangeStreamPostDownloadsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 downloadDeleteById(params: { id: string }, options?: any) {
			 return DownloadApiFp.downloadDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 downloadExistsGetDownloadsidExists(params: { id: string }, options?: any) {
			 return DownloadApiFp.downloadExistsGetDownloadsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 downloadExistsHeadDownloadsid(params: { id: string }, options?: any) {
			 return DownloadApiFp.downloadExistsHeadDownloadsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 downloadFind(params: { filter?: string }, options?: any) {
			 return DownloadApiFp.downloadFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 downloadFindById(params: { id: string; filter?: string }, options?: any) {
			 return DownloadApiFp.downloadFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 downloadFindOne(params: { filter?: string }, options?: any) {
			 return DownloadApiFp.downloadFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 downloadPatchOrCreate(params: { data?: Download }, options?: any) {
			 return DownloadApiFp.downloadPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation listeners.
		  * @param id Download id
		  * @param refresh
		  */
		 downloadPrototypeGetListeners(params: { id: string; refresh?: boolean }, options?: any) {
			 return DownloadApiFp.downloadPrototypeGetListeners(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation trackDownload.
		  * @param id Download id
		  * @param refresh
		  */
		 downloadPrototypeGetTrackDownload(params: { id: string; refresh?: boolean }, options?: any) {
			 return DownloadApiFp.downloadPrototypeGetTrackDownload(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Download id
		  * @param data An object of model property name/value pairs
		  */
		 downloadPrototypePatchAttributes(params: { id: string; data?: Download }, options?: any) {
			 return DownloadApiFp.downloadPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 downloadReplaceByIdPostDownloadsidReplace(
			 params: { id: string; data?: Download },
			 options?: any
		 ) {
			 return DownloadApiFp.downloadReplaceByIdPostDownloadsidReplace(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 downloadReplaceByIdPutDownloadsid(params: { id: string; data?: Download }, options?: any) {
			 return DownloadApiFp.downloadReplaceByIdPutDownloadsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 downloadReplaceOrCreatePostDownloadsReplaceOrCreate(
			 params: { data?: Download },
			 options?: any
		 ) {
			 return DownloadApiFp.downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 downloadReplaceOrCreatePutDownloads(params: { data?: Download }, options?: any) {
			 return DownloadApiFp.downloadReplaceOrCreatePutDownloads(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 downloadUpdateAll(params: { where?: string; data?: Download }, options?: any) {
			 return DownloadApiFp.downloadUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 downloadUpsertWithWhere(params: { where?: string; data?: Download }, options?: any) {
			 return DownloadApiFp.downloadUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * FeatureApi - fetch parameter creator
  */
 export const FeatureApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 featureCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Features/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 featureCreate(params: { data?: Feature }, options?: any): FetchArgs {
		 const baseUrl = `/Features`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 featureCreateChangeStreamGetFeaturesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Features/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 featureCreateChangeStreamPostFeaturesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Features/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 featureDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featureDeleteById');
		 }
		 const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 featureExistsGetFeaturesidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling featureExistsGetFeaturesidExists'
			 );
		 }
		 const baseUrl = `/Features/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 featureExistsHeadFeaturesid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featureExistsHeadFeaturesid');
		 }
		 const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 featureFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Features`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 featureFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featureFindById');
		 }
		 const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 featureFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Features/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 featurePatchOrCreate(params: { data?: Feature }, options?: any): FetchArgs {
		 const baseUrl = `/Features`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts track of Feature.
	  * @param id Feature id
	  * @param where Criteria to match model instances
	  */
	 featurePrototypeCountTrack(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeCountTrack');
		 }
		 const baseUrl = `/Features/{id}/track/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in track of this model.
	  * @param id Feature id
	  * @param data
	  */
	 featurePrototypeCreateTrack(params: { id: string; data?: Track }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeCreateTrack');
		 }
		 const baseUrl = `/Features/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all track of this model.
	  * @param id Feature id
	  */
	 featurePrototypeDeleteTrack(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeDeleteTrack');
		 }
		 const baseUrl = `/Features/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeDestroyByIdTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling featurePrototypeDestroyByIdTrack'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling featurePrototypeDestroyByIdTrack'
			 );
		 }
		 const baseUrl = `/Features/{id}/track/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of track relation to an item by id.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeExistsTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeExistsTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling featurePrototypeExistsTrack');
		 }
		 const baseUrl = `/Features/{id}/track/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeFindByIdTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeFindByIdTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling featurePrototypeFindByIdTrack');
		 }
		 const baseUrl = `/Features/{id}/track/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Feature id
	  * @param refresh
	  */
	 featurePrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeGetAccount');
		 }
		 const baseUrl = `/Features/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries track of Feature.
	  * @param id Feature id
	  * @param filter
	  */
	 featurePrototypeGetTrack(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeGetTrack');
		 }
		 const baseUrl = `/Features/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 featurePrototypeLinkTrack(
		 params: { id: string; fk: string; data?: TrackGenre },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeLinkTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling featurePrototypeLinkTrack');
		 }
		 const baseUrl = `/Features/{id}/track/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Feature id
	  * @param data An object of model property name/value pairs
	  */
	 featurePrototypePatchAttributes(
		 params: { id: string; data?: Feature },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypePatchAttributes');
		 }
		 const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the track relation to an item by id.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeUnlinkTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeUnlinkTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling featurePrototypeUnlinkTrack');
		 }
		 const baseUrl = `/Features/{id}/track/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 featurePrototypeUpdateByIdTrack(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featurePrototypeUpdateByIdTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling featurePrototypeUpdateByIdTrack');
		 }
		 const baseUrl = `/Features/{id}/track/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 featureReplaceByIdPostFeaturesidReplace(
		 params: { id: string; data?: Feature },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling featureReplaceByIdPostFeaturesidReplace'
			 );
		 }
		 const baseUrl = `/Features/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 featureReplaceByIdPutFeaturesid(
		 params: { id: string; data?: Feature },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling featureReplaceByIdPutFeaturesid');
		 }
		 const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 featureReplaceOrCreatePostFeaturesReplaceOrCreate(
		 params: { data?: Feature },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Features/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 featureReplaceOrCreatePutFeatures(params: { data?: Feature }, options?: any): FetchArgs {
		 const baseUrl = `/Features`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 featureUpdateAll(params: { where?: string; data?: Feature }, options?: any): FetchArgs {
		 const baseUrl = `/Features/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 featureUpsertWithWhere(params: { where?: string; data?: Feature }, options?: any): FetchArgs {
		 const baseUrl = `/Features/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * FeatureApi - functional programming interface
  */
 export const FeatureApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 featureCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 featureCreate(
		 params: { data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 featureCreateChangeStreamGetFeaturesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureCreateChangeStreamGetFeaturesChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 featureCreateChangeStreamPostFeaturesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureCreateChangeStreamPostFeaturesChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 featureDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 featureExistsGetFeaturesidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureExistsGetFeaturesidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 featureExistsHeadFeaturesid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureExistsHeadFeaturesid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 featureFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Feature>> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 featureFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 featureFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 featurePatchOrCreate(
		 params: { data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts track of Feature.
	  * @param id Feature id
	  * @param where Criteria to match model instances
	  */
	 featurePrototypeCountTrack(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeCountTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in track of this model.
	  * @param id Feature id
	  * @param data
	  */
	 featurePrototypeCreateTrack(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeCreateTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all track of this model.
	  * @param id Feature id
	  */
	 featurePrototypeDeleteTrack(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeDeleteTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeDestroyByIdTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeDestroyByIdTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of track relation to an item by id.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeExistsTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeExistsTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeFindByIdTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeFindByIdTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Feature id
	  * @param refresh
	  */
	 featurePrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeGetAccount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries track of Feature.
	  * @param id Feature id
	  * @param filter
	  */
	 featurePrototypeGetTrack(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeGetTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 featurePrototypeLinkTrack(
		 params: { id: string; fk: string; data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeLinkTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Feature id
	  * @param data An object of model property name/value pairs
	  */
	 featurePrototypePatchAttributes(
		 params: { id: string; data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the track relation to an item by id.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeUnlinkTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeUnlinkTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 featurePrototypeUpdateByIdTrack(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = FeatureApiFetchParamCreator.featurePrototypeUpdateByIdTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 featureReplaceByIdPostFeaturesidReplace(
		 params: { id: string; data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureReplaceByIdPostFeaturesidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 featureReplaceByIdPutFeaturesid(
		 params: { id: string; data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureReplaceByIdPutFeaturesid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 featureReplaceOrCreatePostFeaturesReplaceOrCreate(
		 params: { data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureReplaceOrCreatePostFeaturesReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 featureReplaceOrCreatePutFeatures(
		 params: { data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureReplaceOrCreatePutFeatures(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 featureUpdateAll(
		 params: { where?: string; data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 featureUpsertWithWhere(
		 params: { where?: string; data?: Feature },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Feature> {
		 const fetchArgs = FeatureApiFetchParamCreator.featureUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * FeatureApi - object-oriented interface
  */
 export class FeatureApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 featureCount(params: { where?: string }, options?: any) {
		 return FeatureApiFp.featureCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 featureCreate(params: { data?: Feature }, options?: any) {
		 return FeatureApiFp.featureCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 featureCreateChangeStreamGetFeaturesChangeStream(params: { options?: string }, options?: any) {
		 return FeatureApiFp.featureCreateChangeStreamGetFeaturesChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 featureCreateChangeStreamPostFeaturesChangeStream(params: { options?: string }, options?: any) {
		 return FeatureApiFp.featureCreateChangeStreamPostFeaturesChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 featureDeleteById(params: { id: string }, options?: any) {
		 return FeatureApiFp.featureDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 featureExistsGetFeaturesidExists(params: { id: string }, options?: any) {
		 return FeatureApiFp.featureExistsGetFeaturesidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 featureExistsHeadFeaturesid(params: { id: string }, options?: any) {
		 return FeatureApiFp.featureExistsHeadFeaturesid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 featureFind(params: { filter?: string }, options?: any) {
		 return FeatureApiFp.featureFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 featureFindById(params: { id: string; filter?: string }, options?: any) {
		 return FeatureApiFp.featureFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 featureFindOne(params: { filter?: string }, options?: any) {
		 return FeatureApiFp.featureFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 featurePatchOrCreate(params: { data?: Feature }, options?: any) {
		 return FeatureApiFp.featurePatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts track of Feature.
	  * @param id Feature id
	  * @param where Criteria to match model instances
	  */
	 featurePrototypeCountTrack(params: { id: string; where?: string }, options?: any) {
		 return FeatureApiFp.featurePrototypeCountTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in track of this model.
	  * @param id Feature id
	  * @param data
	  */
	 featurePrototypeCreateTrack(params: { id: string; data?: Track }, options?: any) {
		 return FeatureApiFp.featurePrototypeCreateTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all track of this model.
	  * @param id Feature id
	  */
	 featurePrototypeDeleteTrack(params: { id: string }, options?: any) {
		 return FeatureApiFp.featurePrototypeDeleteTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeDestroyByIdTrack(params: { id: string; fk: string }, options?: any) {
		 return FeatureApiFp.featurePrototypeDestroyByIdTrack(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check the existence of track relation to an item by id.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeExistsTrack(params: { id: string; fk: string }, options?: any) {
		 return FeatureApiFp.featurePrototypeExistsTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeFindByIdTrack(params: { id: string; fk: string }, options?: any) {
		 return FeatureApiFp.featurePrototypeFindByIdTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Feature id
	  * @param refresh
	  */
	 featurePrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
		 return FeatureApiFp.featurePrototypeGetAccount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries track of Feature.
	  * @param id Feature id
	  * @param filter
	  */
	 featurePrototypeGetTrack(params: { id: string; filter?: string }, options?: any) {
		 return FeatureApiFp.featurePrototypeGetTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 featurePrototypeLinkTrack(params: { id: string; fk: string; data?: TrackGenre }, options?: any) {
		 return FeatureApiFp.featurePrototypeLinkTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Feature id
	  * @param data An object of model property name/value pairs
	  */
	 featurePrototypePatchAttributes(params: { id: string; data?: Feature }, options?: any) {
		 return FeatureApiFp.featurePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the track relation to an item by id.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  */
	 featurePrototypeUnlinkTrack(params: { id: string; fk: string }, options?: any) {
		 return FeatureApiFp.featurePrototypeUnlinkTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for track.
	  * @param id Feature id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 featurePrototypeUpdateByIdTrack(params: { id: string; fk: string; data?: Track }, options?: any) {
		 return FeatureApiFp.featurePrototypeUpdateByIdTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 featureReplaceByIdPostFeaturesidReplace(params: { id: string; data?: Feature }, options?: any) {
		 return FeatureApiFp.featureReplaceByIdPostFeaturesidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 featureReplaceByIdPutFeaturesid(params: { id: string; data?: Feature }, options?: any) {
		 return FeatureApiFp.featureReplaceByIdPutFeaturesid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 featureReplaceOrCreatePostFeaturesReplaceOrCreate(params: { data?: Feature }, options?: any) {
		 return FeatureApiFp.featureReplaceOrCreatePostFeaturesReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 featureReplaceOrCreatePutFeatures(params: { data?: Feature }, options?: any) {
		 return FeatureApiFp.featureReplaceOrCreatePutFeatures(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 featureUpdateAll(params: { where?: string; data?: Feature }, options?: any) {
		 return FeatureApiFp.featureUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 featureUpsertWithWhere(params: { where?: string; data?: Feature }, options?: any) {
		 return FeatureApiFp.featureUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * FeatureApi - factory interface
  */
 export const FeatureApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 featureCount(params: { where?: string }, options?: any) {
			 return FeatureApiFp.featureCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 featureCreate(params: { data?: Feature }, options?: any) {
			 return FeatureApiFp.featureCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 featureCreateChangeStreamGetFeaturesChangeStream(params: { options?: string }, options?: any) {
			 return FeatureApiFp.featureCreateChangeStreamGetFeaturesChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 featureCreateChangeStreamPostFeaturesChangeStream(params: { options?: string }, options?: any) {
			 return FeatureApiFp.featureCreateChangeStreamPostFeaturesChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 featureDeleteById(params: { id: string }, options?: any) {
			 return FeatureApiFp.featureDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 featureExistsGetFeaturesidExists(params: { id: string }, options?: any) {
			 return FeatureApiFp.featureExistsGetFeaturesidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 featureExistsHeadFeaturesid(params: { id: string }, options?: any) {
			 return FeatureApiFp.featureExistsHeadFeaturesid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 featureFind(params: { filter?: string }, options?: any) {
			 return FeatureApiFp.featureFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 featureFindById(params: { id: string; filter?: string }, options?: any) {
			 return FeatureApiFp.featureFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 featureFindOne(params: { filter?: string }, options?: any) {
			 return FeatureApiFp.featureFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 featurePatchOrCreate(params: { data?: Feature }, options?: any) {
			 return FeatureApiFp.featurePatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts track of Feature.
		  * @param id Feature id
		  * @param where Criteria to match model instances
		  */
		 featurePrototypeCountTrack(params: { id: string; where?: string }, options?: any) {
			 return FeatureApiFp.featurePrototypeCountTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in track of this model.
		  * @param id Feature id
		  * @param data
		  */
		 featurePrototypeCreateTrack(params: { id: string; data?: Track }, options?: any) {
			 return FeatureApiFp.featurePrototypeCreateTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all track of this model.
		  * @param id Feature id
		  */
		 featurePrototypeDeleteTrack(params: { id: string }, options?: any) {
			 return FeatureApiFp.featurePrototypeDeleteTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for track.
		  * @param id Feature id
		  * @param fk Foreign key for track
		  */
		 featurePrototypeDestroyByIdTrack(params: { id: string; fk: string }, options?: any) {
			 return FeatureApiFp.featurePrototypeDestroyByIdTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of track relation to an item by id.
		  * @param id Feature id
		  * @param fk Foreign key for track
		  */
		 featurePrototypeExistsTrack(params: { id: string; fk: string }, options?: any) {
			 return FeatureApiFp.featurePrototypeExistsTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for track.
		  * @param id Feature id
		  * @param fk Foreign key for track
		  */
		 featurePrototypeFindByIdTrack(params: { id: string; fk: string }, options?: any) {
			 return FeatureApiFp.featurePrototypeFindByIdTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation account.
		  * @param id Feature id
		  * @param refresh
		  */
		 featurePrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
			 return FeatureApiFp.featurePrototypeGetAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries track of Feature.
		  * @param id Feature id
		  * @param filter
		  */
		 featurePrototypeGetTrack(params: { id: string; filter?: string }, options?: any) {
			 return FeatureApiFp.featurePrototypeGetTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for track.
		  * @param id Feature id
		  * @param fk Foreign key for track
		  * @param data
		  */
		 featurePrototypeLinkTrack(
			 params: { id: string; fk: string; data?: TrackGenre },
			 options?: any
		 ) {
			 return FeatureApiFp.featurePrototypeLinkTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Feature id
		  * @param data An object of model property name/value pairs
		  */
		 featurePrototypePatchAttributes(params: { id: string; data?: Feature }, options?: any) {
			 return FeatureApiFp.featurePrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the track relation to an item by id.
		  * @param id Feature id
		  * @param fk Foreign key for track
		  */
		 featurePrototypeUnlinkTrack(params: { id: string; fk: string }, options?: any) {
			 return FeatureApiFp.featurePrototypeUnlinkTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for track.
		  * @param id Feature id
		  * @param fk Foreign key for track
		  * @param data
		  */
		 featurePrototypeUpdateByIdTrack(
			 params: { id: string; fk: string; data?: Track },
			 options?: any
		 ) {
			 return FeatureApiFp.featurePrototypeUpdateByIdTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 featureReplaceByIdPostFeaturesidReplace(params: { id: string; data?: Feature }, options?: any) {
			 return FeatureApiFp.featureReplaceByIdPostFeaturesidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 featureReplaceByIdPutFeaturesid(params: { id: string; data?: Feature }, options?: any) {
			 return FeatureApiFp.featureReplaceByIdPutFeaturesid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 featureReplaceOrCreatePostFeaturesReplaceOrCreate(params: { data?: Feature }, options?: any) {
			 return FeatureApiFp.featureReplaceOrCreatePostFeaturesReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 featureReplaceOrCreatePutFeatures(params: { data?: Feature }, options?: any) {
			 return FeatureApiFp.featureReplaceOrCreatePutFeatures(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 featureUpdateAll(params: { where?: string; data?: Feature }, options?: any) {
			 return FeatureApiFp.featureUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 featureUpsertWithWhere(params: { where?: string; data?: Feature }, options?: any) {
			 return FeatureApiFp.featureUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * GenreApi - fetch parameter creator
  */
 export const GenreApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 genreCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Genres/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 genreCreate(params: { data?: Genre }, options?: any): FetchArgs {
		 const baseUrl = `/Genres`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 genreCreateChangeStreamGetGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Genres/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 genreCreateChangeStreamPostGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Genres/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 genreDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genreDeleteById');
		 }
		 const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 genreExistsGetGenresidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genreExistsGetGenresidExists');
		 }
		 const baseUrl = `/Genres/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 genreExistsHeadGenresid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genreExistsHeadGenresid');
		 }
		 const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 genreFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Genres`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 genreFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genreFindById');
		 }
		 const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 genreFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Genres/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 genrePatchOrCreate(params: { data?: Genre }, options?: any): FetchArgs {
		 const baseUrl = `/Genres`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts track of Genre.
	  * @param id Genre id
	  * @param where Criteria to match model instances
	  */
	 genrePrototypeCountTrack(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeCountTrack');
		 }
		 const baseUrl = `/Genres/{id}/track/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in track of this model.
	  * @param id Genre id
	  * @param data
	  */
	 genrePrototypeCreateTrack(params: { id: string; data?: Track }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeCreateTrack');
		 }
		 const baseUrl = `/Genres/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all track of this model.
	  * @param id Genre id
	  */
	 genrePrototypeDeleteTrack(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeDeleteTrack');
		 }
		 const baseUrl = `/Genres/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeDestroyByIdTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeDestroyByIdTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling genrePrototypeDestroyByIdTrack');
		 }
		 const baseUrl = `/Genres/{id}/track/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of track relation to an item by id.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeExistsTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeExistsTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling genrePrototypeExistsTrack');
		 }
		 const baseUrl = `/Genres/{id}/track/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeFindByIdTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeFindByIdTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling genrePrototypeFindByIdTrack');
		 }
		 const baseUrl = `/Genres/{id}/track/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Genre id
	  * @param refresh
	  */
	 genrePrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeGetAccount');
		 }
		 const baseUrl = `/Genres/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation fatherGenre.
	  * @param id Genre id
	  * @param refresh
	  */
	 genrePrototypeGetFatherGenre(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeGetFatherGenre');
		 }
		 const baseUrl = `/Genres/{id}/fatherGenre`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries track of Genre.
	  * @param id Genre id
	  * @param filter
	  */
	 genrePrototypeGetTrack(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeGetTrack');
		 }
		 const baseUrl = `/Genres/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 genrePrototypeLinkTrack(
		 params: { id: string; fk: string; data?: TrackGenre },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeLinkTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling genrePrototypeLinkTrack');
		 }
		 const baseUrl = `/Genres/{id}/track/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Genre id
	  * @param data An object of model property name/value pairs
	  */
	 genrePrototypePatchAttributes(params: { id: string; data?: Genre }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypePatchAttributes');
		 }
		 const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the track relation to an item by id.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeUnlinkTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeUnlinkTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling genrePrototypeUnlinkTrack');
		 }
		 const baseUrl = `/Genres/{id}/track/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 genrePrototypeUpdateByIdTrack(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genrePrototypeUpdateByIdTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling genrePrototypeUpdateByIdTrack');
		 }
		 const baseUrl = `/Genres/{id}/track/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 genreReplaceByIdPostGenresidReplace(
		 params: { id: string; data?: Genre },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling genreReplaceByIdPostGenresidReplace'
			 );
		 }
		 const baseUrl = `/Genres/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 genreReplaceByIdPutGenresid(params: { id: string; data?: Genre }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling genreReplaceByIdPutGenresid');
		 }
		 const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 genreReplaceOrCreatePostGenresReplaceOrCreate(
		 params: { data?: Genre },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Genres/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 genreReplaceOrCreatePutGenres(params: { data?: Genre }, options?: any): FetchArgs {
		 const baseUrl = `/Genres`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 genreUpdateAll(params: { where?: string; data?: Genre }, options?: any): FetchArgs {
		 const baseUrl = `/Genres/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 genreUpsertWithWhere(params: { where?: string; data?: Genre }, options?: any): FetchArgs {
		 const baseUrl = `/Genres/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * GenreApi - functional programming interface
  */
 export const GenreApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 genreCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = GenreApiFetchParamCreator.genreCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 genreCreate(
		 params: { data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genreCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 genreCreateChangeStreamGetGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = GenreApiFetchParamCreator.genreCreateChangeStreamGetGenresChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 genreCreateChangeStreamPostGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = GenreApiFetchParamCreator.genreCreateChangeStreamPostGenresChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 genreDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = GenreApiFetchParamCreator.genreDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 genreExistsGetGenresidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = GenreApiFetchParamCreator.genreExistsGetGenresidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 genreExistsHeadGenresid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = GenreApiFetchParamCreator.genreExistsHeadGenresid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 genreFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Genre>> {
		 const fetchArgs = GenreApiFetchParamCreator.genreFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 genreFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genreFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 genreFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genreFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 genrePatchOrCreate(
		 params: { data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts track of Genre.
	  * @param id Genre id
	  * @param where Criteria to match model instances
	  */
	 genrePrototypeCountTrack(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeCountTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in track of this model.
	  * @param id Genre id
	  * @param data
	  */
	 genrePrototypeCreateTrack(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeCreateTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all track of this model.
	  * @param id Genre id
	  */
	 genrePrototypeDeleteTrack(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeDeleteTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeDestroyByIdTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeDestroyByIdTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of track relation to an item by id.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeExistsTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeExistsTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeFindByIdTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeFindByIdTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Genre id
	  * @param refresh
	  */
	 genrePrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeGetAccount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation fatherGenre.
	  * @param id Genre id
	  * @param refresh
	  */
	 genrePrototypeGetFatherGenre(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeGetFatherGenre(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries track of Genre.
	  * @param id Genre id
	  * @param filter
	  */
	 genrePrototypeGetTrack(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeGetTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 genrePrototypeLinkTrack(
		 params: { id: string; fk: string; data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeLinkTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Genre id
	  * @param data An object of model property name/value pairs
	  */
	 genrePrototypePatchAttributes(
		 params: { id: string; data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the track relation to an item by id.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeUnlinkTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeUnlinkTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 genrePrototypeUpdateByIdTrack(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = GenreApiFetchParamCreator.genrePrototypeUpdateByIdTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 genreReplaceByIdPostGenresidReplace(
		 params: { id: string; data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genreReplaceByIdPostGenresidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 genreReplaceByIdPutGenresid(
		 params: { id: string; data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genreReplaceByIdPutGenresid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 genreReplaceOrCreatePostGenresReplaceOrCreate(
		 params: { data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genreReplaceOrCreatePostGenresReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 genreReplaceOrCreatePutGenres(
		 params: { data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genreReplaceOrCreatePutGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 genreUpdateAll(
		 params: { where?: string; data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = GenreApiFetchParamCreator.genreUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 genreUpsertWithWhere(
		 params: { where?: string; data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = GenreApiFetchParamCreator.genreUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * GenreApi - object-oriented interface
  */
 export class GenreApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 genreCount(params: { where?: string }, options?: any) {
		 return GenreApiFp.genreCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 genreCreate(params: { data?: Genre }, options?: any) {
		 return GenreApiFp.genreCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 genreCreateChangeStreamGetGenresChangeStream(params: { options?: string }, options?: any) {
		 return GenreApiFp.genreCreateChangeStreamGetGenresChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 genreCreateChangeStreamPostGenresChangeStream(params: { options?: string }, options?: any) {
		 return GenreApiFp.genreCreateChangeStreamPostGenresChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 genreDeleteById(params: { id: string }, options?: any) {
		 return GenreApiFp.genreDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 genreExistsGetGenresidExists(params: { id: string }, options?: any) {
		 return GenreApiFp.genreExistsGetGenresidExists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 genreExistsHeadGenresid(params: { id: string }, options?: any) {
		 return GenreApiFp.genreExistsHeadGenresid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 genreFind(params: { filter?: string }, options?: any) {
		 return GenreApiFp.genreFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 genreFindById(params: { id: string; filter?: string }, options?: any) {
		 return GenreApiFp.genreFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 genreFindOne(params: { filter?: string }, options?: any) {
		 return GenreApiFp.genreFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 genrePatchOrCreate(params: { data?: Genre }, options?: any) {
		 return GenreApiFp.genrePatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts track of Genre.
	  * @param id Genre id
	  * @param where Criteria to match model instances
	  */
	 genrePrototypeCountTrack(params: { id: string; where?: string }, options?: any) {
		 return GenreApiFp.genrePrototypeCountTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in track of this model.
	  * @param id Genre id
	  * @param data
	  */
	 genrePrototypeCreateTrack(params: { id: string; data?: Track }, options?: any) {
		 return GenreApiFp.genrePrototypeCreateTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all track of this model.
	  * @param id Genre id
	  */
	 genrePrototypeDeleteTrack(params: { id: string }, options?: any) {
		 return GenreApiFp.genrePrototypeDeleteTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeDestroyByIdTrack(params: { id: string; fk: string }, options?: any) {
		 return GenreApiFp.genrePrototypeDestroyByIdTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of track relation to an item by id.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeExistsTrack(params: { id: string; fk: string }, options?: any) {
		 return GenreApiFp.genrePrototypeExistsTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeFindByIdTrack(params: { id: string; fk: string }, options?: any) {
		 return GenreApiFp.genrePrototypeFindByIdTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Genre id
	  * @param refresh
	  */
	 genrePrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
		 return GenreApiFp.genrePrototypeGetAccount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation fatherGenre.
	  * @param id Genre id
	  * @param refresh
	  */
	 genrePrototypeGetFatherGenre(params: { id: string; refresh?: boolean }, options?: any) {
		 return GenreApiFp.genrePrototypeGetFatherGenre(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries track of Genre.
	  * @param id Genre id
	  * @param filter
	  */
	 genrePrototypeGetTrack(params: { id: string; filter?: string }, options?: any) {
		 return GenreApiFp.genrePrototypeGetTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 genrePrototypeLinkTrack(params: { id: string; fk: string; data?: TrackGenre }, options?: any) {
		 return GenreApiFp.genrePrototypeLinkTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Genre id
	  * @param data An object of model property name/value pairs
	  */
	 genrePrototypePatchAttributes(params: { id: string; data?: Genre }, options?: any) {
		 return GenreApiFp.genrePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the track relation to an item by id.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  */
	 genrePrototypeUnlinkTrack(params: { id: string; fk: string }, options?: any) {
		 return GenreApiFp.genrePrototypeUnlinkTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for track.
	  * @param id Genre id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 genrePrototypeUpdateByIdTrack(params: { id: string; fk: string; data?: Track }, options?: any) {
		 return GenreApiFp.genrePrototypeUpdateByIdTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 genreReplaceByIdPostGenresidReplace(params: { id: string; data?: Genre }, options?: any) {
		 return GenreApiFp.genreReplaceByIdPostGenresidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 genreReplaceByIdPutGenresid(params: { id: string; data?: Genre }, options?: any) {
		 return GenreApiFp.genreReplaceByIdPutGenresid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 genreReplaceOrCreatePostGenresReplaceOrCreate(params: { data?: Genre }, options?: any) {
		 return GenreApiFp.genreReplaceOrCreatePostGenresReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 genreReplaceOrCreatePutGenres(params: { data?: Genre }, options?: any) {
		 return GenreApiFp.genreReplaceOrCreatePutGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 genreUpdateAll(params: { where?: string; data?: Genre }, options?: any) {
		 return GenreApiFp.genreUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 genreUpsertWithWhere(params: { where?: string; data?: Genre }, options?: any) {
		 return GenreApiFp.genreUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * GenreApi - factory interface
  */
 export const GenreApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 genreCount(params: { where?: string }, options?: any) {
			 return GenreApiFp.genreCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 genreCreate(params: { data?: Genre }, options?: any) {
			 return GenreApiFp.genreCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 genreCreateChangeStreamGetGenresChangeStream(params: { options?: string }, options?: any) {
			 return GenreApiFp.genreCreateChangeStreamGetGenresChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 genreCreateChangeStreamPostGenresChangeStream(params: { options?: string }, options?: any) {
			 return GenreApiFp.genreCreateChangeStreamPostGenresChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 genreDeleteById(params: { id: string }, options?: any) {
			 return GenreApiFp.genreDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 genreExistsGetGenresidExists(params: { id: string }, options?: any) {
			 return GenreApiFp.genreExistsGetGenresidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 genreExistsHeadGenresid(params: { id: string }, options?: any) {
			 return GenreApiFp.genreExistsHeadGenresid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 genreFind(params: { filter?: string }, options?: any) {
			 return GenreApiFp.genreFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 genreFindById(params: { id: string; filter?: string }, options?: any) {
			 return GenreApiFp.genreFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 genreFindOne(params: { filter?: string }, options?: any) {
			 return GenreApiFp.genreFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 genrePatchOrCreate(params: { data?: Genre }, options?: any) {
			 return GenreApiFp.genrePatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts track of Genre.
		  * @param id Genre id
		  * @param where Criteria to match model instances
		  */
		 genrePrototypeCountTrack(params: { id: string; where?: string }, options?: any) {
			 return GenreApiFp.genrePrototypeCountTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in track of this model.
		  * @param id Genre id
		  * @param data
		  */
		 genrePrototypeCreateTrack(params: { id: string; data?: Track }, options?: any) {
			 return GenreApiFp.genrePrototypeCreateTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all track of this model.
		  * @param id Genre id
		  */
		 genrePrototypeDeleteTrack(params: { id: string }, options?: any) {
			 return GenreApiFp.genrePrototypeDeleteTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for track.
		  * @param id Genre id
		  * @param fk Foreign key for track
		  */
		 genrePrototypeDestroyByIdTrack(params: { id: string; fk: string }, options?: any) {
			 return GenreApiFp.genrePrototypeDestroyByIdTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of track relation to an item by id.
		  * @param id Genre id
		  * @param fk Foreign key for track
		  */
		 genrePrototypeExistsTrack(params: { id: string; fk: string }, options?: any) {
			 return GenreApiFp.genrePrototypeExistsTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for track.
		  * @param id Genre id
		  * @param fk Foreign key for track
		  */
		 genrePrototypeFindByIdTrack(params: { id: string; fk: string }, options?: any) {
			 return GenreApiFp.genrePrototypeFindByIdTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation account.
		  * @param id Genre id
		  * @param refresh
		  */
		 genrePrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
			 return GenreApiFp.genrePrototypeGetAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation fatherGenre.
		  * @param id Genre id
		  * @param refresh
		  */
		 genrePrototypeGetFatherGenre(params: { id: string; refresh?: boolean }, options?: any) {
			 return GenreApiFp.genrePrototypeGetFatherGenre(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries track of Genre.
		  * @param id Genre id
		  * @param filter
		  */
		 genrePrototypeGetTrack(params: { id: string; filter?: string }, options?: any) {
			 return GenreApiFp.genrePrototypeGetTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for track.
		  * @param id Genre id
		  * @param fk Foreign key for track
		  * @param data
		  */
		 genrePrototypeLinkTrack(params: { id: string; fk: string; data?: TrackGenre }, options?: any) {
			 return GenreApiFp.genrePrototypeLinkTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Genre id
		  * @param data An object of model property name/value pairs
		  */
		 genrePrototypePatchAttributes(params: { id: string; data?: Genre }, options?: any) {
			 return GenreApiFp.genrePrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the track relation to an item by id.
		  * @param id Genre id
		  * @param fk Foreign key for track
		  */
		 genrePrototypeUnlinkTrack(params: { id: string; fk: string }, options?: any) {
			 return GenreApiFp.genrePrototypeUnlinkTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for track.
		  * @param id Genre id
		  * @param fk Foreign key for track
		  * @param data
		  */
		 genrePrototypeUpdateByIdTrack(params: { id: string; fk: string; data?: Track }, options?: any) {
			 return GenreApiFp.genrePrototypeUpdateByIdTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 genreReplaceByIdPostGenresidReplace(params: { id: string; data?: Genre }, options?: any) {
			 return GenreApiFp.genreReplaceByIdPostGenresidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 genreReplaceByIdPutGenresid(params: { id: string; data?: Genre }, options?: any) {
			 return GenreApiFp.genreReplaceByIdPutGenresid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 genreReplaceOrCreatePostGenresReplaceOrCreate(params: { data?: Genre }, options?: any) {
			 return GenreApiFp.genreReplaceOrCreatePostGenresReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 genreReplaceOrCreatePutGenres(params: { data?: Genre }, options?: any) {
			 return GenreApiFp.genreReplaceOrCreatePutGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 genreUpdateAll(params: { where?: string; data?: Genre }, options?: any) {
			 return GenreApiFp.genreUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 genreUpsertWithWhere(params: { where?: string; data?: Genre }, options?: any) {
			 return GenreApiFp.genreUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * MoodApi - fetch parameter creator
  */
 export const MoodApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 moodCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Moods/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 moodCreate(params: { data?: Mood }, options?: any): FetchArgs {
		 const baseUrl = `/Moods`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 moodCreateChangeStreamGetMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Moods/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 moodCreateChangeStreamPostMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Moods/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 moodDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodDeleteById');
		 }
		 const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 moodExistsGetMoodsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodExistsGetMoodsidExists');
		 }
		 const baseUrl = `/Moods/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 moodExistsHeadMoodsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodExistsHeadMoodsid');
		 }
		 const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 moodFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Moods`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 moodFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodFindById');
		 }
		 const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 moodFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Moods/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 moodPatchOrCreate(params: { data?: Mood }, options?: any): FetchArgs {
		 const baseUrl = `/Moods`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts track of Mood.
	  * @param id Mood id
	  * @param where Criteria to match model instances
	  */
	 moodPrototypeCountTrack(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeCountTrack');
		 }
		 const baseUrl = `/Moods/{id}/track/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in track of this model.
	  * @param id Mood id
	  * @param data
	  */
	 moodPrototypeCreateTrack(params: { id: string; data?: Track }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeCreateTrack');
		 }
		 const baseUrl = `/Moods/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all track of this model.
	  * @param id Mood id
	  */
	 moodPrototypeDeleteTrack(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeDeleteTrack');
		 }
		 const baseUrl = `/Moods/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeDestroyByIdTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeDestroyByIdTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling moodPrototypeDestroyByIdTrack');
		 }
		 const baseUrl = `/Moods/{id}/track/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of track relation to an item by id.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeExistsTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeExistsTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling moodPrototypeExistsTrack');
		 }
		 const baseUrl = `/Moods/{id}/track/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeFindByIdTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeFindByIdTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling moodPrototypeFindByIdTrack');
		 }
		 const baseUrl = `/Moods/{id}/track/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Mood id
	  * @param refresh
	  */
	 moodPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeGetAccount');
		 }
		 const baseUrl = `/Moods/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries track of Mood.
	  * @param id Mood id
	  * @param filter
	  */
	 moodPrototypeGetTrack(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeGetTrack');
		 }
		 const baseUrl = `/Moods/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 moodPrototypeLinkTrack(
		 params: { id: string; fk: string; data?: TrackMood },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeLinkTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling moodPrototypeLinkTrack');
		 }
		 const baseUrl = `/Moods/{id}/track/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Mood id
	  * @param data An object of model property name/value pairs
	  */
	 moodPrototypePatchAttributes(params: { id: string; data?: Mood }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypePatchAttributes');
		 }
		 const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the track relation to an item by id.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeUnlinkTrack(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeUnlinkTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling moodPrototypeUnlinkTrack');
		 }
		 const baseUrl = `/Moods/{id}/track/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 moodPrototypeUpdateByIdTrack(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodPrototypeUpdateByIdTrack');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling moodPrototypeUpdateByIdTrack');
		 }
		 const baseUrl = `/Moods/{id}/track/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 moodReplaceByIdPostMoodsidReplace(params: { id: string; data?: Mood }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling moodReplaceByIdPostMoodsidReplace'
			 );
		 }
		 const baseUrl = `/Moods/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 moodReplaceByIdPutMoodsid(params: { id: string; data?: Mood }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling moodReplaceByIdPutMoodsid');
		 }
		 const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 moodReplaceOrCreatePostMoodsReplaceOrCreate(params: { data?: Mood }, options?: any): FetchArgs {
		 const baseUrl = `/Moods/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 moodReplaceOrCreatePutMoods(params: { data?: Mood }, options?: any): FetchArgs {
		 const baseUrl = `/Moods`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 moodUpdateAll(params: { where?: string; data?: Mood }, options?: any): FetchArgs {
		 const baseUrl = `/Moods/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 moodUpsertWithWhere(params: { where?: string; data?: Mood }, options?: any): FetchArgs {
		 const baseUrl = `/Moods/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * MoodApi - functional programming interface
  */
 export const MoodApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 moodCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = MoodApiFetchParamCreator.moodCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 moodCreate(
		 params: { data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 moodCreateChangeStreamGetMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = MoodApiFetchParamCreator.moodCreateChangeStreamGetMoodsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 moodCreateChangeStreamPostMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = MoodApiFetchParamCreator.moodCreateChangeStreamPostMoodsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 moodDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = MoodApiFetchParamCreator.moodDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 moodExistsGetMoodsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = MoodApiFetchParamCreator.moodExistsGetMoodsidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 moodExistsHeadMoodsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = MoodApiFetchParamCreator.moodExistsHeadMoodsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 moodFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Mood>> {
		 const fetchArgs = MoodApiFetchParamCreator.moodFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 moodFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 moodFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 moodPatchOrCreate(
		 params: { data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts track of Mood.
	  * @param id Mood id
	  * @param where Criteria to match model instances
	  */
	 moodPrototypeCountTrack(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeCountTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in track of this model.
	  * @param id Mood id
	  * @param data
	  */
	 moodPrototypeCreateTrack(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeCreateTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all track of this model.
	  * @param id Mood id
	  */
	 moodPrototypeDeleteTrack(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeDeleteTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeDestroyByIdTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeDestroyByIdTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of track relation to an item by id.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeExistsTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeExistsTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeFindByIdTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeFindByIdTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Mood id
	  * @param refresh
	  */
	 moodPrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeGetAccount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries track of Mood.
	  * @param id Mood id
	  * @param filter
	  */
	 moodPrototypeGetTrack(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeGetTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 moodPrototypeLinkTrack(
		 params: { id: string; fk: string; data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeLinkTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Mood id
	  * @param data An object of model property name/value pairs
	  */
	 moodPrototypePatchAttributes(
		 params: { id: string; data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the track relation to an item by id.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeUnlinkTrack(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeUnlinkTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 moodPrototypeUpdateByIdTrack(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = MoodApiFetchParamCreator.moodPrototypeUpdateByIdTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 moodReplaceByIdPostMoodsidReplace(
		 params: { id: string; data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodReplaceByIdPostMoodsidReplace(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 moodReplaceByIdPutMoodsid(
		 params: { id: string; data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodReplaceByIdPutMoodsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 moodReplaceOrCreatePostMoodsReplaceOrCreate(
		 params: { data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodReplaceOrCreatePostMoodsReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 moodReplaceOrCreatePutMoods(
		 params: { data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodReplaceOrCreatePutMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 moodUpdateAll(
		 params: { where?: string; data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = MoodApiFetchParamCreator.moodUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 moodUpsertWithWhere(
		 params: { where?: string; data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = MoodApiFetchParamCreator.moodUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * MoodApi - object-oriented interface
  */
 export class MoodApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 moodCount(params: { where?: string }, options?: any) {
		 return MoodApiFp.moodCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 moodCreate(params: { data?: Mood }, options?: any) {
		 return MoodApiFp.moodCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 moodCreateChangeStreamGetMoodsChangeStream(params: { options?: string }, options?: any) {
		 return MoodApiFp.moodCreateChangeStreamGetMoodsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 moodCreateChangeStreamPostMoodsChangeStream(params: { options?: string }, options?: any) {
		 return MoodApiFp.moodCreateChangeStreamPostMoodsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 moodDeleteById(params: { id: string }, options?: any) {
		 return MoodApiFp.moodDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 moodExistsGetMoodsidExists(params: { id: string }, options?: any) {
		 return MoodApiFp.moodExistsGetMoodsidExists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 moodExistsHeadMoodsid(params: { id: string }, options?: any) {
		 return MoodApiFp.moodExistsHeadMoodsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 moodFind(params: { filter?: string }, options?: any) {
		 return MoodApiFp.moodFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 moodFindById(params: { id: string; filter?: string }, options?: any) {
		 return MoodApiFp.moodFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 moodFindOne(params: { filter?: string }, options?: any) {
		 return MoodApiFp.moodFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 moodPatchOrCreate(params: { data?: Mood }, options?: any) {
		 return MoodApiFp.moodPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts track of Mood.
	  * @param id Mood id
	  * @param where Criteria to match model instances
	  */
	 moodPrototypeCountTrack(params: { id: string; where?: string }, options?: any) {
		 return MoodApiFp.moodPrototypeCountTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in track of this model.
	  * @param id Mood id
	  * @param data
	  */
	 moodPrototypeCreateTrack(params: { id: string; data?: Track }, options?: any) {
		 return MoodApiFp.moodPrototypeCreateTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all track of this model.
	  * @param id Mood id
	  */
	 moodPrototypeDeleteTrack(params: { id: string }, options?: any) {
		 return MoodApiFp.moodPrototypeDeleteTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeDestroyByIdTrack(params: { id: string; fk: string }, options?: any) {
		 return MoodApiFp.moodPrototypeDestroyByIdTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of track relation to an item by id.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeExistsTrack(params: { id: string; fk: string }, options?: any) {
		 return MoodApiFp.moodPrototypeExistsTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeFindByIdTrack(params: { id: string; fk: string }, options?: any) {
		 return MoodApiFp.moodPrototypeFindByIdTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Mood id
	  * @param refresh
	  */
	 moodPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
		 return MoodApiFp.moodPrototypeGetAccount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries track of Mood.
	  * @param id Mood id
	  * @param filter
	  */
	 moodPrototypeGetTrack(params: { id: string; filter?: string }, options?: any) {
		 return MoodApiFp.moodPrototypeGetTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 moodPrototypeLinkTrack(params: { id: string; fk: string; data?: TrackMood }, options?: any) {
		 return MoodApiFp.moodPrototypeLinkTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Mood id
	  * @param data An object of model property name/value pairs
	  */
	 moodPrototypePatchAttributes(params: { id: string; data?: Mood }, options?: any) {
		 return MoodApiFp.moodPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the track relation to an item by id.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  */
	 moodPrototypeUnlinkTrack(params: { id: string; fk: string }, options?: any) {
		 return MoodApiFp.moodPrototypeUnlinkTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for track.
	  * @param id Mood id
	  * @param fk Foreign key for track
	  * @param data
	  */
	 moodPrototypeUpdateByIdTrack(params: { id: string; fk: string; data?: Track }, options?: any) {
		 return MoodApiFp.moodPrototypeUpdateByIdTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 moodReplaceByIdPostMoodsidReplace(params: { id: string; data?: Mood }, options?: any) {
		 return MoodApiFp.moodReplaceByIdPostMoodsidReplace(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 moodReplaceByIdPutMoodsid(params: { id: string; data?: Mood }, options?: any) {
		 return MoodApiFp.moodReplaceByIdPutMoodsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 moodReplaceOrCreatePostMoodsReplaceOrCreate(params: { data?: Mood }, options?: any) {
		 return MoodApiFp.moodReplaceOrCreatePostMoodsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 moodReplaceOrCreatePutMoods(params: { data?: Mood }, options?: any) {
		 return MoodApiFp.moodReplaceOrCreatePutMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 moodUpdateAll(params: { where?: string; data?: Mood }, options?: any) {
		 return MoodApiFp.moodUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 moodUpsertWithWhere(params: { where?: string; data?: Mood }, options?: any) {
		 return MoodApiFp.moodUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * MoodApi - factory interface
  */
 export const MoodApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 moodCount(params: { where?: string }, options?: any) {
			 return MoodApiFp.moodCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 moodCreate(params: { data?: Mood }, options?: any) {
			 return MoodApiFp.moodCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 moodCreateChangeStreamGetMoodsChangeStream(params: { options?: string }, options?: any) {
			 return MoodApiFp.moodCreateChangeStreamGetMoodsChangeStream(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 moodCreateChangeStreamPostMoodsChangeStream(params: { options?: string }, options?: any) {
			 return MoodApiFp.moodCreateChangeStreamPostMoodsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 moodDeleteById(params: { id: string }, options?: any) {
			 return MoodApiFp.moodDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 moodExistsGetMoodsidExists(params: { id: string }, options?: any) {
			 return MoodApiFp.moodExistsGetMoodsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 moodExistsHeadMoodsid(params: { id: string }, options?: any) {
			 return MoodApiFp.moodExistsHeadMoodsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 moodFind(params: { filter?: string }, options?: any) {
			 return MoodApiFp.moodFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 moodFindById(params: { id: string; filter?: string }, options?: any) {
			 return MoodApiFp.moodFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 moodFindOne(params: { filter?: string }, options?: any) {
			 return MoodApiFp.moodFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 moodPatchOrCreate(params: { data?: Mood }, options?: any) {
			 return MoodApiFp.moodPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts track of Mood.
		  * @param id Mood id
		  * @param where Criteria to match model instances
		  */
		 moodPrototypeCountTrack(params: { id: string; where?: string }, options?: any) {
			 return MoodApiFp.moodPrototypeCountTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in track of this model.
		  * @param id Mood id
		  * @param data
		  */
		 moodPrototypeCreateTrack(params: { id: string; data?: Track }, options?: any) {
			 return MoodApiFp.moodPrototypeCreateTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all track of this model.
		  * @param id Mood id
		  */
		 moodPrototypeDeleteTrack(params: { id: string }, options?: any) {
			 return MoodApiFp.moodPrototypeDeleteTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for track.
		  * @param id Mood id
		  * @param fk Foreign key for track
		  */
		 moodPrototypeDestroyByIdTrack(params: { id: string; fk: string }, options?: any) {
			 return MoodApiFp.moodPrototypeDestroyByIdTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of track relation to an item by id.
		  * @param id Mood id
		  * @param fk Foreign key for track
		  */
		 moodPrototypeExistsTrack(params: { id: string; fk: string }, options?: any) {
			 return MoodApiFp.moodPrototypeExistsTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for track.
		  * @param id Mood id
		  * @param fk Foreign key for track
		  */
		 moodPrototypeFindByIdTrack(params: { id: string; fk: string }, options?: any) {
			 return MoodApiFp.moodPrototypeFindByIdTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation account.
		  * @param id Mood id
		  * @param refresh
		  */
		 moodPrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
			 return MoodApiFp.moodPrototypeGetAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries track of Mood.
		  * @param id Mood id
		  * @param filter
		  */
		 moodPrototypeGetTrack(params: { id: string; filter?: string }, options?: any) {
			 return MoodApiFp.moodPrototypeGetTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for track.
		  * @param id Mood id
		  * @param fk Foreign key for track
		  * @param data
		  */
		 moodPrototypeLinkTrack(params: { id: string; fk: string; data?: TrackMood }, options?: any) {
			 return MoodApiFp.moodPrototypeLinkTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Mood id
		  * @param data An object of model property name/value pairs
		  */
		 moodPrototypePatchAttributes(params: { id: string; data?: Mood }, options?: any) {
			 return MoodApiFp.moodPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the track relation to an item by id.
		  * @param id Mood id
		  * @param fk Foreign key for track
		  */
		 moodPrototypeUnlinkTrack(params: { id: string; fk: string }, options?: any) {
			 return MoodApiFp.moodPrototypeUnlinkTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for track.
		  * @param id Mood id
		  * @param fk Foreign key for track
		  * @param data
		  */
		 moodPrototypeUpdateByIdTrack(params: { id: string; fk: string; data?: Track }, options?: any) {
			 return MoodApiFp.moodPrototypeUpdateByIdTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 moodReplaceByIdPostMoodsidReplace(params: { id: string; data?: Mood }, options?: any) {
			 return MoodApiFp.moodReplaceByIdPostMoodsidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 moodReplaceByIdPutMoodsid(params: { id: string; data?: Mood }, options?: any) {
			 return MoodApiFp.moodReplaceByIdPutMoodsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 moodReplaceOrCreatePostMoodsReplaceOrCreate(params: { data?: Mood }, options?: any) {
			 return MoodApiFp.moodReplaceOrCreatePostMoodsReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 moodReplaceOrCreatePutMoods(params: { data?: Mood }, options?: any) {
			 return MoodApiFp.moodReplaceOrCreatePutMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 moodUpdateAll(params: { where?: string; data?: Mood }, options?: any) {
			 return MoodApiFp.moodUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 moodUpsertWithWhere(params: { where?: string; data?: Mood }, options?: any) {
			 return MoodApiFp.moodUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * PlaylistApi - fetch parameter creator
  */
 export const PlaylistApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 playlistCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Playlists/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 playlistCreate(params: { data?: Playlist }, options?: any): FetchArgs {
		 const baseUrl = `/Playlists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 playlistCreateChangeStreamGetPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Playlists/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 playlistCreateChangeStreamPostPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Playlists/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 playlistDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistDeleteById');
		 }
		 const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 playlistExistsGetPlaylistsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling playlistExistsGetPlaylistsidExists'
			 );
		 }
		 const baseUrl = `/Playlists/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 playlistExistsHeadPlaylistsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistExistsHeadPlaylistsid');
		 }
		 const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 playlistFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Playlists`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 playlistFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistFindById');
		 }
		 const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 playlistFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Playlists/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 playlistPatchOrCreate(params: { data?: Playlist }, options?: any): FetchArgs {
		 const baseUrl = `/Playlists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts accounts of Playlist.
	  * @param id Playlist id
	  * @param where Criteria to match model instances
	  */
	 playlistPrototypeCountAccounts(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeCountAccounts');
		 }
		 const baseUrl = `/Playlists/{id}/accounts/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts tracks of Playlist.
	  * @param id Playlist id
	  * @param where Criteria to match model instances
	  */
	 playlistPrototypeCountTracks(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeCountTracks');
		 }
		 const baseUrl = `/Playlists/{id}/tracks/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in accounts of this model.
	  * @param id Playlist id
	  * @param data
	  */
	 playlistPrototypeCreateAccounts(
		 params: { id: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeCreateAccounts');
		 }
		 const baseUrl = `/Playlists/{id}/accounts`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in tracks of this model.
	  * @param id Playlist id
	  * @param data
	  */
	 playlistPrototypeCreateTracks(params: { id: string; data?: Track }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeCreateTracks');
		 }
		 const baseUrl = `/Playlists/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all accounts of this model.
	  * @param id Playlist id
	  */
	 playlistPrototypeDeleteAccounts(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeDeleteAccounts');
		 }
		 const baseUrl = `/Playlists/{id}/accounts`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all tracks of this model.
	  * @param id Playlist id
	  */
	 playlistPrototypeDeleteTracks(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeDeleteTracks');
		 }
		 const baseUrl = `/Playlists/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeDestroyByIdAccounts(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling playlistPrototypeDestroyByIdAccounts'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling playlistPrototypeDestroyByIdAccounts'
			 );
		 }
		 const baseUrl = `/Playlists/{id}/accounts/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeDestroyByIdTracks(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling playlistPrototypeDestroyByIdTracks'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling playlistPrototypeDestroyByIdTracks'
			 );
		 }
		 const baseUrl = `/Playlists/{id}/tracks/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of accounts relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeExistsAccounts(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeExistsAccounts');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling playlistPrototypeExistsAccounts');
		 }
		 const baseUrl = `/Playlists/{id}/accounts/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of tracks relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeExistsTracks(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeExistsTracks');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling playlistPrototypeExistsTracks');
		 }
		 const baseUrl = `/Playlists/{id}/tracks/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeFindByIdAccounts(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling playlistPrototypeFindByIdAccounts'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling playlistPrototypeFindByIdAccounts'
			 );
		 }
		 const baseUrl = `/Playlists/{id}/accounts/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeFindByIdTracks(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeFindByIdTracks');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling playlistPrototypeFindByIdTracks');
		 }
		 const baseUrl = `/Playlists/{id}/tracks/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries accounts of Playlist.
	  * @param id Playlist id
	  * @param filter
	  */
	 playlistPrototypeGetAccounts(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeGetAccounts');
		 }
		 const baseUrl = `/Playlists/{id}/accounts`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation project.
	  * @param id Playlist id
	  * @param refresh
	  */
	 playlistPrototypeGetProject(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeGetProject');
		 }
		 const baseUrl = `/Playlists/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries tracks of Playlist.
	  * @param id Playlist id
	  * @param filter
	  */
	 playlistPrototypeGetTracks(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeGetTracks');
		 }
		 const baseUrl = `/Playlists/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  * @param data
	  */
	 playlistPrototypeLinkAccounts(
		 params: { id: string; fk: string; data?: AccountPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeLinkAccounts');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling playlistPrototypeLinkAccounts');
		 }
		 const baseUrl = `/Playlists/{id}/accounts/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  * @param data
	  */
	 playlistPrototypeLinkTracks(
		 params: { id: string; fk: string; data?: TrackInPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeLinkTracks');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling playlistPrototypeLinkTracks');
		 }
		 const baseUrl = `/Playlists/{id}/tracks/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Playlist id
	  * @param data An object of model property name/value pairs
	  */
	 playlistPrototypePatchAttributes(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling playlistPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the accounts relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeUnlinkAccounts(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeUnlinkAccounts');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling playlistPrototypeUnlinkAccounts');
		 }
		 const baseUrl = `/Playlists/{id}/accounts/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the tracks relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeUnlinkTracks(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling playlistPrototypeUnlinkTracks');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling playlistPrototypeUnlinkTracks');
		 }
		 const baseUrl = `/Playlists/{id}/tracks/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  * @param data
	  */
	 playlistPrototypeUpdateByIdAccounts(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling playlistPrototypeUpdateByIdAccounts'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling playlistPrototypeUpdateByIdAccounts'
			 );
		 }
		 const baseUrl = `/Playlists/{id}/accounts/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  * @param data
	  */
	 playlistPrototypeUpdateByIdTracks(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling playlistPrototypeUpdateByIdTracks'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling playlistPrototypeUpdateByIdTracks'
			 );
		 }
		 const baseUrl = `/Playlists/{id}/tracks/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 playlistReplaceByIdPostPlaylistsidReplace(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling playlistReplaceByIdPostPlaylistsidReplace'
			 );
		 }
		 const baseUrl = `/Playlists/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 playlistReplaceByIdPutPlaylistsid(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling playlistReplaceByIdPutPlaylistsid'
			 );
		 }
		 const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(
		 params: { data?: Playlist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Playlists/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 playlistReplaceOrCreatePutPlaylists(params: { data?: Playlist }, options?: any): FetchArgs {
		 const baseUrl = `/Playlists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 playlistUpdateAll(params: { where?: string; data?: Playlist }, options?: any): FetchArgs {
		 const baseUrl = `/Playlists/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 playlistUpsertWithWhere(params: { where?: string; data?: Playlist }, options?: any): FetchArgs {
		 const baseUrl = `/Playlists/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * PlaylistApi - functional programming interface
  */
 export const PlaylistApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 playlistCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 playlistCreate(
		 params: { data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 playlistCreateChangeStreamGetPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 PlaylistApiFetchParamCreator.playlistCreateChangeStreamGetPlaylistsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 playlistCreateChangeStreamPostPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 PlaylistApiFetchParamCreator.playlistCreateChangeStreamPostPlaylistsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 playlistDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 playlistExistsGetPlaylistsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistExistsGetPlaylistsidExists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 playlistExistsHeadPlaylistsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistExistsHeadPlaylistsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 playlistFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Playlist>> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 playlistFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 playlistFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 playlistPatchOrCreate(
		 params: { data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts accounts of Playlist.
	  * @param id Playlist id
	  * @param where Criteria to match model instances
	  */
	 playlistPrototypeCountAccounts(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeCountAccounts(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts tracks of Playlist.
	  * @param id Playlist id
	  * @param where Criteria to match model instances
	  */
	 playlistPrototypeCountTracks(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeCountTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in accounts of this model.
	  * @param id Playlist id
	  * @param data
	  */
	 playlistPrototypeCreateAccounts(
		 params: { id: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeCreateAccounts(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in tracks of this model.
	  * @param id Playlist id
	  * @param data
	  */
	 playlistPrototypeCreateTracks(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeCreateTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all accounts of this model.
	  * @param id Playlist id
	  */
	 playlistPrototypeDeleteAccounts(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeDeleteAccounts(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all tracks of this model.
	  * @param id Playlist id
	  */
	 playlistPrototypeDeleteTracks(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeDeleteTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeDestroyByIdAccounts(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeDestroyByIdAccounts(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeDestroyByIdTracks(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeDestroyByIdTracks(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of accounts relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeExistsAccounts(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeExistsAccounts(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of tracks relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeExistsTracks(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeExistsTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeFindByIdAccounts(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeFindByIdAccounts(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeFindByIdTracks(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeFindByIdTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries accounts of Playlist.
	  * @param id Playlist id
	  * @param filter
	  */
	 playlistPrototypeGetAccounts(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeGetAccounts(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation project.
	  * @param id Playlist id
	  * @param refresh
	  */
	 playlistPrototypeGetProject(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeGetProject(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries tracks of Playlist.
	  * @param id Playlist id
	  * @param filter
	  */
	 playlistPrototypeGetTracks(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeGetTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  * @param data
	  */
	 playlistPrototypeLinkAccounts(
		 params: { id: string; fk: string; data?: AccountPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountPlaylist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeLinkAccounts(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  * @param data
	  */
	 playlistPrototypeLinkTracks(
		 params: { id: string; fk: string; data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeLinkTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Playlist id
	  * @param data An object of model property name/value pairs
	  */
	 playlistPrototypePatchAttributes(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the accounts relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeUnlinkAccounts(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeUnlinkAccounts(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the tracks relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeUnlinkTracks(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeUnlinkTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  * @param data
	  */
	 playlistPrototypeUpdateByIdAccounts(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeUpdateByIdAccounts(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  * @param data
	  */
	 playlistPrototypeUpdateByIdTracks(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistPrototypeUpdateByIdTracks(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 playlistReplaceByIdPostPlaylistsidReplace(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistReplaceByIdPostPlaylistsidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 playlistReplaceByIdPutPlaylistsid(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistReplaceByIdPutPlaylistsid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(
		 params: { data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs =
			 PlaylistApiFetchParamCreator.playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 playlistReplaceOrCreatePutPlaylists(
		 params: { data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistReplaceOrCreatePutPlaylists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 playlistUpdateAll(
		 params: { where?: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 playlistUpsertWithWhere(
		 params: { where?: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = PlaylistApiFetchParamCreator.playlistUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * PlaylistApi - object-oriented interface
  */
 export class PlaylistApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 playlistCount(params: { where?: string }, options?: any) {
		 return PlaylistApiFp.playlistCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 playlistCreate(params: { data?: Playlist }, options?: any) {
		 return PlaylistApiFp.playlistCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 playlistCreateChangeStreamGetPlaylistsChangeStream(params: { options?: string }, options?: any) {
		 return PlaylistApiFp.playlistCreateChangeStreamGetPlaylistsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 playlistCreateChangeStreamPostPlaylistsChangeStream(params: { options?: string }, options?: any) {
		 return PlaylistApiFp.playlistCreateChangeStreamPostPlaylistsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 playlistDeleteById(params: { id: string }, options?: any) {
		 return PlaylistApiFp.playlistDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 playlistExistsGetPlaylistsidExists(params: { id: string }, options?: any) {
		 return PlaylistApiFp.playlistExistsGetPlaylistsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 playlistExistsHeadPlaylistsid(params: { id: string }, options?: any) {
		 return PlaylistApiFp.playlistExistsHeadPlaylistsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 playlistFind(params: { filter?: string }, options?: any) {
		 return PlaylistApiFp.playlistFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 playlistFindById(params: { id: string; filter?: string }, options?: any) {
		 return PlaylistApiFp.playlistFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 playlistFindOne(params: { filter?: string }, options?: any) {
		 return PlaylistApiFp.playlistFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 playlistPatchOrCreate(params: { data?: Playlist }, options?: any) {
		 return PlaylistApiFp.playlistPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts accounts of Playlist.
	  * @param id Playlist id
	  * @param where Criteria to match model instances
	  */
	 playlistPrototypeCountAccounts(params: { id: string; where?: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeCountAccounts(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts tracks of Playlist.
	  * @param id Playlist id
	  * @param where Criteria to match model instances
	  */
	 playlistPrototypeCountTracks(params: { id: string; where?: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeCountTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in accounts of this model.
	  * @param id Playlist id
	  * @param data
	  */
	 playlistPrototypeCreateAccounts(params: { id: string; data?: Account }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeCreateAccounts(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Creates a new instance in tracks of this model.
	  * @param id Playlist id
	  * @param data
	  */
	 playlistPrototypeCreateTracks(params: { id: string; data?: Track }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeCreateTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all accounts of this model.
	  * @param id Playlist id
	  */
	 playlistPrototypeDeleteAccounts(params: { id: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeDeleteAccounts(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Deletes all tracks of this model.
	  * @param id Playlist id
	  */
	 playlistPrototypeDeleteTracks(params: { id: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeDeleteTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeDestroyByIdAccounts(params: { id: string; fk: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeDestroyByIdAccounts(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeDestroyByIdTracks(params: { id: string; fk: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeDestroyByIdTracks(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check the existence of accounts relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeExistsAccounts(params: { id: string; fk: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeExistsAccounts(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check the existence of tracks relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeExistsTracks(params: { id: string; fk: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeExistsTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeFindByIdAccounts(params: { id: string; fk: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeFindByIdAccounts(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeFindByIdTracks(params: { id: string; fk: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeFindByIdTracks(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Queries accounts of Playlist.
	  * @param id Playlist id
	  * @param filter
	  */
	 playlistPrototypeGetAccounts(params: { id: string; filter?: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeGetAccounts(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation project.
	  * @param id Playlist id
	  * @param refresh
	  */
	 playlistPrototypeGetProject(params: { id: string; refresh?: boolean }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeGetProject(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries tracks of Playlist.
	  * @param id Playlist id
	  * @param filter
	  */
	 playlistPrototypeGetTracks(params: { id: string; filter?: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeGetTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  * @param data
	  */
	 playlistPrototypeLinkAccounts(
		 params: { id: string; fk: string; data?: AccountPlaylist },
		 options?: any
	 ) {
		 return PlaylistApiFp.playlistPrototypeLinkAccounts(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  * @param data
	  */
	 playlistPrototypeLinkTracks(
		 params: { id: string; fk: string; data?: TrackInPlaylist },
		 options?: any
	 ) {
		 return PlaylistApiFp.playlistPrototypeLinkTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Playlist id
	  * @param data An object of model property name/value pairs
	  */
	 playlistPrototypePatchAttributes(params: { id: string; data?: Playlist }, options?: any) {
		 return PlaylistApiFp.playlistPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Remove the accounts relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  */
	 playlistPrototypeUnlinkAccounts(params: { id: string; fk: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeUnlinkAccounts(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Remove the tracks relation to an item by id.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  */
	 playlistPrototypeUnlinkTracks(params: { id: string; fk: string }, options?: any) {
		 return PlaylistApiFp.playlistPrototypeUnlinkTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for accounts.
	  * @param id Playlist id
	  * @param fk Foreign key for accounts
	  * @param data
	  */
	 playlistPrototypeUpdateByIdAccounts(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ) {
		 return PlaylistApiFp.playlistPrototypeUpdateByIdAccounts(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for tracks.
	  * @param id Playlist id
	  * @param fk Foreign key for tracks
	  * @param data
	  */
	 playlistPrototypeUpdateByIdTracks(
		 params: { id: string; fk: string; data?: Track },
		 options?: any
	 ) {
		 return PlaylistApiFp.playlistPrototypeUpdateByIdTracks(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 playlistReplaceByIdPostPlaylistsidReplace(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ) {
		 return PlaylistApiFp.playlistReplaceByIdPostPlaylistsidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 playlistReplaceByIdPutPlaylistsid(params: { id: string; data?: Playlist }, options?: any) {
		 return PlaylistApiFp.playlistReplaceByIdPutPlaylistsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params: { data?: Playlist }, options?: any) {
		 return PlaylistApiFp.playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 playlistReplaceOrCreatePutPlaylists(params: { data?: Playlist }, options?: any) {
		 return PlaylistApiFp.playlistReplaceOrCreatePutPlaylists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 playlistUpdateAll(params: { where?: string; data?: Playlist }, options?: any) {
		 return PlaylistApiFp.playlistUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 playlistUpsertWithWhere(params: { where?: string; data?: Playlist }, options?: any) {
		 return PlaylistApiFp.playlistUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * PlaylistApi - factory interface
  */
 export const PlaylistApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 playlistCount(params: { where?: string }, options?: any) {
			 return PlaylistApiFp.playlistCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 playlistCreate(params: { data?: Playlist }, options?: any) {
			 return PlaylistApiFp.playlistCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 playlistCreateChangeStreamGetPlaylistsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return PlaylistApiFp.playlistCreateChangeStreamGetPlaylistsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 playlistCreateChangeStreamPostPlaylistsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return PlaylistApiFp.playlistCreateChangeStreamPostPlaylistsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 playlistDeleteById(params: { id: string }, options?: any) {
			 return PlaylistApiFp.playlistDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 playlistExistsGetPlaylistsidExists(params: { id: string }, options?: any) {
			 return PlaylistApiFp.playlistExistsGetPlaylistsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 playlistExistsHeadPlaylistsid(params: { id: string }, options?: any) {
			 return PlaylistApiFp.playlistExistsHeadPlaylistsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 playlistFind(params: { filter?: string }, options?: any) {
			 return PlaylistApiFp.playlistFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 playlistFindById(params: { id: string; filter?: string }, options?: any) {
			 return PlaylistApiFp.playlistFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 playlistFindOne(params: { filter?: string }, options?: any) {
			 return PlaylistApiFp.playlistFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 playlistPatchOrCreate(params: { data?: Playlist }, options?: any) {
			 return PlaylistApiFp.playlistPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts accounts of Playlist.
		  * @param id Playlist id
		  * @param where Criteria to match model instances
		  */
		 playlistPrototypeCountAccounts(params: { id: string; where?: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeCountAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts tracks of Playlist.
		  * @param id Playlist id
		  * @param where Criteria to match model instances
		  */
		 playlistPrototypeCountTracks(params: { id: string; where?: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeCountTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in accounts of this model.
		  * @param id Playlist id
		  * @param data
		  */
		 playlistPrototypeCreateAccounts(params: { id: string; data?: Account }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeCreateAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in tracks of this model.
		  * @param id Playlist id
		  * @param data
		  */
		 playlistPrototypeCreateTracks(params: { id: string; data?: Track }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeCreateTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all accounts of this model.
		  * @param id Playlist id
		  */
		 playlistPrototypeDeleteAccounts(params: { id: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeDeleteAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all tracks of this model.
		  * @param id Playlist id
		  */
		 playlistPrototypeDeleteTracks(params: { id: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeDeleteTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for accounts.
		  * @param id Playlist id
		  * @param fk Foreign key for accounts
		  */
		 playlistPrototypeDestroyByIdAccounts(params: { id: string; fk: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeDestroyByIdAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for tracks.
		  * @param id Playlist id
		  * @param fk Foreign key for tracks
		  */
		 playlistPrototypeDestroyByIdTracks(params: { id: string; fk: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeDestroyByIdTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of accounts relation to an item by id.
		  * @param id Playlist id
		  * @param fk Foreign key for accounts
		  */
		 playlistPrototypeExistsAccounts(params: { id: string; fk: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeExistsAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of tracks relation to an item by id.
		  * @param id Playlist id
		  * @param fk Foreign key for tracks
		  */
		 playlistPrototypeExistsTracks(params: { id: string; fk: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeExistsTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for accounts.
		  * @param id Playlist id
		  * @param fk Foreign key for accounts
		  */
		 playlistPrototypeFindByIdAccounts(params: { id: string; fk: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeFindByIdAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for tracks.
		  * @param id Playlist id
		  * @param fk Foreign key for tracks
		  */
		 playlistPrototypeFindByIdTracks(params: { id: string; fk: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeFindByIdTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries accounts of Playlist.
		  * @param id Playlist id
		  * @param filter
		  */
		 playlistPrototypeGetAccounts(params: { id: string; filter?: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeGetAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation project.
		  * @param id Playlist id
		  * @param refresh
		  */
		 playlistPrototypeGetProject(params: { id: string; refresh?: boolean }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeGetProject(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries tracks of Playlist.
		  * @param id Playlist id
		  * @param filter
		  */
		 playlistPrototypeGetTracks(params: { id: string; filter?: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeGetTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for accounts.
		  * @param id Playlist id
		  * @param fk Foreign key for accounts
		  * @param data
		  */
		 playlistPrototypeLinkAccounts(
			 params: { id: string; fk: string; data?: AccountPlaylist },
			 options?: any
		 ) {
			 return PlaylistApiFp.playlistPrototypeLinkAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for tracks.
		  * @param id Playlist id
		  * @param fk Foreign key for tracks
		  * @param data
		  */
		 playlistPrototypeLinkTracks(
			 params: { id: string; fk: string; data?: TrackInPlaylist },
			 options?: any
		 ) {
			 return PlaylistApiFp.playlistPrototypeLinkTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Playlist id
		  * @param data An object of model property name/value pairs
		  */
		 playlistPrototypePatchAttributes(params: { id: string; data?: Playlist }, options?: any) {
			 return PlaylistApiFp.playlistPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the accounts relation to an item by id.
		  * @param id Playlist id
		  * @param fk Foreign key for accounts
		  */
		 playlistPrototypeUnlinkAccounts(params: { id: string; fk: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeUnlinkAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the tracks relation to an item by id.
		  * @param id Playlist id
		  * @param fk Foreign key for tracks
		  */
		 playlistPrototypeUnlinkTracks(params: { id: string; fk: string }, options?: any) {
			 return PlaylistApiFp.playlistPrototypeUnlinkTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for accounts.
		  * @param id Playlist id
		  * @param fk Foreign key for accounts
		  * @param data
		  */
		 playlistPrototypeUpdateByIdAccounts(
			 params: { id: string; fk: string; data?: Account },
			 options?: any
		 ) {
			 return PlaylistApiFp.playlistPrototypeUpdateByIdAccounts(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for tracks.
		  * @param id Playlist id
		  * @param fk Foreign key for tracks
		  * @param data
		  */
		 playlistPrototypeUpdateByIdTracks(
			 params: { id: string; fk: string; data?: Track },
			 options?: any
		 ) {
			 return PlaylistApiFp.playlistPrototypeUpdateByIdTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 playlistReplaceByIdPostPlaylistsidReplace(
			 params: { id: string; data?: Playlist },
			 options?: any
		 ) {
			 return PlaylistApiFp.playlistReplaceByIdPostPlaylistsidReplace(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 playlistReplaceByIdPutPlaylistsid(params: { id: string; data?: Playlist }, options?: any) {
			 return PlaylistApiFp.playlistReplaceByIdPutPlaylistsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(
			 params: { data?: Playlist },
			 options?: any
		 ) {
			 return PlaylistApiFp.playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 playlistReplaceOrCreatePutPlaylists(params: { data?: Playlist }, options?: any) {
			 return PlaylistApiFp.playlistReplaceOrCreatePutPlaylists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 playlistUpdateAll(params: { where?: string; data?: Playlist }, options?: any) {
			 return PlaylistApiFp.playlistUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 playlistUpsertWithWhere(params: { where?: string; data?: Playlist }, options?: any) {
			 return PlaylistApiFp.playlistUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * PriceApi - fetch parameter creator
  */
 export const PriceApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 priceCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Prices/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 priceCreate(params: { data?: Price }, options?: any): FetchArgs {
		 const baseUrl = `/Prices`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 priceCreateChangeStreamGetPricesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Prices/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 priceCreateChangeStreamPostPricesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Prices/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 priceDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling priceDeleteById');
		 }
		 const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 priceExistsGetPricesidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling priceExistsGetPricesidExists');
		 }
		 const baseUrl = `/Prices/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 priceExistsHeadPricesid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling priceExistsHeadPricesid');
		 }
		 const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 priceFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Prices`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 priceFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling priceFindById');
		 }
		 const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 priceFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Prices/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 pricePatchOrCreate(params: { data?: Price }, options?: any): FetchArgs {
		 const baseUrl = `/Prices`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Price id
	  * @param refresh
	  */
	 pricePrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling pricePrototypeGetAccount');
		 }
		 const baseUrl = `/Prices/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Price id
	  * @param data An object of model property name/value pairs
	  */
	 pricePrototypePatchAttributes(params: { id: string; data?: Price }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling pricePrototypePatchAttributes');
		 }
		 const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 priceReplaceByIdPostPricesidReplace(
		 params: { id: string; data?: Price },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling priceReplaceByIdPostPricesidReplace'
			 );
		 }
		 const baseUrl = `/Prices/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 priceReplaceByIdPutPricesid(params: { id: string; data?: Price }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling priceReplaceByIdPutPricesid');
		 }
		 const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 priceReplaceOrCreatePostPricesReplaceOrCreate(
		 params: { data?: Price },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Prices/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 priceReplaceOrCreatePutPrices(params: { data?: Price }, options?: any): FetchArgs {
		 const baseUrl = `/Prices`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 priceUpdateAll(params: { where?: string; data?: Price }, options?: any): FetchArgs {
		 const baseUrl = `/Prices/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 priceUpsertWithWhere(params: { where?: string; data?: Price }, options?: any): FetchArgs {
		 const baseUrl = `/Prices/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * PriceApi - functional programming interface
  */
 export const PriceApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 priceCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = PriceApiFetchParamCreator.priceCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 priceCreate(
		 params: { data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.priceCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 priceCreateChangeStreamGetPricesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PriceApiFetchParamCreator.priceCreateChangeStreamGetPricesChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 priceCreateChangeStreamPostPricesChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PriceApiFetchParamCreator.priceCreateChangeStreamPostPricesChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 priceDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = PriceApiFetchParamCreator.priceDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 priceExistsGetPricesidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = PriceApiFetchParamCreator.priceExistsGetPricesidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 priceExistsHeadPricesid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = PriceApiFetchParamCreator.priceExistsHeadPricesid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 priceFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Price>> {
		 const fetchArgs = PriceApiFetchParamCreator.priceFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 priceFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.priceFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 priceFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.priceFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 pricePatchOrCreate(
		 params: { data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.pricePatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Price id
	  * @param refresh
	  */
	 pricePrototypeGetAccount(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = PriceApiFetchParamCreator.pricePrototypeGetAccount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Price id
	  * @param data An object of model property name/value pairs
	  */
	 pricePrototypePatchAttributes(
		 params: { id: string; data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.pricePrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 priceReplaceByIdPostPricesidReplace(
		 params: { id: string; data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.priceReplaceByIdPostPricesidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 priceReplaceByIdPutPricesid(
		 params: { id: string; data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.priceReplaceByIdPutPricesid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 priceReplaceOrCreatePostPricesReplaceOrCreate(
		 params: { data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.priceReplaceOrCreatePostPricesReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 priceReplaceOrCreatePutPrices(
		 params: { data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.priceReplaceOrCreatePutPrices(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 priceUpdateAll(
		 params: { where?: string; data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = PriceApiFetchParamCreator.priceUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 priceUpsertWithWhere(
		 params: { where?: string; data?: Price },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Price> {
		 const fetchArgs = PriceApiFetchParamCreator.priceUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * PriceApi - object-oriented interface
  */
 export class PriceApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 priceCount(params: { where?: string }, options?: any) {
		 return PriceApiFp.priceCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 priceCreate(params: { data?: Price }, options?: any) {
		 return PriceApiFp.priceCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 priceCreateChangeStreamGetPricesChangeStream(params: { options?: string }, options?: any) {
		 return PriceApiFp.priceCreateChangeStreamGetPricesChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 priceCreateChangeStreamPostPricesChangeStream(params: { options?: string }, options?: any) {
		 return PriceApiFp.priceCreateChangeStreamPostPricesChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 priceDeleteById(params: { id: string }, options?: any) {
		 return PriceApiFp.priceDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 priceExistsGetPricesidExists(params: { id: string }, options?: any) {
		 return PriceApiFp.priceExistsGetPricesidExists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 priceExistsHeadPricesid(params: { id: string }, options?: any) {
		 return PriceApiFp.priceExistsHeadPricesid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 priceFind(params: { filter?: string }, options?: any) {
		 return PriceApiFp.priceFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 priceFindById(params: { id: string; filter?: string }, options?: any) {
		 return PriceApiFp.priceFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 priceFindOne(params: { filter?: string }, options?: any) {
		 return PriceApiFp.priceFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 pricePatchOrCreate(params: { data?: Price }, options?: any) {
		 return PriceApiFp.pricePatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation account.
	  * @param id Price id
	  * @param refresh
	  */
	 pricePrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
		 return PriceApiFp.pricePrototypeGetAccount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Price id
	  * @param data An object of model property name/value pairs
	  */
	 pricePrototypePatchAttributes(params: { id: string; data?: Price }, options?: any) {
		 return PriceApiFp.pricePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 priceReplaceByIdPostPricesidReplace(params: { id: string; data?: Price }, options?: any) {
		 return PriceApiFp.priceReplaceByIdPostPricesidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 priceReplaceByIdPutPricesid(params: { id: string; data?: Price }, options?: any) {
		 return PriceApiFp.priceReplaceByIdPutPricesid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 priceReplaceOrCreatePostPricesReplaceOrCreate(params: { data?: Price }, options?: any) {
		 return PriceApiFp.priceReplaceOrCreatePostPricesReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 priceReplaceOrCreatePutPrices(params: { data?: Price }, options?: any) {
		 return PriceApiFp.priceReplaceOrCreatePutPrices(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 priceUpdateAll(params: { where?: string; data?: Price }, options?: any) {
		 return PriceApiFp.priceUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 priceUpsertWithWhere(params: { where?: string; data?: Price }, options?: any) {
		 return PriceApiFp.priceUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * PriceApi - factory interface
  */
 export const PriceApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 priceCount(params: { where?: string }, options?: any) {
			 return PriceApiFp.priceCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 priceCreate(params: { data?: Price }, options?: any) {
			 return PriceApiFp.priceCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 priceCreateChangeStreamGetPricesChangeStream(params: { options?: string }, options?: any) {
			 return PriceApiFp.priceCreateChangeStreamGetPricesChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 priceCreateChangeStreamPostPricesChangeStream(params: { options?: string }, options?: any) {
			 return PriceApiFp.priceCreateChangeStreamPostPricesChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 priceDeleteById(params: { id: string }, options?: any) {
			 return PriceApiFp.priceDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 priceExistsGetPricesidExists(params: { id: string }, options?: any) {
			 return PriceApiFp.priceExistsGetPricesidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 priceExistsHeadPricesid(params: { id: string }, options?: any) {
			 return PriceApiFp.priceExistsHeadPricesid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 priceFind(params: { filter?: string }, options?: any) {
			 return PriceApiFp.priceFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 priceFindById(params: { id: string; filter?: string }, options?: any) {
			 return PriceApiFp.priceFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 priceFindOne(params: { filter?: string }, options?: any) {
			 return PriceApiFp.priceFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 pricePatchOrCreate(params: { data?: Price }, options?: any) {
			 return PriceApiFp.pricePatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation account.
		  * @param id Price id
		  * @param refresh
		  */
		 pricePrototypeGetAccount(params: { id: string; refresh?: boolean }, options?: any) {
			 return PriceApiFp.pricePrototypeGetAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Price id
		  * @param data An object of model property name/value pairs
		  */
		 pricePrototypePatchAttributes(params: { id: string; data?: Price }, options?: any) {
			 return PriceApiFp.pricePrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 priceReplaceByIdPostPricesidReplace(params: { id: string; data?: Price }, options?: any) {
			 return PriceApiFp.priceReplaceByIdPostPricesidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 priceReplaceByIdPutPricesid(params: { id: string; data?: Price }, options?: any) {
			 return PriceApiFp.priceReplaceByIdPutPricesid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 priceReplaceOrCreatePostPricesReplaceOrCreate(params: { data?: Price }, options?: any) {
			 return PriceApiFp.priceReplaceOrCreatePostPricesReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 priceReplaceOrCreatePutPrices(params: { data?: Price }, options?: any) {
			 return PriceApiFp.priceReplaceOrCreatePutPrices(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 priceUpdateAll(params: { where?: string; data?: Price }, options?: any) {
			 return PriceApiFp.priceUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 priceUpsertWithWhere(params: { where?: string; data?: Price }, options?: any) {
			 return PriceApiFp.priceUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * ProjectApi - fetch parameter creator
  */
 export const ProjectApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 projectCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Projects/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 projectCreate(params: { data?: Project }, options?: any): FetchArgs {
		 const baseUrl = `/Projects`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 projectCreateChangeStreamGetProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Projects/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 projectCreateChangeStreamPostProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Projects/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 projectDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectDeleteById');
		 }
		 const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 projectExistsGetProjectsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling projectExistsGetProjectsidExists'
			 );
		 }
		 const baseUrl = `/Projects/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 projectExistsHeadProjectsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectExistsHeadProjectsid');
		 }
		 const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 projectFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Projects`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 projectFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectFindById');
		 }
		 const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 projectFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Projects/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 projectPatchOrCreate(params: { data?: Project }, options?: any): FetchArgs {
		 const baseUrl = `/Projects`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts onwer of Project.
	  * @param id Project id
	  * @param where Criteria to match model instances
	  */
	 projectPrototypeCountOnwer(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeCountOnwer');
		 }
		 const baseUrl = `/Projects/{id}/onwer/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts playlists of Project.
	  * @param id Project id
	  * @param where Criteria to match model instances
	  */
	 projectPrototypeCountPlaylists(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeCountPlaylists');
		 }
		 const baseUrl = `/Projects/{id}/playlists/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in onwer of this model.
	  * @param id Project id
	  * @param data
	  */
	 projectPrototypeCreateOnwer(params: { id: string; data?: Account }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeCreateOnwer');
		 }
		 const baseUrl = `/Projects/{id}/onwer`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in playlists of this model.
	  * @param id Project id
	  * @param data
	  */
	 projectPrototypeCreatePlaylists(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeCreatePlaylists');
		 }
		 const baseUrl = `/Projects/{id}/playlists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all onwer of this model.
	  * @param id Project id
	  */
	 projectPrototypeDeleteOnwer(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeDeleteOnwer');
		 }
		 const baseUrl = `/Projects/{id}/onwer`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all playlists of this model.
	  * @param id Project id
	  */
	 projectPrototypeDeletePlaylists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeDeletePlaylists');
		 }
		 const baseUrl = `/Projects/{id}/playlists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeDestroyByIdOnwer(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling projectPrototypeDestroyByIdOnwer'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling projectPrototypeDestroyByIdOnwer'
			 );
		 }
		 const baseUrl = `/Projects/{id}/onwer/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for playlists.
	  * @param id Project id
	  * @param fk Foreign key for playlists
	  */
	 projectPrototypeDestroyByIdPlaylists(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling projectPrototypeDestroyByIdPlaylists'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling projectPrototypeDestroyByIdPlaylists'
			 );
		 }
		 const baseUrl = `/Projects/{id}/playlists/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of onwer relation to an item by id.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeExistsOnwer(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeExistsOnwer');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling projectPrototypeExistsOnwer');
		 }
		 const baseUrl = `/Projects/{id}/onwer/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeFindByIdOnwer(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeFindByIdOnwer');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling projectPrototypeFindByIdOnwer');
		 }
		 const baseUrl = `/Projects/{id}/onwer/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for playlists.
	  * @param id Project id
	  * @param fk Foreign key for playlists
	  */
	 projectPrototypeFindByIdPlaylists(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling projectPrototypeFindByIdPlaylists'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling projectPrototypeFindByIdPlaylists'
			 );
		 }
		 const baseUrl = `/Projects/{id}/playlists/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries onwer of Project.
	  * @param id Project id
	  * @param filter
	  */
	 projectPrototypeGetOnwer(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeGetOnwer');
		 }
		 const baseUrl = `/Projects/{id}/onwer`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries playlists of Project.
	  * @param id Project id
	  * @param filter
	  */
	 projectPrototypeGetPlaylists(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeGetPlaylists');
		 }
		 const baseUrl = `/Projects/{id}/playlists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  * @param data
	  */
	 projectPrototypeLinkOnwer(
		 params: { id: string; fk: string; data?: AccountProject },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeLinkOnwer');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling projectPrototypeLinkOnwer');
		 }
		 const baseUrl = `/Projects/{id}/onwer/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Project id
	  * @param data An object of model property name/value pairs
	  */
	 projectPrototypePatchAttributes(
		 params: { id: string; data?: Project },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypePatchAttributes');
		 }
		 const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the onwer relation to an item by id.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeUnlinkOnwer(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeUnlinkOnwer');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling projectPrototypeUnlinkOnwer');
		 }
		 const baseUrl = `/Projects/{id}/onwer/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  * @param data
	  */
	 projectPrototypeUpdateByIdOnwer(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectPrototypeUpdateByIdOnwer');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling projectPrototypeUpdateByIdOnwer');
		 }
		 const baseUrl = `/Projects/{id}/onwer/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for playlists.
	  * @param id Project id
	  * @param fk Foreign key for playlists
	  * @param data
	  */
	 projectPrototypeUpdateByIdPlaylists(
		 params: { id: string; fk: string; data?: Playlist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling projectPrototypeUpdateByIdPlaylists'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling projectPrototypeUpdateByIdPlaylists'
			 );
		 }
		 const baseUrl = `/Projects/{id}/playlists/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 projectReplaceByIdPostProjectsidReplace(
		 params: { id: string; data?: Project },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling projectReplaceByIdPostProjectsidReplace'
			 );
		 }
		 const baseUrl = `/Projects/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 projectReplaceByIdPutProjectsid(
		 params: { id: string; data?: Project },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling projectReplaceByIdPutProjectsid');
		 }
		 const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 projectReplaceOrCreatePostProjectsReplaceOrCreate(
		 params: { data?: Project },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Projects/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 projectReplaceOrCreatePutProjects(params: { data?: Project }, options?: any): FetchArgs {
		 const baseUrl = `/Projects`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 projectUpdateAll(params: { where?: string; data?: Project }, options?: any): FetchArgs {
		 const baseUrl = `/Projects/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 projectUpsertWithWhere(params: { where?: string; data?: Project }, options?: any): FetchArgs {
		 const baseUrl = `/Projects/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * ProjectApi - functional programming interface
  */
 export const ProjectApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 projectCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 projectCreate(
		 params: { data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 projectCreateChangeStreamGetProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectCreateChangeStreamGetProjectsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 projectCreateChangeStreamPostProjectsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectCreateChangeStreamPostProjectsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 projectDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 projectExistsGetProjectsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectExistsGetProjectsidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 projectExistsHeadProjectsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectExistsHeadProjectsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 projectFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Project>> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 projectFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 projectFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 projectPatchOrCreate(
		 params: { data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts onwer of Project.
	  * @param id Project id
	  * @param where Criteria to match model instances
	  */
	 projectPrototypeCountOnwer(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeCountOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts playlists of Project.
	  * @param id Project id
	  * @param where Criteria to match model instances
	  */
	 projectPrototypeCountPlaylists(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeCountPlaylists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in onwer of this model.
	  * @param id Project id
	  * @param data
	  */
	 projectPrototypeCreateOnwer(
		 params: { id: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeCreateOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in playlists of this model.
	  * @param id Project id
	  * @param data
	  */
	 projectPrototypeCreatePlaylists(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeCreatePlaylists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all onwer of this model.
	  * @param id Project id
	  */
	 projectPrototypeDeleteOnwer(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeDeleteOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all playlists of this model.
	  * @param id Project id
	  */
	 projectPrototypeDeletePlaylists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeDeletePlaylists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeDestroyByIdOnwer(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeDestroyByIdOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for playlists.
	  * @param id Project id
	  * @param fk Foreign key for playlists
	  */
	 projectPrototypeDestroyByIdPlaylists(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeDestroyByIdPlaylists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of onwer relation to an item by id.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeExistsOnwer(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeExistsOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeFindByIdOnwer(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeFindByIdOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for playlists.
	  * @param id Project id
	  * @param fk Foreign key for playlists
	  */
	 projectPrototypeFindByIdPlaylists(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeFindByIdPlaylists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries onwer of Project.
	  * @param id Project id
	  * @param filter
	  */
	 projectPrototypeGetOnwer(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeGetOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries playlists of Project.
	  * @param id Project id
	  * @param filter
	  */
	 projectPrototypeGetPlaylists(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Playlist>> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeGetPlaylists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  * @param data
	  */
	 projectPrototypeLinkOnwer(
		 params: { id: string; fk: string; data?: AccountProject },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountProject> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeLinkOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Project id
	  * @param data An object of model property name/value pairs
	  */
	 projectPrototypePatchAttributes(
		 params: { id: string; data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the onwer relation to an item by id.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeUnlinkOnwer(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeUnlinkOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  * @param data
	  */
	 projectPrototypeUpdateByIdOnwer(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeUpdateByIdOnwer(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for playlists.
	  * @param id Project id
	  * @param fk Foreign key for playlists
	  * @param data
	  */
	 projectPrototypeUpdateByIdPlaylists(
		 params: { id: string; fk: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectPrototypeUpdateByIdPlaylists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 projectReplaceByIdPostProjectsidReplace(
		 params: { id: string; data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectReplaceByIdPostProjectsidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 projectReplaceByIdPutProjectsid(
		 params: { id: string; data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectReplaceByIdPutProjectsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 projectReplaceOrCreatePostProjectsReplaceOrCreate(
		 params: { data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectReplaceOrCreatePostProjectsReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 projectReplaceOrCreatePutProjects(
		 params: { data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectReplaceOrCreatePutProjects(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 projectUpdateAll(
		 params: { where?: string; data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 projectUpsertWithWhere(
		 params: { where?: string; data?: Project },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
		 const fetchArgs = ProjectApiFetchParamCreator.projectUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * ProjectApi - object-oriented interface
  */
 export class ProjectApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 projectCount(params: { where?: string }, options?: any) {
		 return ProjectApiFp.projectCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 projectCreate(params: { data?: Project }, options?: any) {
		 return ProjectApiFp.projectCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 projectCreateChangeStreamGetProjectsChangeStream(params: { options?: string }, options?: any) {
		 return ProjectApiFp.projectCreateChangeStreamGetProjectsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 projectCreateChangeStreamPostProjectsChangeStream(params: { options?: string }, options?: any) {
		 return ProjectApiFp.projectCreateChangeStreamPostProjectsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 projectDeleteById(params: { id: string }, options?: any) {
		 return ProjectApiFp.projectDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 projectExistsGetProjectsidExists(params: { id: string }, options?: any) {
		 return ProjectApiFp.projectExistsGetProjectsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 projectExistsHeadProjectsid(params: { id: string }, options?: any) {
		 return ProjectApiFp.projectExistsHeadProjectsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 projectFind(params: { filter?: string }, options?: any) {
		 return ProjectApiFp.projectFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 projectFindById(params: { id: string; filter?: string }, options?: any) {
		 return ProjectApiFp.projectFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 projectFindOne(params: { filter?: string }, options?: any) {
		 return ProjectApiFp.projectFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 projectPatchOrCreate(params: { data?: Project }, options?: any) {
		 return ProjectApiFp.projectPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts onwer of Project.
	  * @param id Project id
	  * @param where Criteria to match model instances
	  */
	 projectPrototypeCountOnwer(params: { id: string; where?: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeCountOnwer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts playlists of Project.
	  * @param id Project id
	  * @param where Criteria to match model instances
	  */
	 projectPrototypeCountPlaylists(params: { id: string; where?: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeCountPlaylists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in onwer of this model.
	  * @param id Project id
	  * @param data
	  */
	 projectPrototypeCreateOnwer(params: { id: string; data?: Account }, options?: any) {
		 return ProjectApiFp.projectPrototypeCreateOnwer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in playlists of this model.
	  * @param id Project id
	  * @param data
	  */
	 projectPrototypeCreatePlaylists(params: { id: string; data?: Playlist }, options?: any) {
		 return ProjectApiFp.projectPrototypeCreatePlaylists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all onwer of this model.
	  * @param id Project id
	  */
	 projectPrototypeDeleteOnwer(params: { id: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeDeleteOnwer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all playlists of this model.
	  * @param id Project id
	  */
	 projectPrototypeDeletePlaylists(params: { id: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeDeletePlaylists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeDestroyByIdOnwer(params: { id: string; fk: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeDestroyByIdOnwer(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for playlists.
	  * @param id Project id
	  * @param fk Foreign key for playlists
	  */
	 projectPrototypeDestroyByIdPlaylists(params: { id: string; fk: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeDestroyByIdPlaylists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check the existence of onwer relation to an item by id.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeExistsOnwer(params: { id: string; fk: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeExistsOnwer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeFindByIdOnwer(params: { id: string; fk: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeFindByIdOnwer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for playlists.
	  * @param id Project id
	  * @param fk Foreign key for playlists
	  */
	 projectPrototypeFindByIdPlaylists(params: { id: string; fk: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeFindByIdPlaylists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Queries onwer of Project.
	  * @param id Project id
	  * @param filter
	  */
	 projectPrototypeGetOnwer(params: { id: string; filter?: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeGetOnwer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries playlists of Project.
	  * @param id Project id
	  * @param filter
	  */
	 projectPrototypeGetPlaylists(params: { id: string; filter?: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeGetPlaylists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  * @param data
	  */
	 projectPrototypeLinkOnwer(
		 params: { id: string; fk: string; data?: AccountProject },
		 options?: any
	 ) {
		 return ProjectApiFp.projectPrototypeLinkOnwer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Project id
	  * @param data An object of model property name/value pairs
	  */
	 projectPrototypePatchAttributes(params: { id: string; data?: Project }, options?: any) {
		 return ProjectApiFp.projectPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the onwer relation to an item by id.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  */
	 projectPrototypeUnlinkOnwer(params: { id: string; fk: string }, options?: any) {
		 return ProjectApiFp.projectPrototypeUnlinkOnwer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for onwer.
	  * @param id Project id
	  * @param fk Foreign key for onwer
	  * @param data
	  */
	 projectPrototypeUpdateByIdOnwer(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ) {
		 return ProjectApiFp.projectPrototypeUpdateByIdOnwer(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for playlists.
	  * @param id Project id
	  * @param fk Foreign key for playlists
	  * @param data
	  */
	 projectPrototypeUpdateByIdPlaylists(
		 params: { id: string; fk: string; data?: Playlist },
		 options?: any
	 ) {
		 return ProjectApiFp.projectPrototypeUpdateByIdPlaylists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 projectReplaceByIdPostProjectsidReplace(params: { id: string; data?: Project }, options?: any) {
		 return ProjectApiFp.projectReplaceByIdPostProjectsidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 projectReplaceByIdPutProjectsid(params: { id: string; data?: Project }, options?: any) {
		 return ProjectApiFp.projectReplaceByIdPutProjectsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 projectReplaceOrCreatePostProjectsReplaceOrCreate(params: { data?: Project }, options?: any) {
		 return ProjectApiFp.projectReplaceOrCreatePostProjectsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 projectReplaceOrCreatePutProjects(params: { data?: Project }, options?: any) {
		 return ProjectApiFp.projectReplaceOrCreatePutProjects(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 projectUpdateAll(params: { where?: string; data?: Project }, options?: any) {
		 return ProjectApiFp.projectUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 projectUpsertWithWhere(params: { where?: string; data?: Project }, options?: any) {
		 return ProjectApiFp.projectUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * ProjectApi - factory interface
  */
 export const ProjectApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 projectCount(params: { where?: string }, options?: any) {
			 return ProjectApiFp.projectCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 projectCreate(params: { data?: Project }, options?: any) {
			 return ProjectApiFp.projectCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 projectCreateChangeStreamGetProjectsChangeStream(params: { options?: string }, options?: any) {
			 return ProjectApiFp.projectCreateChangeStreamGetProjectsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 projectCreateChangeStreamPostProjectsChangeStream(params: { options?: string }, options?: any) {
			 return ProjectApiFp.projectCreateChangeStreamPostProjectsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 projectDeleteById(params: { id: string }, options?: any) {
			 return ProjectApiFp.projectDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 projectExistsGetProjectsidExists(params: { id: string }, options?: any) {
			 return ProjectApiFp.projectExistsGetProjectsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 projectExistsHeadProjectsid(params: { id: string }, options?: any) {
			 return ProjectApiFp.projectExistsHeadProjectsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 projectFind(params: { filter?: string }, options?: any) {
			 return ProjectApiFp.projectFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 projectFindById(params: { id: string; filter?: string }, options?: any) {
			 return ProjectApiFp.projectFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 projectFindOne(params: { filter?: string }, options?: any) {
			 return ProjectApiFp.projectFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 projectPatchOrCreate(params: { data?: Project }, options?: any) {
			 return ProjectApiFp.projectPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts onwer of Project.
		  * @param id Project id
		  * @param where Criteria to match model instances
		  */
		 projectPrototypeCountOnwer(params: { id: string; where?: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeCountOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts playlists of Project.
		  * @param id Project id
		  * @param where Criteria to match model instances
		  */
		 projectPrototypeCountPlaylists(params: { id: string; where?: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeCountPlaylists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in onwer of this model.
		  * @param id Project id
		  * @param data
		  */
		 projectPrototypeCreateOnwer(params: { id: string; data?: Account }, options?: any) {
			 return ProjectApiFp.projectPrototypeCreateOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in playlists of this model.
		  * @param id Project id
		  * @param data
		  */
		 projectPrototypeCreatePlaylists(params: { id: string; data?: Playlist }, options?: any) {
			 return ProjectApiFp.projectPrototypeCreatePlaylists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all onwer of this model.
		  * @param id Project id
		  */
		 projectPrototypeDeleteOnwer(params: { id: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeDeleteOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all playlists of this model.
		  * @param id Project id
		  */
		 projectPrototypeDeletePlaylists(params: { id: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeDeletePlaylists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for onwer.
		  * @param id Project id
		  * @param fk Foreign key for onwer
		  */
		 projectPrototypeDestroyByIdOnwer(params: { id: string; fk: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeDestroyByIdOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for playlists.
		  * @param id Project id
		  * @param fk Foreign key for playlists
		  */
		 projectPrototypeDestroyByIdPlaylists(params: { id: string; fk: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeDestroyByIdPlaylists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of onwer relation to an item by id.
		  * @param id Project id
		  * @param fk Foreign key for onwer
		  */
		 projectPrototypeExistsOnwer(params: { id: string; fk: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeExistsOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for onwer.
		  * @param id Project id
		  * @param fk Foreign key for onwer
		  */
		 projectPrototypeFindByIdOnwer(params: { id: string; fk: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeFindByIdOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for playlists.
		  * @param id Project id
		  * @param fk Foreign key for playlists
		  */
		 projectPrototypeFindByIdPlaylists(params: { id: string; fk: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeFindByIdPlaylists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries onwer of Project.
		  * @param id Project id
		  * @param filter
		  */
		 projectPrototypeGetOnwer(params: { id: string; filter?: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeGetOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries playlists of Project.
		  * @param id Project id
		  * @param filter
		  */
		 projectPrototypeGetPlaylists(params: { id: string; filter?: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeGetPlaylists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for onwer.
		  * @param id Project id
		  * @param fk Foreign key for onwer
		  * @param data
		  */
		 projectPrototypeLinkOnwer(
			 params: { id: string; fk: string; data?: AccountProject },
			 options?: any
		 ) {
			 return ProjectApiFp.projectPrototypeLinkOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Project id
		  * @param data An object of model property name/value pairs
		  */
		 projectPrototypePatchAttributes(params: { id: string; data?: Project }, options?: any) {
			 return ProjectApiFp.projectPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the onwer relation to an item by id.
		  * @param id Project id
		  * @param fk Foreign key for onwer
		  */
		 projectPrototypeUnlinkOnwer(params: { id: string; fk: string }, options?: any) {
			 return ProjectApiFp.projectPrototypeUnlinkOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for onwer.
		  * @param id Project id
		  * @param fk Foreign key for onwer
		  * @param data
		  */
		 projectPrototypeUpdateByIdOnwer(
			 params: { id: string; fk: string; data?: Account },
			 options?: any
		 ) {
			 return ProjectApiFp.projectPrototypeUpdateByIdOnwer(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for playlists.
		  * @param id Project id
		  * @param fk Foreign key for playlists
		  * @param data
		  */
		 projectPrototypeUpdateByIdPlaylists(
			 params: { id: string; fk: string; data?: Playlist },
			 options?: any
		 ) {
			 return ProjectApiFp.projectPrototypeUpdateByIdPlaylists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 projectReplaceByIdPostProjectsidReplace(params: { id: string; data?: Project }, options?: any) {
			 return ProjectApiFp.projectReplaceByIdPostProjectsidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 projectReplaceByIdPutProjectsid(params: { id: string; data?: Project }, options?: any) {
			 return ProjectApiFp.projectReplaceByIdPutProjectsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 projectReplaceOrCreatePostProjectsReplaceOrCreate(params: { data?: Project }, options?: any) {
			 return ProjectApiFp.projectReplaceOrCreatePostProjectsReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 projectReplaceOrCreatePutProjects(params: { data?: Project }, options?: any) {
			 return ProjectApiFp.projectReplaceOrCreatePutProjects(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 projectUpdateAll(params: { where?: string; data?: Project }, options?: any) {
			 return ProjectApiFp.projectUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 projectUpsertWithWhere(params: { where?: string; data?: Project }, options?: any) {
			 return ProjectApiFp.projectUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * SubscriptionApi - fetch parameter creator
  */
 export const SubscriptionApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 subscriptionCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Subscriptions/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 subscriptionCreate(params: { data?: Subscription }, options?: any): FetchArgs {
		 const baseUrl = `/Subscriptions`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 subscriptionCreateChangeStreamGetSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Subscriptions/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 subscriptionCreateChangeStreamPostSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Subscriptions/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 subscriptionDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling subscriptionDeleteById');
		 }
		 const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 subscriptionExistsGetSubscriptionsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionExistsGetSubscriptionsidExists'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 subscriptionExistsHeadSubscriptionsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionExistsHeadSubscriptionsid'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 subscriptionFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Subscriptions`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 subscriptionFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling subscriptionFindById');
		 }
		 const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 subscriptionFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Subscriptions/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 subscriptionPatchOrCreate(params: { data?: Subscription }, options?: any): FetchArgs {
		 const baseUrl = `/Subscriptions`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts account of Subscription.
	  * @param id Subscription id
	  * @param where Criteria to match model instances
	  */
	 subscriptionPrototypeCountAccount(
		 params: { id: string; where?: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypeCountAccount'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/account/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in account of this model.
	  * @param id Subscription id
	  * @param data
	  */
	 subscriptionPrototypeCreateAccount(
		 params: { id: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypeCreateAccount'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all account of this model.
	  * @param id Subscription id
	  */
	 subscriptionPrototypeDeleteAccount(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypeDeleteAccount'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeDestroyByIdAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypeDestroyByIdAccount'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling subscriptionPrototypeDestroyByIdAccount'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/account/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of account relation to an item by id.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeExistsAccount(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypeExistsAccount'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling subscriptionPrototypeExistsAccount'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/account/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeFindByIdAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypeFindByIdAccount'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling subscriptionPrototypeFindByIdAccount'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/account/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries account of Subscription.
	  * @param id Subscription id
	  * @param filter
	  */
	 subscriptionPrototypeGetAccount(
		 params: { id: string; filter?: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling subscriptionPrototypeGetAccount');
		 }
		 const baseUrl = `/Subscriptions/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation creater.
	  * @param id Subscription id
	  * @param refresh
	  */
	 subscriptionPrototypeGetCreater(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling subscriptionPrototypeGetCreater');
		 }
		 const baseUrl = `/Subscriptions/{id}/creater`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  * @param data
	  */
	 subscriptionPrototypeLinkAccount(
		 params: { id: string; fk: string; data?: AccountSubscription },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypeLinkAccount'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling subscriptionPrototypeLinkAccount'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/account/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Subscription id
	  * @param data An object of model property name/value pairs
	  */
	 subscriptionPrototypePatchAttributes(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the account relation to an item by id.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeUnlinkAccount(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypeUnlinkAccount'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling subscriptionPrototypeUnlinkAccount'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/account/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  * @param data
	  */
	 subscriptionPrototypeUpdateByIdAccount(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionPrototypeUpdateByIdAccount'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling subscriptionPrototypeUpdateByIdAccount'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/account/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 subscriptionReplaceByIdPostSubscriptionsidReplace(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionReplaceByIdPostSubscriptionsidReplace'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 subscriptionReplaceByIdPutSubscriptionsid(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling subscriptionReplaceByIdPutSubscriptionsid'
			 );
		 }
		 const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(
		 params: { data?: Subscription },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Subscriptions/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 subscriptionReplaceOrCreatePutSubscriptions(
		 params: { data?: Subscription },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Subscriptions`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 subscriptionUpdateAll(params: { where?: string; data?: Subscription }, options?: any): FetchArgs {
		 const baseUrl = `/Subscriptions/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 subscriptionUpsertWithWhere(
		 params: { where?: string; data?: Subscription },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Subscriptions/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * SubscriptionApi - functional programming interface
  */
 export const SubscriptionApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 subscriptionCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 subscriptionCreate(
		 params: { data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 subscriptionCreateChangeStreamGetSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 SubscriptionApiFetchParamCreator.subscriptionCreateChangeStreamGetSubscriptionsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 subscriptionCreateChangeStreamPostSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 SubscriptionApiFetchParamCreator.subscriptionCreateChangeStreamPostSubscriptionsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 subscriptionDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 subscriptionExistsGetSubscriptionsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionExistsGetSubscriptionsidExists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 subscriptionExistsHeadSubscriptionsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionExistsHeadSubscriptionsid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 subscriptionFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Subscription>> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 subscriptionFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 subscriptionFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 subscriptionPatchOrCreate(
		 params: { data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts account of Subscription.
	  * @param id Subscription id
	  * @param where Criteria to match model instances
	  */
	 subscriptionPrototypeCountAccount(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeCountAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in account of this model.
	  * @param id Subscription id
	  * @param data
	  */
	 subscriptionPrototypeCreateAccount(
		 params: { id: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeCreateAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all account of this model.
	  * @param id Subscription id
	  */
	 subscriptionPrototypeDeleteAccount(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeDeleteAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeDestroyByIdAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeDestroyByIdAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of account relation to an item by id.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeExistsAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeExistsAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeFindByIdAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeFindByIdAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries account of Subscription.
	  * @param id Subscription id
	  * @param filter
	  */
	 subscriptionPrototypeGetAccount(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeGetAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation creater.
	  * @param id Subscription id
	  * @param refresh
	  */
	 subscriptionPrototypeGetCreater(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeGetCreater(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  * @param data
	  */
	 subscriptionPrototypeLinkAccount(
		 params: { id: string; fk: string; data?: AccountSubscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccountSubscription> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeLinkAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Subscription id
	  * @param data An object of model property name/value pairs
	  */
	 subscriptionPrototypePatchAttributes(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the account relation to an item by id.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeUnlinkAccount(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeUnlinkAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  * @param data
	  */
	 subscriptionPrototypeUpdateByIdAccount(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionPrototypeUpdateByIdAccount(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 subscriptionReplaceByIdPostSubscriptionsidReplace(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs =
			 SubscriptionApiFetchParamCreator.subscriptionReplaceByIdPostSubscriptionsidReplace(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 subscriptionReplaceByIdPutSubscriptionsid(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionReplaceByIdPutSubscriptionsid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(
		 params: { data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs =
			 SubscriptionApiFetchParamCreator.subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 subscriptionReplaceOrCreatePutSubscriptions(
		 params: { data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionReplaceOrCreatePutSubscriptions(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 subscriptionUpdateAll(
		 params: { where?: string; data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 subscriptionUpsertWithWhere(
		 params: { where?: string; data?: Subscription },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
		 const fetchArgs = SubscriptionApiFetchParamCreator.subscriptionUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * SubscriptionApi - object-oriented interface
  */
 export class SubscriptionApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 subscriptionCount(params: { where?: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 subscriptionCreate(params: { data?: Subscription }, options?: any) {
		 return SubscriptionApiFp.subscriptionCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 subscriptionCreateChangeStreamGetSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return SubscriptionApiFp.subscriptionCreateChangeStreamGetSubscriptionsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 subscriptionCreateChangeStreamPostSubscriptionsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return SubscriptionApiFp.subscriptionCreateChangeStreamPostSubscriptionsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 subscriptionDeleteById(params: { id: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 subscriptionExistsGetSubscriptionsidExists(params: { id: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionExistsGetSubscriptionsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 subscriptionExistsHeadSubscriptionsid(params: { id: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionExistsHeadSubscriptionsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 subscriptionFind(params: { filter?: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 subscriptionFindById(params: { id: string; filter?: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 subscriptionFindOne(params: { filter?: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 subscriptionPatchOrCreate(params: { data?: Subscription }, options?: any) {
		 return SubscriptionApiFp.subscriptionPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts account of Subscription.
	  * @param id Subscription id
	  * @param where Criteria to match model instances
	  */
	 subscriptionPrototypeCountAccount(params: { id: string; where?: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypeCountAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Creates a new instance in account of this model.
	  * @param id Subscription id
	  * @param data
	  */
	 subscriptionPrototypeCreateAccount(params: { id: string; data?: Account }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypeCreateAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Deletes all account of this model.
	  * @param id Subscription id
	  */
	 subscriptionPrototypeDeleteAccount(params: { id: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypeDeleteAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeDestroyByIdAccount(params: { id: string; fk: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypeDestroyByIdAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check the existence of account relation to an item by id.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeExistsAccount(params: { id: string; fk: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypeExistsAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeFindByIdAccount(params: { id: string; fk: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypeFindByIdAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Queries account of Subscription.
	  * @param id Subscription id
	  * @param filter
	  */
	 subscriptionPrototypeGetAccount(params: { id: string; filter?: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypeGetAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation creater.
	  * @param id Subscription id
	  * @param refresh
	  */
	 subscriptionPrototypeGetCreater(params: { id: string; refresh?: boolean }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypeGetCreater(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Add a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  * @param data
	  */
	 subscriptionPrototypeLinkAccount(
		 params: { id: string; fk: string; data?: AccountSubscription },
		 options?: any
	 ) {
		 return SubscriptionApiFp.subscriptionPrototypeLinkAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Subscription id
	  * @param data An object of model property name/value pairs
	  */
	 subscriptionPrototypePatchAttributes(params: { id: string; data?: Subscription }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Remove the account relation to an item by id.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  */
	 subscriptionPrototypeUnlinkAccount(params: { id: string; fk: string }, options?: any) {
		 return SubscriptionApiFp.subscriptionPrototypeUnlinkAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for account.
	  * @param id Subscription id
	  * @param fk Foreign key for account
	  * @param data
	  */
	 subscriptionPrototypeUpdateByIdAccount(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ) {
		 return SubscriptionApiFp.subscriptionPrototypeUpdateByIdAccount(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 subscriptionReplaceByIdPostSubscriptionsidReplace(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ) {
		 return SubscriptionApiFp.subscriptionReplaceByIdPostSubscriptionsidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 subscriptionReplaceByIdPutSubscriptionsid(
		 params: { id: string; data?: Subscription },
		 options?: any
	 ) {
		 return SubscriptionApiFp.subscriptionReplaceByIdPutSubscriptionsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(
		 params: { data?: Subscription },
		 options?: any
	 ) {
		 return SubscriptionApiFp.subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 subscriptionReplaceOrCreatePutSubscriptions(params: { data?: Subscription }, options?: any) {
		 return SubscriptionApiFp.subscriptionReplaceOrCreatePutSubscriptions(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 subscriptionUpdateAll(params: { where?: string; data?: Subscription }, options?: any) {
		 return SubscriptionApiFp.subscriptionUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 subscriptionUpsertWithWhere(params: { where?: string; data?: Subscription }, options?: any) {
		 return SubscriptionApiFp.subscriptionUpsertWithWhere(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
 }
 
 /**
  * SubscriptionApi - factory interface
  */
 export const SubscriptionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 subscriptionCount(params: { where?: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 subscriptionCreate(params: { data?: Subscription }, options?: any) {
			 return SubscriptionApiFp.subscriptionCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 subscriptionCreateChangeStreamGetSubscriptionsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return SubscriptionApiFp.subscriptionCreateChangeStreamGetSubscriptionsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 subscriptionCreateChangeStreamPostSubscriptionsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return SubscriptionApiFp.subscriptionCreateChangeStreamPostSubscriptionsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 subscriptionDeleteById(params: { id: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 subscriptionExistsGetSubscriptionsidExists(params: { id: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionExistsGetSubscriptionsidExists(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 subscriptionExistsHeadSubscriptionsid(params: { id: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionExistsHeadSubscriptionsid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 subscriptionFind(params: { filter?: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 subscriptionFindById(params: { id: string; filter?: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 subscriptionFindOne(params: { filter?: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 subscriptionPatchOrCreate(params: { data?: Subscription }, options?: any) {
			 return SubscriptionApiFp.subscriptionPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts account of Subscription.
		  * @param id Subscription id
		  * @param where Criteria to match model instances
		  */
		 subscriptionPrototypeCountAccount(params: { id: string; where?: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionPrototypeCountAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in account of this model.
		  * @param id Subscription id
		  * @param data
		  */
		 subscriptionPrototypeCreateAccount(params: { id: string; data?: Account }, options?: any) {
			 return SubscriptionApiFp.subscriptionPrototypeCreateAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all account of this model.
		  * @param id Subscription id
		  */
		 subscriptionPrototypeDeleteAccount(params: { id: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionPrototypeDeleteAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for account.
		  * @param id Subscription id
		  * @param fk Foreign key for account
		  */
		 subscriptionPrototypeDestroyByIdAccount(params: { id: string; fk: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionPrototypeDestroyByIdAccount(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check the existence of account relation to an item by id.
		  * @param id Subscription id
		  * @param fk Foreign key for account
		  */
		 subscriptionPrototypeExistsAccount(params: { id: string; fk: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionPrototypeExistsAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for account.
		  * @param id Subscription id
		  * @param fk Foreign key for account
		  */
		 subscriptionPrototypeFindByIdAccount(params: { id: string; fk: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionPrototypeFindByIdAccount(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Queries account of Subscription.
		  * @param id Subscription id
		  * @param filter
		  */
		 subscriptionPrototypeGetAccount(params: { id: string; filter?: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionPrototypeGetAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation creater.
		  * @param id Subscription id
		  * @param refresh
		  */
		 subscriptionPrototypeGetCreater(params: { id: string; refresh?: boolean }, options?: any) {
			 return SubscriptionApiFp.subscriptionPrototypeGetCreater(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for account.
		  * @param id Subscription id
		  * @param fk Foreign key for account
		  * @param data
		  */
		 subscriptionPrototypeLinkAccount(
			 params: { id: string; fk: string; data?: AccountSubscription },
			 options?: any
		 ) {
			 return SubscriptionApiFp.subscriptionPrototypeLinkAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Subscription id
		  * @param data An object of model property name/value pairs
		  */
		 subscriptionPrototypePatchAttributes(
			 params: { id: string; data?: Subscription },
			 options?: any
		 ) {
			 return SubscriptionApiFp.subscriptionPrototypePatchAttributes(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Remove the account relation to an item by id.
		  * @param id Subscription id
		  * @param fk Foreign key for account
		  */
		 subscriptionPrototypeUnlinkAccount(params: { id: string; fk: string }, options?: any) {
			 return SubscriptionApiFp.subscriptionPrototypeUnlinkAccount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for account.
		  * @param id Subscription id
		  * @param fk Foreign key for account
		  * @param data
		  */
		 subscriptionPrototypeUpdateByIdAccount(
			 params: { id: string; fk: string; data?: Account },
			 options?: any
		 ) {
			 return SubscriptionApiFp.subscriptionPrototypeUpdateByIdAccount(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 subscriptionReplaceByIdPostSubscriptionsidReplace(
			 params: { id: string; data?: Subscription },
			 options?: any
		 ) {
			 return SubscriptionApiFp.subscriptionReplaceByIdPostSubscriptionsidReplace(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 subscriptionReplaceByIdPutSubscriptionsid(
			 params: { id: string; data?: Subscription },
			 options?: any
		 ) {
			 return SubscriptionApiFp.subscriptionReplaceByIdPutSubscriptionsid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(
			 params: { data?: Subscription },
			 options?: any
		 ) {
			 return SubscriptionApiFp.subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 subscriptionReplaceOrCreatePutSubscriptions(params: { data?: Subscription }, options?: any) {
			 return SubscriptionApiFp.subscriptionReplaceOrCreatePutSubscriptions(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 subscriptionUpdateAll(params: { where?: string; data?: Subscription }, options?: any) {
			 return SubscriptionApiFp.subscriptionUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 subscriptionUpsertWithWhere(params: { where?: string; data?: Subscription }, options?: any) {
			 return SubscriptionApiFp.subscriptionUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * TagApi - fetch parameter creator
  */
 export const TagApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 tagCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Tags/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 tagCreate(params: { data?: Tag }, options?: any): FetchArgs {
		 const baseUrl = `/Tags`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 tagCreateChangeStreamGetTagsChangeStream(params: { options?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Tags/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 tagCreateChangeStreamPostTagsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Tags/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 tagDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling tagDeleteById');
		 }
		 const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 tagExistsGetTagsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling tagExistsGetTagsidExists');
		 }
		 const baseUrl = `/Tags/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 tagExistsHeadTagsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling tagExistsHeadTagsid');
		 }
		 const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 tagFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Tags`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 tagFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling tagFindById');
		 }
		 const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 tagFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Tags/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 tagPatchOrCreate(params: { data?: Tag }, options?: any): FetchArgs {
		 const baseUrl = `/Tags`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Tag id
	  * @param data An object of model property name/value pairs
	  */
	 tagPrototypePatchAttributes(params: { id: string; data?: Tag }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling tagPrototypePatchAttributes');
		 }
		 const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 tagReplaceByIdPostTagsidReplace(params: { id: string; data?: Tag }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling tagReplaceByIdPostTagsidReplace');
		 }
		 const baseUrl = `/Tags/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 tagReplaceByIdPutTagsid(params: { id: string; data?: Tag }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling tagReplaceByIdPutTagsid');
		 }
		 const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 tagReplaceOrCreatePostTagsReplaceOrCreate(params: { data?: Tag }, options?: any): FetchArgs {
		 const baseUrl = `/Tags/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 tagReplaceOrCreatePutTags(params: { data?: Tag }, options?: any): FetchArgs {
		 const baseUrl = `/Tags`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 tagUpdateAll(params: { where?: string; data?: Tag }, options?: any): FetchArgs {
		 const baseUrl = `/Tags/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 tagUpsertWithWhere(params: { where?: string; data?: Tag }, options?: any): FetchArgs {
		 const baseUrl = `/Tags/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * TagApi - functional programming interface
  */
 export const TagApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 tagCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TagApiFetchParamCreator.tagCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 tagCreate(
		 params: { data?: Tag },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 tagCreateChangeStreamGetTagsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TagApiFetchParamCreator.tagCreateChangeStreamGetTagsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 tagCreateChangeStreamPostTagsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TagApiFetchParamCreator.tagCreateChangeStreamPostTagsChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 tagDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TagApiFetchParamCreator.tagDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 tagExistsGetTagsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TagApiFetchParamCreator.tagExistsGetTagsidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 tagExistsHeadTagsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TagApiFetchParamCreator.tagExistsHeadTagsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 tagFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tag>> {
		 const fetchArgs = TagApiFetchParamCreator.tagFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 tagFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 tagFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 tagPatchOrCreate(
		 params: { data?: Tag },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Tag id
	  * @param data An object of model property name/value pairs
	  */
	 tagPrototypePatchAttributes(
		 params: { id: string; data?: Tag },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagPrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 tagReplaceByIdPostTagsidReplace(
		 params: { id: string; data?: Tag },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagReplaceByIdPostTagsidReplace(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 tagReplaceByIdPutTagsid(
		 params: { id: string; data?: Tag },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagReplaceByIdPutTagsid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 tagReplaceOrCreatePostTagsReplaceOrCreate(
		 params: { data?: Tag },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagReplaceOrCreatePostTagsReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 tagReplaceOrCreatePutTags(
		 params: { data?: Tag },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagReplaceOrCreatePutTags(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 tagUpdateAll(
		 params: { where?: string; data?: Tag },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = TagApiFetchParamCreator.tagUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 tagUpsertWithWhere(
		 params: { where?: string; data?: Tag },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
		 const fetchArgs = TagApiFetchParamCreator.tagUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * TagApi - object-oriented interface
  */
 export class TagApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 tagCount(params: { where?: string }, options?: any) {
		 return TagApiFp.tagCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 tagCreate(params: { data?: Tag }, options?: any) {
		 return TagApiFp.tagCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 tagCreateChangeStreamGetTagsChangeStream(params: { options?: string }, options?: any) {
		 return TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 tagCreateChangeStreamPostTagsChangeStream(params: { options?: string }, options?: any) {
		 return TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 tagDeleteById(params: { id: string }, options?: any) {
		 return TagApiFp.tagDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 tagExistsGetTagsidExists(params: { id: string }, options?: any) {
		 return TagApiFp.tagExistsGetTagsidExists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 tagExistsHeadTagsid(params: { id: string }, options?: any) {
		 return TagApiFp.tagExistsHeadTagsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 tagFind(params: { filter?: string }, options?: any) {
		 return TagApiFp.tagFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 tagFindById(params: { id: string; filter?: string }, options?: any) {
		 return TagApiFp.tagFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 tagFindOne(params: { filter?: string }, options?: any) {
		 return TagApiFp.tagFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 tagPatchOrCreate(params: { data?: Tag }, options?: any) {
		 return TagApiFp.tagPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Tag id
	  * @param data An object of model property name/value pairs
	  */
	 tagPrototypePatchAttributes(params: { id: string; data?: Tag }, options?: any) {
		 return TagApiFp.tagPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 tagReplaceByIdPostTagsidReplace(params: { id: string; data?: Tag }, options?: any) {
		 return TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 tagReplaceByIdPutTagsid(params: { id: string; data?: Tag }, options?: any) {
		 return TagApiFp.tagReplaceByIdPutTagsid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 tagReplaceOrCreatePostTagsReplaceOrCreate(params: { data?: Tag }, options?: any) {
		 return TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 tagReplaceOrCreatePutTags(params: { data?: Tag }, options?: any) {
		 return TagApiFp.tagReplaceOrCreatePutTags(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 tagUpdateAll(params: { where?: string; data?: Tag }, options?: any) {
		 return TagApiFp.tagUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 tagUpsertWithWhere(params: { where?: string; data?: Tag }, options?: any) {
		 return TagApiFp.tagUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * TagApi - factory interface
  */
 export const TagApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 tagCount(params: { where?: string }, options?: any) {
			 return TagApiFp.tagCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 tagCreate(params: { data?: Tag }, options?: any) {
			 return TagApiFp.tagCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 tagCreateChangeStreamGetTagsChangeStream(params: { options?: string }, options?: any) {
			 return TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 tagCreateChangeStreamPostTagsChangeStream(params: { options?: string }, options?: any) {
			 return TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 tagDeleteById(params: { id: string }, options?: any) {
			 return TagApiFp.tagDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 tagExistsGetTagsidExists(params: { id: string }, options?: any) {
			 return TagApiFp.tagExistsGetTagsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 tagExistsHeadTagsid(params: { id: string }, options?: any) {
			 return TagApiFp.tagExistsHeadTagsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 tagFind(params: { filter?: string }, options?: any) {
			 return TagApiFp.tagFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 tagFindById(params: { id: string; filter?: string }, options?: any) {
			 return TagApiFp.tagFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 tagFindOne(params: { filter?: string }, options?: any) {
			 return TagApiFp.tagFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 tagPatchOrCreate(params: { data?: Tag }, options?: any) {
			 return TagApiFp.tagPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Tag id
		  * @param data An object of model property name/value pairs
		  */
		 tagPrototypePatchAttributes(params: { id: string; data?: Tag }, options?: any) {
			 return TagApiFp.tagPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 tagReplaceByIdPostTagsidReplace(params: { id: string; data?: Tag }, options?: any) {
			 return TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 tagReplaceByIdPutTagsid(params: { id: string; data?: Tag }, options?: any) {
			 return TagApiFp.tagReplaceByIdPutTagsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 tagReplaceOrCreatePostTagsReplaceOrCreate(params: { data?: Tag }, options?: any) {
			 return TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 tagReplaceOrCreatePutTags(params: { data?: Tag }, options?: any) {
			 return TagApiFp.tagReplaceOrCreatePutTags(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 tagUpdateAll(params: { where?: string; data?: Tag }, options?: any) {
			 return TagApiFp.tagUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 tagUpsertWithWhere(params: { where?: string; data?: Tag }, options?: any) {
			 return TagApiFp.tagUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * TrackApi - fetch parameter creator
  */
 export const TrackApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Tracks/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackCreate(params: { data?: Track }, options?: any): FetchArgs {
		 const baseUrl = `/Tracks`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackCreateChangeStreamGetTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Tracks/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackCreateChangeStreamPostTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Tracks/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackDeleteById');
		 }
		 const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackExistsGetTracksidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackExistsGetTracksidExists');
		 }
		 const baseUrl = `/Tracks/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackExistsHeadTracksid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackExistsHeadTracksid');
		 }
		 const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Tracks`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackFindById');
		 }
		 const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Tracks/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackPatchOrCreate(params: { data?: Track }, options?: any): FetchArgs {
		 const baseUrl = `/Tracks`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts cart of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountCart(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCountCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts composers of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountComposers(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCountComposers');
		 }
		 const baseUrl = `/Tracks/{id}/composers/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts downloaders of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountDownloaders(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCountDownloaders');
		 }
		 const baseUrl = `/Tracks/{id}/downloaders/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts genres of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountGenres(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCountGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts moods of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountMoods(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCountMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts playlist of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountPlaylist(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCountPlaylist');
		 }
		 const baseUrl = `/Tracks/{id}/playlist/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in cart of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateCart(params: { id: string; data?: Cart }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCreateCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in composers of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateComposers(params: { id: string; data?: Account }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCreateComposers');
		 }
		 const baseUrl = `/Tracks/{id}/composers`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in downloaders of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateDownloaders(
		 params: { id: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCreateDownloaders');
		 }
		 const baseUrl = `/Tracks/{id}/downloaders`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in genres of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateGenres(params: { id: string; data?: Genre }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCreateGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in moods of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateMoods(params: { id: string; data?: Mood }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCreateMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in playlist of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreatePlaylist(params: { id: string; data?: Playlist }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeCreatePlaylist');
		 }
		 const baseUrl = `/Tracks/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all cart of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteCart(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeDeleteCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all composers of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteComposers(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeDeleteComposers');
		 }
		 const baseUrl = `/Tracks/{id}/composers`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all downloaders of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteDownloaders(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeDeleteDownloaders');
		 }
		 const baseUrl = `/Tracks/{id}/downloaders`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all genres of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteGenres(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeDeleteGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all moods of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteMoods(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeDeleteMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all playlist of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeletePlaylist(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeDeletePlaylist');
		 }
		 const baseUrl = `/Tracks/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeDestroyByIdCart(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeDestroyByIdCart');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeDestroyByIdCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeDestroyByIdComposers(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackPrototypeDestroyByIdComposers'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling trackPrototypeDestroyByIdComposers'
			 );
		 }
		 const baseUrl = `/Tracks/{id}/composers/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeDestroyByIdDownloaders(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackPrototypeDestroyByIdDownloaders'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling trackPrototypeDestroyByIdDownloaders'
			 );
		 }
		 const baseUrl = `/Tracks/{id}/downloaders/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeDestroyByIdGenres(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeDestroyByIdGenres');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeDestroyByIdGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeDestroyByIdMoods(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeDestroyByIdMoods');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeDestroyByIdMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeDestroyByIdPlaylist(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackPrototypeDestroyByIdPlaylist'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling trackPrototypeDestroyByIdPlaylist'
			 );
		 }
		 const baseUrl = `/Tracks/{id}/playlist/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of cart relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeExistsCart(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeExistsCart');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeExistsCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of composers relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeExistsComposers(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeExistsComposers');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeExistsComposers');
		 }
		 const baseUrl = `/Tracks/{id}/composers/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of downloaders relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeExistsDownloaders(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeExistsDownloaders');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeExistsDownloaders');
		 }
		 const baseUrl = `/Tracks/{id}/downloaders/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of genres relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeExistsGenres(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeExistsGenres');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeExistsGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of moods relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeExistsMoods(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeExistsMoods');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeExistsMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of playlist relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeExistsPlaylist(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeExistsPlaylist');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeExistsPlaylist');
		 }
		 const baseUrl = `/Tracks/{id}/playlist/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeFindByIdCart(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeFindByIdCart');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeFindByIdComposers(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeFindByIdComposers');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdComposers');
		 }
		 const baseUrl = `/Tracks/{id}/composers/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeFindByIdDownloaders(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackPrototypeFindByIdDownloaders'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling trackPrototypeFindByIdDownloaders'
			 );
		 }
		 const baseUrl = `/Tracks/{id}/downloaders/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeFindByIdGenres(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeFindByIdGenres');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeFindByIdMoods(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeFindByIdMoods');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeFindByIdPlaylist(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeFindByIdPlaylist');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdPlaylist');
		 }
		 const baseUrl = `/Tracks/{id}/playlist/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries cart of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetCart(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeGetCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries composers of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetComposers(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeGetComposers');
		 }
		 const baseUrl = `/Tracks/{id}/composers`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries downloaders of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetDownloaders(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeGetDownloaders');
		 }
		 const baseUrl = `/Tracks/{id}/downloaders`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries genres of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetGenres(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeGetGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries moods of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetMoods(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeGetMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries playlist of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetPlaylist(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeGetPlaylist');
		 }
		 const baseUrl = `/Tracks/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  * @param data
	  */
	 trackPrototypeLinkCart(
		 params: { id: string; fk: string; data?: TrackInCart },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeLinkCart');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeLinkCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  * @param data
	  */
	 trackPrototypeLinkComposers(
		 params: { id: string; fk: string; data?: ComposeTrack },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeLinkComposers');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeLinkComposers');
		 }
		 const baseUrl = `/Tracks/{id}/composers/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  * @param data
	  */
	 trackPrototypeLinkDownloaders(
		 params: { id: string; fk: string; data?: Download },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeLinkDownloaders');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeLinkDownloaders');
		 }
		 const baseUrl = `/Tracks/{id}/downloaders/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  * @param data
	  */
	 trackPrototypeLinkGenres(
		 params: { id: string; fk: string; data?: TrackGenre },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeLinkGenres');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeLinkGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  * @param data
	  */
	 trackPrototypeLinkMoods(
		 params: { id: string; fk: string; data?: TrackMood },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeLinkMoods');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeLinkMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 trackPrototypeLinkPlaylist(
		 params: { id: string; fk: string; data?: TrackInPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeLinkPlaylist');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeLinkPlaylist');
		 }
		 const baseUrl = `/Tracks/{id}/playlist/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Track id
	  * @param data An object of model property name/value pairs
	  */
	 trackPrototypePatchAttributes(params: { id: string; data?: Track }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypePatchAttributes');
		 }
		 const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the cart relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeUnlinkCart(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeUnlinkCart');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the composers relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeUnlinkComposers(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeUnlinkComposers');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkComposers');
		 }
		 const baseUrl = `/Tracks/{id}/composers/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the downloaders relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeUnlinkDownloaders(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeUnlinkDownloaders');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkDownloaders');
		 }
		 const baseUrl = `/Tracks/{id}/downloaders/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the genres relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeUnlinkGenres(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeUnlinkGenres');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the moods relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeUnlinkMoods(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeUnlinkMoods');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Remove the playlist relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeUnlinkPlaylist(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeUnlinkPlaylist');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkPlaylist');
		 }
		 const baseUrl = `/Tracks/{id}/playlist/rel/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  * @param data
	  */
	 trackPrototypeUpdateByIdCart(
		 params: { id: string; fk: string; data?: Cart },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeUpdateByIdCart');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeUpdateByIdCart');
		 }
		 const baseUrl = `/Tracks/{id}/cart/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  * @param data
	  */
	 trackPrototypeUpdateByIdComposers(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackPrototypeUpdateByIdComposers'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling trackPrototypeUpdateByIdComposers'
			 );
		 }
		 const baseUrl = `/Tracks/{id}/composers/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  * @param data
	  */
	 trackPrototypeUpdateByIdDownloaders(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackPrototypeUpdateByIdDownloaders'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling trackPrototypeUpdateByIdDownloaders'
			 );
		 }
		 const baseUrl = `/Tracks/{id}/downloaders/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  * @param data
	  */
	 trackPrototypeUpdateByIdGenres(
		 params: { id: string; fk: string; data?: Genre },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeUpdateByIdGenres');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeUpdateByIdGenres');
		 }
		 const baseUrl = `/Tracks/{id}/genres/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  * @param data
	  */
	 trackPrototypeUpdateByIdMoods(
		 params: { id: string; fk: string; data?: Mood },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackPrototypeUpdateByIdMoods');
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error('Missing required parameter fk when calling trackPrototypeUpdateByIdMoods');
		 }
		 const baseUrl = `/Tracks/{id}/moods/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 trackPrototypeUpdateByIdPlaylist(
		 params: { id: string; fk: string; data?: Playlist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackPrototypeUpdateByIdPlaylist'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling trackPrototypeUpdateByIdPlaylist'
			 );
		 }
		 const baseUrl = `/Tracks/{id}/playlist/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackReplaceByIdPostTracksidReplace(
		 params: { id: string; data?: Track },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackReplaceByIdPostTracksidReplace'
			 );
		 }
		 const baseUrl = `/Tracks/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackReplaceByIdPutTracksid(params: { id: string; data?: Track }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackReplaceByIdPutTracksid');
		 }
		 const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackReplaceOrCreatePostTracksReplaceOrCreate(
		 params: { data?: Track },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Tracks/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackReplaceOrCreatePutTracks(params: { data?: Track }, options?: any): FetchArgs {
		 const baseUrl = `/Tracks`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackUpdateAll(params: { where?: string; data?: Track }, options?: any): FetchArgs {
		 const baseUrl = `/Tracks/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackUpsertWithWhere(params: { where?: string; data?: Track }, options?: any): FetchArgs {
		 const baseUrl = `/Tracks/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * TrackApi - functional programming interface
  */
 export const TrackApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackApiFetchParamCreator.trackCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackCreate(
		 params: { data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackCreateChangeStreamGetTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackCreateChangeStreamGetTracksChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackCreateChangeStreamPostTracksChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackCreateChangeStreamPostTracksChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackExistsGetTracksidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TrackApiFetchParamCreator.trackExistsGetTracksidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackExistsHeadTracksid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TrackApiFetchParamCreator.trackExistsHeadTracksid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
		 const fetchArgs = TrackApiFetchParamCreator.trackFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackPatchOrCreate(
		 params: { data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts cart of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountCart(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCountCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts composers of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountComposers(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCountComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts downloaders of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountDownloaders(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCountDownloaders(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts genres of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountGenres(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCountGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts moods of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountMoods(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCountMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts playlist of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountPlaylist(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCountPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in cart of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateCart(
		 params: { id: string; data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCreateCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in composers of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateComposers(
		 params: { id: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCreateComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in downloaders of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateDownloaders(
		 params: { id: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCreateDownloaders(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in genres of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateGenres(
		 params: { id: string; data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCreateGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in moods of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateMoods(
		 params: { id: string; data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCreateMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in playlist of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreatePlaylist(
		 params: { id: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeCreatePlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all cart of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteCart(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDeleteCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all composers of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteComposers(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDeleteComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all downloaders of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteDownloaders(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDeleteDownloaders(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all genres of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteGenres(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDeleteGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all moods of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteMoods(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDeleteMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all playlist of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeletePlaylist(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDeletePlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeDestroyByIdCart(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDestroyByIdCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeDestroyByIdComposers(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDestroyByIdComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeDestroyByIdDownloaders(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDestroyByIdDownloaders(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeDestroyByIdGenres(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDestroyByIdGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeDestroyByIdMoods(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDestroyByIdMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeDestroyByIdPlaylist(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeDestroyByIdPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of cart relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeExistsCart(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeExistsCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of composers relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeExistsComposers(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeExistsComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of downloaders relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeExistsDownloaders(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeExistsDownloaders(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of genres relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeExistsGenres(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeExistsGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of moods relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeExistsMoods(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeExistsMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check the existence of playlist relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeExistsPlaylist(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeExistsPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeFindByIdCart(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeFindByIdCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeFindByIdComposers(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeFindByIdComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeFindByIdDownloaders(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeFindByIdDownloaders(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeFindByIdGenres(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeFindByIdGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeFindByIdMoods(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeFindByIdMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeFindByIdPlaylist(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeFindByIdPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries cart of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetCart(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Cart>> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeGetCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries composers of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetComposers(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeGetComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries downloaders of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetDownloaders(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeGetDownloaders(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries genres of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetGenres(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Genre>> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeGetGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries moods of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetMoods(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Mood>> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeGetMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries playlist of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetPlaylist(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Playlist>> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeGetPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  * @param data
	  */
	 trackPrototypeLinkCart(
		 params: { id: string; fk: string; data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeLinkCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  * @param data
	  */
	 trackPrototypeLinkComposers(
		 params: { id: string; fk: string; data?: ComposeTrack },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeTrack> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeLinkComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  * @param data
	  */
	 trackPrototypeLinkDownloaders(
		 params: { id: string; fk: string; data?: Download },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Download> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeLinkDownloaders(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  * @param data
	  */
	 trackPrototypeLinkGenres(
		 params: { id: string; fk: string; data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeLinkGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  * @param data
	  */
	 trackPrototypeLinkMoods(
		 params: { id: string; fk: string; data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeLinkMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Add a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 trackPrototypeLinkPlaylist(
		 params: { id: string; fk: string; data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeLinkPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Track id
	  * @param data An object of model property name/value pairs
	  */
	 trackPrototypePatchAttributes(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the cart relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeUnlinkCart(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUnlinkCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the composers relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeUnlinkComposers(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUnlinkComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the downloaders relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeUnlinkDownloaders(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUnlinkDownloaders(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the genres relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeUnlinkGenres(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUnlinkGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the moods relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeUnlinkMoods(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUnlinkMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Remove the playlist relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeUnlinkPlaylist(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUnlinkPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  * @param data
	  */
	 trackPrototypeUpdateByIdCart(
		 params: { id: string; fk: string; data?: Cart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUpdateByIdCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  * @param data
	  */
	 trackPrototypeUpdateByIdComposers(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUpdateByIdComposers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  * @param data
	  */
	 trackPrototypeUpdateByIdDownloaders(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUpdateByIdDownloaders(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  * @param data
	  */
	 trackPrototypeUpdateByIdGenres(
		 params: { id: string; fk: string; data?: Genre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUpdateByIdGenres(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  * @param data
	  */
	 trackPrototypeUpdateByIdMoods(
		 params: { id: string; fk: string; data?: Mood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUpdateByIdMoods(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 trackPrototypeUpdateByIdPlaylist(
		 params: { id: string; fk: string; data?: Playlist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = TrackApiFetchParamCreator.trackPrototypeUpdateByIdPlaylist(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackReplaceByIdPostTracksidReplace(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackReplaceByIdPostTracksidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackReplaceByIdPutTracksid(
		 params: { id: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackReplaceByIdPutTracksid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackReplaceOrCreatePostTracksReplaceOrCreate(
		 params: { data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackReplaceOrCreatePostTracksReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackReplaceOrCreatePutTracks(
		 params: { data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackReplaceOrCreatePutTracks(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackUpdateAll(
		 params: { where?: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = TrackApiFetchParamCreator.trackUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackUpsertWithWhere(
		 params: { where?: string; data?: Track },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackApiFetchParamCreator.trackUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * TrackApi - object-oriented interface
  */
 export class TrackApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackCount(params: { where?: string }, options?: any) {
		 return TrackApiFp.trackCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackCreate(params: { data?: Track }, options?: any) {
		 return TrackApiFp.trackCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackCreateChangeStreamGetTracksChangeStream(params: { options?: string }, options?: any) {
		 return TrackApiFp.trackCreateChangeStreamGetTracksChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackCreateChangeStreamPostTracksChangeStream(params: { options?: string }, options?: any) {
		 return TrackApiFp.trackCreateChangeStreamPostTracksChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackDeleteById(params: { id: string }, options?: any) {
		 return TrackApiFp.trackDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackExistsGetTracksidExists(params: { id: string }, options?: any) {
		 return TrackApiFp.trackExistsGetTracksidExists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackExistsHeadTracksid(params: { id: string }, options?: any) {
		 return TrackApiFp.trackExistsHeadTracksid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackFind(params: { filter?: string }, options?: any) {
		 return TrackApiFp.trackFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackFindById(params: { id: string; filter?: string }, options?: any) {
		 return TrackApiFp.trackFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackFindOne(params: { filter?: string }, options?: any) {
		 return TrackApiFp.trackFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackPatchOrCreate(params: { data?: Track }, options?: any) {
		 return TrackApiFp.trackPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts cart of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountCart(params: { id: string; where?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeCountCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts composers of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountComposers(params: { id: string; where?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeCountComposers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts downloaders of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountDownloaders(params: { id: string; where?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeCountDownloaders(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts genres of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountGenres(params: { id: string; where?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeCountGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts moods of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountMoods(params: { id: string; where?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeCountMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts playlist of Track.
	  * @param id Track id
	  * @param where Criteria to match model instances
	  */
	 trackPrototypeCountPlaylist(params: { id: string; where?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeCountPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in cart of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateCart(params: { id: string; data?: Cart }, options?: any) {
		 return TrackApiFp.trackPrototypeCreateCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in composers of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateComposers(params: { id: string; data?: Account }, options?: any) {
		 return TrackApiFp.trackPrototypeCreateComposers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in downloaders of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateDownloaders(params: { id: string; data?: Account }, options?: any) {
		 return TrackApiFp.trackPrototypeCreateDownloaders(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in genres of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateGenres(params: { id: string; data?: Genre }, options?: any) {
		 return TrackApiFp.trackPrototypeCreateGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in moods of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreateMoods(params: { id: string; data?: Mood }, options?: any) {
		 return TrackApiFp.trackPrototypeCreateMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in playlist of this model.
	  * @param id Track id
	  * @param data
	  */
	 trackPrototypeCreatePlaylist(params: { id: string; data?: Playlist }, options?: any) {
		 return TrackApiFp.trackPrototypeCreatePlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all cart of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteCart(params: { id: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDeleteCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all composers of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteComposers(params: { id: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDeleteComposers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all downloaders of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteDownloaders(params: { id: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDeleteDownloaders(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all genres of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteGenres(params: { id: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDeleteGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all moods of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeleteMoods(params: { id: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDeleteMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all playlist of this model.
	  * @param id Track id
	  */
	 trackPrototypeDeletePlaylist(params: { id: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDeletePlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeDestroyByIdCart(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDestroyByIdCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeDestroyByIdComposers(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDestroyByIdComposers(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeDestroyByIdDownloaders(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDestroyByIdDownloaders(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeDestroyByIdGenres(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDestroyByIdGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeDestroyByIdMoods(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDestroyByIdMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeDestroyByIdPlaylist(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeDestroyByIdPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of cart relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeExistsCart(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeExistsCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of composers relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeExistsComposers(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeExistsComposers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of downloaders relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeExistsDownloaders(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeExistsDownloaders(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of genres relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeExistsGenres(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeExistsGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of moods relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeExistsMoods(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeExistsMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check the existence of playlist relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeExistsPlaylist(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeExistsPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeFindByIdCart(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeFindByIdCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeFindByIdComposers(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeFindByIdComposers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeFindByIdDownloaders(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeFindByIdDownloaders(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeFindByIdGenres(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeFindByIdGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeFindByIdMoods(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeFindByIdMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeFindByIdPlaylist(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeFindByIdPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries cart of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetCart(params: { id: string; filter?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeGetCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries composers of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetComposers(params: { id: string; filter?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeGetComposers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries downloaders of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetDownloaders(params: { id: string; filter?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeGetDownloaders(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries genres of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetGenres(params: { id: string; filter?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeGetGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries moods of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetMoods(params: { id: string; filter?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeGetMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries playlist of Track.
	  * @param id Track id
	  * @param filter
	  */
	 trackPrototypeGetPlaylist(params: { id: string; filter?: string }, options?: any) {
		 return TrackApiFp.trackPrototypeGetPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  * @param data
	  */
	 trackPrototypeLinkCart(params: { id: string; fk: string; data?: TrackInCart }, options?: any) {
		 return TrackApiFp.trackPrototypeLinkCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  * @param data
	  */
	 trackPrototypeLinkComposers(
		 params: { id: string; fk: string; data?: ComposeTrack },
		 options?: any
	 ) {
		 return TrackApiFp.trackPrototypeLinkComposers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  * @param data
	  */
	 trackPrototypeLinkDownloaders(
		 params: { id: string; fk: string; data?: Download },
		 options?: any
	 ) {
		 return TrackApiFp.trackPrototypeLinkDownloaders(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  * @param data
	  */
	 trackPrototypeLinkGenres(params: { id: string; fk: string; data?: TrackGenre }, options?: any) {
		 return TrackApiFp.trackPrototypeLinkGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  * @param data
	  */
	 trackPrototypeLinkMoods(params: { id: string; fk: string; data?: TrackMood }, options?: any) {
		 return TrackApiFp.trackPrototypeLinkMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Add a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 trackPrototypeLinkPlaylist(
		 params: { id: string; fk: string; data?: TrackInPlaylist },
		 options?: any
	 ) {
		 return TrackApiFp.trackPrototypeLinkPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id Track id
	  * @param data An object of model property name/value pairs
	  */
	 trackPrototypePatchAttributes(params: { id: string; data?: Track }, options?: any) {
		 return TrackApiFp.trackPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the cart relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  */
	 trackPrototypeUnlinkCart(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeUnlinkCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the composers relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  */
	 trackPrototypeUnlinkComposers(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeUnlinkComposers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the downloaders relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  */
	 trackPrototypeUnlinkDownloaders(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeUnlinkDownloaders(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the genres relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  */
	 trackPrototypeUnlinkGenres(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeUnlinkGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the moods relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  */
	 trackPrototypeUnlinkMoods(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeUnlinkMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Remove the playlist relation to an item by id.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  */
	 trackPrototypeUnlinkPlaylist(params: { id: string; fk: string }, options?: any) {
		 return TrackApiFp.trackPrototypeUnlinkPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for cart.
	  * @param id Track id
	  * @param fk Foreign key for cart
	  * @param data
	  */
	 trackPrototypeUpdateByIdCart(params: { id: string; fk: string; data?: Cart }, options?: any) {
		 return TrackApiFp.trackPrototypeUpdateByIdCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for composers.
	  * @param id Track id
	  * @param fk Foreign key for composers
	  * @param data
	  */
	 trackPrototypeUpdateByIdComposers(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ) {
		 return TrackApiFp.trackPrototypeUpdateByIdComposers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for downloaders.
	  * @param id Track id
	  * @param fk Foreign key for downloaders
	  * @param data
	  */
	 trackPrototypeUpdateByIdDownloaders(
		 params: { id: string; fk: string; data?: Account },
		 options?: any
	 ) {
		 return TrackApiFp.trackPrototypeUpdateByIdDownloaders(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update a related item by id for genres.
	  * @param id Track id
	  * @param fk Foreign key for genres
	  * @param data
	  */
	 trackPrototypeUpdateByIdGenres(params: { id: string; fk: string; data?: Genre }, options?: any) {
		 return TrackApiFp.trackPrototypeUpdateByIdGenres(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for moods.
	  * @param id Track id
	  * @param fk Foreign key for moods
	  * @param data
	  */
	 trackPrototypeUpdateByIdMoods(params: { id: string; fk: string; data?: Mood }, options?: any) {
		 return TrackApiFp.trackPrototypeUpdateByIdMoods(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for playlist.
	  * @param id Track id
	  * @param fk Foreign key for playlist
	  * @param data
	  */
	 trackPrototypeUpdateByIdPlaylist(
		 params: { id: string; fk: string; data?: Playlist },
		 options?: any
	 ) {
		 return TrackApiFp.trackPrototypeUpdateByIdPlaylist(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackReplaceByIdPostTracksidReplace(params: { id: string; data?: Track }, options?: any) {
		 return TrackApiFp.trackReplaceByIdPostTracksidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackReplaceByIdPutTracksid(params: { id: string; data?: Track }, options?: any) {
		 return TrackApiFp.trackReplaceByIdPutTracksid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackReplaceOrCreatePostTracksReplaceOrCreate(params: { data?: Track }, options?: any) {
		 return TrackApiFp.trackReplaceOrCreatePostTracksReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackReplaceOrCreatePutTracks(params: { data?: Track }, options?: any) {
		 return TrackApiFp.trackReplaceOrCreatePutTracks(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackUpdateAll(params: { where?: string; data?: Track }, options?: any) {
		 return TrackApiFp.trackUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackUpsertWithWhere(params: { where?: string; data?: Track }, options?: any) {
		 return TrackApiFp.trackUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * TrackApi - factory interface
  */
 export const TrackApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 trackCount(params: { where?: string }, options?: any) {
			 return TrackApiFp.trackCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 trackCreate(params: { data?: Track }, options?: any) {
			 return TrackApiFp.trackCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackCreateChangeStreamGetTracksChangeStream(params: { options?: string }, options?: any) {
			 return TrackApiFp.trackCreateChangeStreamGetTracksChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackCreateChangeStreamPostTracksChangeStream(params: { options?: string }, options?: any) {
			 return TrackApiFp.trackCreateChangeStreamPostTracksChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 trackDeleteById(params: { id: string }, options?: any) {
			 return TrackApiFp.trackDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackExistsGetTracksidExists(params: { id: string }, options?: any) {
			 return TrackApiFp.trackExistsGetTracksidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackExistsHeadTracksid(params: { id: string }, options?: any) {
			 return TrackApiFp.trackExistsHeadTracksid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackFind(params: { filter?: string }, options?: any) {
			 return TrackApiFp.trackFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 trackFindById(params: { id: string; filter?: string }, options?: any) {
			 return TrackApiFp.trackFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackFindOne(params: { filter?: string }, options?: any) {
			 return TrackApiFp.trackFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackPatchOrCreate(params: { data?: Track }, options?: any) {
			 return TrackApiFp.trackPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts cart of Track.
		  * @param id Track id
		  * @param where Criteria to match model instances
		  */
		 trackPrototypeCountCart(params: { id: string; where?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeCountCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts composers of Track.
		  * @param id Track id
		  * @param where Criteria to match model instances
		  */
		 trackPrototypeCountComposers(params: { id: string; where?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeCountComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts downloaders of Track.
		  * @param id Track id
		  * @param where Criteria to match model instances
		  */
		 trackPrototypeCountDownloaders(params: { id: string; where?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeCountDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts genres of Track.
		  * @param id Track id
		  * @param where Criteria to match model instances
		  */
		 trackPrototypeCountGenres(params: { id: string; where?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeCountGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts moods of Track.
		  * @param id Track id
		  * @param where Criteria to match model instances
		  */
		 trackPrototypeCountMoods(params: { id: string; where?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeCountMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts playlist of Track.
		  * @param id Track id
		  * @param where Criteria to match model instances
		  */
		 trackPrototypeCountPlaylist(params: { id: string; where?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeCountPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in cart of this model.
		  * @param id Track id
		  * @param data
		  */
		 trackPrototypeCreateCart(params: { id: string; data?: Cart }, options?: any) {
			 return TrackApiFp.trackPrototypeCreateCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in composers of this model.
		  * @param id Track id
		  * @param data
		  */
		 trackPrototypeCreateComposers(params: { id: string; data?: Account }, options?: any) {
			 return TrackApiFp.trackPrototypeCreateComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in downloaders of this model.
		  * @param id Track id
		  * @param data
		  */
		 trackPrototypeCreateDownloaders(params: { id: string; data?: Account }, options?: any) {
			 return TrackApiFp.trackPrototypeCreateDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in genres of this model.
		  * @param id Track id
		  * @param data
		  */
		 trackPrototypeCreateGenres(params: { id: string; data?: Genre }, options?: any) {
			 return TrackApiFp.trackPrototypeCreateGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in moods of this model.
		  * @param id Track id
		  * @param data
		  */
		 trackPrototypeCreateMoods(params: { id: string; data?: Mood }, options?: any) {
			 return TrackApiFp.trackPrototypeCreateMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in playlist of this model.
		  * @param id Track id
		  * @param data
		  */
		 trackPrototypeCreatePlaylist(params: { id: string; data?: Playlist }, options?: any) {
			 return TrackApiFp.trackPrototypeCreatePlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all cart of this model.
		  * @param id Track id
		  */
		 trackPrototypeDeleteCart(params: { id: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDeleteCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all composers of this model.
		  * @param id Track id
		  */
		 trackPrototypeDeleteComposers(params: { id: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDeleteComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all downloaders of this model.
		  * @param id Track id
		  */
		 trackPrototypeDeleteDownloaders(params: { id: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDeleteDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all genres of this model.
		  * @param id Track id
		  */
		 trackPrototypeDeleteGenres(params: { id: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDeleteGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all moods of this model.
		  * @param id Track id
		  */
		 trackPrototypeDeleteMoods(params: { id: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDeleteMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all playlist of this model.
		  * @param id Track id
		  */
		 trackPrototypeDeletePlaylist(params: { id: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDeletePlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for cart.
		  * @param id Track id
		  * @param fk Foreign key for cart
		  */
		 trackPrototypeDestroyByIdCart(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDestroyByIdCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for composers.
		  * @param id Track id
		  * @param fk Foreign key for composers
		  */
		 trackPrototypeDestroyByIdComposers(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDestroyByIdComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for downloaders.
		  * @param id Track id
		  * @param fk Foreign key for downloaders
		  */
		 trackPrototypeDestroyByIdDownloaders(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDestroyByIdDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for genres.
		  * @param id Track id
		  * @param fk Foreign key for genres
		  */
		 trackPrototypeDestroyByIdGenres(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDestroyByIdGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for moods.
		  * @param id Track id
		  * @param fk Foreign key for moods
		  */
		 trackPrototypeDestroyByIdMoods(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDestroyByIdMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for playlist.
		  * @param id Track id
		  * @param fk Foreign key for playlist
		  */
		 trackPrototypeDestroyByIdPlaylist(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeDestroyByIdPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of cart relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for cart
		  */
		 trackPrototypeExistsCart(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeExistsCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of composers relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for composers
		  */
		 trackPrototypeExistsComposers(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeExistsComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of downloaders relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for downloaders
		  */
		 trackPrototypeExistsDownloaders(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeExistsDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of genres relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for genres
		  */
		 trackPrototypeExistsGenres(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeExistsGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of moods relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for moods
		  */
		 trackPrototypeExistsMoods(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeExistsMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check the existence of playlist relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for playlist
		  */
		 trackPrototypeExistsPlaylist(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeExistsPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for cart.
		  * @param id Track id
		  * @param fk Foreign key for cart
		  */
		 trackPrototypeFindByIdCart(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeFindByIdCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for composers.
		  * @param id Track id
		  * @param fk Foreign key for composers
		  */
		 trackPrototypeFindByIdComposers(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeFindByIdComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for downloaders.
		  * @param id Track id
		  * @param fk Foreign key for downloaders
		  */
		 trackPrototypeFindByIdDownloaders(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeFindByIdDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for genres.
		  * @param id Track id
		  * @param fk Foreign key for genres
		  */
		 trackPrototypeFindByIdGenres(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeFindByIdGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for moods.
		  * @param id Track id
		  * @param fk Foreign key for moods
		  */
		 trackPrototypeFindByIdMoods(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeFindByIdMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for playlist.
		  * @param id Track id
		  * @param fk Foreign key for playlist
		  */
		 trackPrototypeFindByIdPlaylist(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeFindByIdPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries cart of Track.
		  * @param id Track id
		  * @param filter
		  */
		 trackPrototypeGetCart(params: { id: string; filter?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeGetCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries composers of Track.
		  * @param id Track id
		  * @param filter
		  */
		 trackPrototypeGetComposers(params: { id: string; filter?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeGetComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries downloaders of Track.
		  * @param id Track id
		  * @param filter
		  */
		 trackPrototypeGetDownloaders(params: { id: string; filter?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeGetDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries genres of Track.
		  * @param id Track id
		  * @param filter
		  */
		 trackPrototypeGetGenres(params: { id: string; filter?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeGetGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries moods of Track.
		  * @param id Track id
		  * @param filter
		  */
		 trackPrototypeGetMoods(params: { id: string; filter?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeGetMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries playlist of Track.
		  * @param id Track id
		  * @param filter
		  */
		 trackPrototypeGetPlaylist(params: { id: string; filter?: string }, options?: any) {
			 return TrackApiFp.trackPrototypeGetPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for cart.
		  * @param id Track id
		  * @param fk Foreign key for cart
		  * @param data
		  */
		 trackPrototypeLinkCart(params: { id: string; fk: string; data?: TrackInCart }, options?: any) {
			 return TrackApiFp.trackPrototypeLinkCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for composers.
		  * @param id Track id
		  * @param fk Foreign key for composers
		  * @param data
		  */
		 trackPrototypeLinkComposers(
			 params: { id: string; fk: string; data?: ComposeTrack },
			 options?: any
		 ) {
			 return TrackApiFp.trackPrototypeLinkComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for downloaders.
		  * @param id Track id
		  * @param fk Foreign key for downloaders
		  * @param data
		  */
		 trackPrototypeLinkDownloaders(
			 params: { id: string; fk: string; data?: Download },
			 options?: any
		 ) {
			 return TrackApiFp.trackPrototypeLinkDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for genres.
		  * @param id Track id
		  * @param fk Foreign key for genres
		  * @param data
		  */
		 trackPrototypeLinkGenres(params: { id: string; fk: string; data?: TrackGenre }, options?: any) {
			 return TrackApiFp.trackPrototypeLinkGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for moods.
		  * @param id Track id
		  * @param fk Foreign key for moods
		  * @param data
		  */
		 trackPrototypeLinkMoods(params: { id: string; fk: string; data?: TrackMood }, options?: any) {
			 return TrackApiFp.trackPrototypeLinkMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Add a related item by id for playlist.
		  * @param id Track id
		  * @param fk Foreign key for playlist
		  * @param data
		  */
		 trackPrototypeLinkPlaylist(
			 params: { id: string; fk: string; data?: TrackInPlaylist },
			 options?: any
		 ) {
			 return TrackApiFp.trackPrototypeLinkPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id Track id
		  * @param data An object of model property name/value pairs
		  */
		 trackPrototypePatchAttributes(params: { id: string; data?: Track }, options?: any) {
			 return TrackApiFp.trackPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the cart relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for cart
		  */
		 trackPrototypeUnlinkCart(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeUnlinkCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the composers relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for composers
		  */
		 trackPrototypeUnlinkComposers(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeUnlinkComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the downloaders relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for downloaders
		  */
		 trackPrototypeUnlinkDownloaders(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeUnlinkDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the genres relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for genres
		  */
		 trackPrototypeUnlinkGenres(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeUnlinkGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the moods relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for moods
		  */
		 trackPrototypeUnlinkMoods(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeUnlinkMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Remove the playlist relation to an item by id.
		  * @param id Track id
		  * @param fk Foreign key for playlist
		  */
		 trackPrototypeUnlinkPlaylist(params: { id: string; fk: string }, options?: any) {
			 return TrackApiFp.trackPrototypeUnlinkPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for cart.
		  * @param id Track id
		  * @param fk Foreign key for cart
		  * @param data
		  */
		 trackPrototypeUpdateByIdCart(params: { id: string; fk: string; data?: Cart }, options?: any) {
			 return TrackApiFp.trackPrototypeUpdateByIdCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for composers.
		  * @param id Track id
		  * @param fk Foreign key for composers
		  * @param data
		  */
		 trackPrototypeUpdateByIdComposers(
			 params: { id: string; fk: string; data?: Account },
			 options?: any
		 ) {
			 return TrackApiFp.trackPrototypeUpdateByIdComposers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for downloaders.
		  * @param id Track id
		  * @param fk Foreign key for downloaders
		  * @param data
		  */
		 trackPrototypeUpdateByIdDownloaders(
			 params: { id: string; fk: string; data?: Account },
			 options?: any
		 ) {
			 return TrackApiFp.trackPrototypeUpdateByIdDownloaders(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for genres.
		  * @param id Track id
		  * @param fk Foreign key for genres
		  * @param data
		  */
		 trackPrototypeUpdateByIdGenres(
			 params: { id: string; fk: string; data?: Genre },
			 options?: any
		 ) {
			 return TrackApiFp.trackPrototypeUpdateByIdGenres(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for moods.
		  * @param id Track id
		  * @param fk Foreign key for moods
		  * @param data
		  */
		 trackPrototypeUpdateByIdMoods(params: { id: string; fk: string; data?: Mood }, options?: any) {
			 return TrackApiFp.trackPrototypeUpdateByIdMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for playlist.
		  * @param id Track id
		  * @param fk Foreign key for playlist
		  * @param data
		  */
		 trackPrototypeUpdateByIdPlaylist(
			 params: { id: string; fk: string; data?: Playlist },
			 options?: any
		 ) {
			 return TrackApiFp.trackPrototypeUpdateByIdPlaylist(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackReplaceByIdPostTracksidReplace(params: { id: string; data?: Track }, options?: any) {
			 return TrackApiFp.trackReplaceByIdPostTracksidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackReplaceByIdPutTracksid(params: { id: string; data?: Track }, options?: any) {
			 return TrackApiFp.trackReplaceByIdPutTracksid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackReplaceOrCreatePostTracksReplaceOrCreate(params: { data?: Track }, options?: any) {
			 return TrackApiFp.trackReplaceOrCreatePostTracksReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackReplaceOrCreatePutTracks(params: { data?: Track }, options?: any) {
			 return TrackApiFp.trackReplaceOrCreatePutTracks(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackUpdateAll(params: { where?: string; data?: Track }, options?: any) {
			 return TrackApiFp.trackUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackUpsertWithWhere(params: { where?: string; data?: Track }, options?: any) {
			 return TrackApiFp.trackUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * TrackGenreApi - fetch parameter creator
  */
 export const TrackGenreApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackGenreCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackGenres/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackGenreCreate(params: { data?: TrackGenre }, options?: any): FetchArgs {
		 const baseUrl = `/TrackGenres`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackGenreCreateChangeStreamGetTrackGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackGenres/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackGenreCreateChangeStreamPostTrackGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackGenres/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackGenreDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackGenreDeleteById');
		 }
		 const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackGenreExistsGetTrackGenresidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackGenreExistsGetTrackGenresidExists'
			 );
		 }
		 const baseUrl = `/TrackGenres/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackGenreExistsHeadTrackGenresid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackGenreExistsHeadTrackGenresid'
			 );
		 }
		 const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackGenreFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackGenres`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackGenreFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackGenreFindById');
		 }
		 const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackGenreFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackGenres/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackGenrePatchOrCreate(params: { data?: TrackGenre }, options?: any): FetchArgs {
		 const baseUrl = `/TrackGenres`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation genre.
	  * @param id TrackGenre id
	  * @param refresh
	  */
	 trackGenrePrototypeGetGenre(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackGenrePrototypeGetGenre');
		 }
		 const baseUrl = `/TrackGenres/{id}/genre`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackGenre id
	  * @param refresh
	  */
	 trackGenrePrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackGenrePrototypeGetTrack');
		 }
		 const baseUrl = `/TrackGenres/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackGenre id
	  * @param data An object of model property name/value pairs
	  */
	 trackGenrePrototypePatchAttributes(
		 params: { id: string; data?: TrackGenre },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackGenrePrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackGenreReplaceByIdPostTrackGenresidReplace(
		 params: { id: string; data?: TrackGenre },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackGenreReplaceByIdPostTrackGenresidReplace'
			 );
		 }
		 const baseUrl = `/TrackGenres/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackGenreReplaceByIdPutTrackGenresid(
		 params: { id: string; data?: TrackGenre },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackGenreReplaceByIdPutTrackGenresid'
			 );
		 }
		 const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(
		 params: { data?: TrackGenre },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackGenres/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackGenreReplaceOrCreatePutTrackGenres(params: { data?: TrackGenre }, options?: any): FetchArgs {
		 const baseUrl = `/TrackGenres`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackGenreUpdateAll(params: { where?: string; data?: TrackGenre }, options?: any): FetchArgs {
		 const baseUrl = `/TrackGenres/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackGenreUpsertWithWhere(
		 params: { where?: string; data?: TrackGenre },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackGenres/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * TrackGenreApi - functional programming interface
  */
 export const TrackGenreApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackGenreCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackGenreCreate(
		 params: { data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackGenreCreateChangeStreamGetTrackGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 TrackGenreApiFetchParamCreator.trackGenreCreateChangeStreamGetTrackGenresChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackGenreCreateChangeStreamPostTrackGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 TrackGenreApiFetchParamCreator.trackGenreCreateChangeStreamPostTrackGenresChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackGenreDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackGenreExistsGetTrackGenresidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreExistsGetTrackGenresidExists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackGenreExistsHeadTrackGenresid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreExistsHeadTrackGenresid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackGenreFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TrackGenre>> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackGenreFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackGenreFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackGenrePatchOrCreate(
		 params: { data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenrePatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation genre.
	  * @param id TrackGenre id
	  * @param refresh
	  */
	 trackGenrePrototypeGetGenre(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Genre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenrePrototypeGetGenre(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackGenre id
	  * @param refresh
	  */
	 trackGenrePrototypeGetTrack(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenrePrototypeGetTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackGenre id
	  * @param data An object of model property name/value pairs
	  */
	 trackGenrePrototypePatchAttributes(
		 params: { id: string; data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenrePrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackGenreReplaceByIdPostTrackGenresidReplace(
		 params: { id: string; data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreReplaceByIdPostTrackGenresidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackGenreReplaceByIdPutTrackGenresid(
		 params: { id: string; data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreReplaceByIdPutTrackGenresid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(
		 params: { data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs =
			 TrackGenreApiFetchParamCreator.trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackGenreReplaceOrCreatePutTrackGenres(
		 params: { data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreReplaceOrCreatePutTrackGenres(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackGenreUpdateAll(
		 params: { where?: string; data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackGenreUpsertWithWhere(
		 params: { where?: string; data?: TrackGenre },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackGenre> {
		 const fetchArgs = TrackGenreApiFetchParamCreator.trackGenreUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * TrackGenreApi - object-oriented interface
  */
 export class TrackGenreApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackGenreCount(params: { where?: string }, options?: any) {
		 return TrackGenreApiFp.trackGenreCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackGenreCreate(params: { data?: TrackGenre }, options?: any) {
		 return TrackGenreApiFp.trackGenreCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackGenreCreateChangeStreamGetTrackGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return TrackGenreApiFp.trackGenreCreateChangeStreamGetTrackGenresChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackGenreCreateChangeStreamPostTrackGenresChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return TrackGenreApiFp.trackGenreCreateChangeStreamPostTrackGenresChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackGenreDeleteById(params: { id: string }, options?: any) {
		 return TrackGenreApiFp.trackGenreDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackGenreExistsGetTrackGenresidExists(params: { id: string }, options?: any) {
		 return TrackGenreApiFp.trackGenreExistsGetTrackGenresidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackGenreExistsHeadTrackGenresid(params: { id: string }, options?: any) {
		 return TrackGenreApiFp.trackGenreExistsHeadTrackGenresid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackGenreFind(params: { filter?: string }, options?: any) {
		 return TrackGenreApiFp.trackGenreFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackGenreFindById(params: { id: string; filter?: string }, options?: any) {
		 return TrackGenreApiFp.trackGenreFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackGenreFindOne(params: { filter?: string }, options?: any) {
		 return TrackGenreApiFp.trackGenreFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackGenrePatchOrCreate(params: { data?: TrackGenre }, options?: any) {
		 return TrackGenreApiFp.trackGenrePatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation genre.
	  * @param id TrackGenre id
	  * @param refresh
	  */
	 trackGenrePrototypeGetGenre(params: { id: string; refresh?: boolean }, options?: any) {
		 return TrackGenreApiFp.trackGenrePrototypeGetGenre(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackGenre id
	  * @param refresh
	  */
	 trackGenrePrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
		 return TrackGenreApiFp.trackGenrePrototypeGetTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackGenre id
	  * @param data An object of model property name/value pairs
	  */
	 trackGenrePrototypePatchAttributes(params: { id: string; data?: TrackGenre }, options?: any) {
		 return TrackGenreApiFp.trackGenrePrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackGenreReplaceByIdPostTrackGenresidReplace(
		 params: { id: string; data?: TrackGenre },
		 options?: any
	 ) {
		 return TrackGenreApiFp.trackGenreReplaceByIdPostTrackGenresidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackGenreReplaceByIdPutTrackGenresid(params: { id: string; data?: TrackGenre }, options?: any) {
		 return TrackGenreApiFp.trackGenreReplaceByIdPutTrackGenresid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(
		 params: { data?: TrackGenre },
		 options?: any
	 ) {
		 return TrackGenreApiFp.trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackGenreReplaceOrCreatePutTrackGenres(params: { data?: TrackGenre }, options?: any) {
		 return TrackGenreApiFp.trackGenreReplaceOrCreatePutTrackGenres(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackGenreUpdateAll(params: { where?: string; data?: TrackGenre }, options?: any) {
		 return TrackGenreApiFp.trackGenreUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackGenreUpsertWithWhere(params: { where?: string; data?: TrackGenre }, options?: any) {
		 return TrackGenreApiFp.trackGenreUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * TrackGenreApi - factory interface
  */
 export const TrackGenreApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 trackGenreCount(params: { where?: string }, options?: any) {
			 return TrackGenreApiFp.trackGenreCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 trackGenreCreate(params: { data?: TrackGenre }, options?: any) {
			 return TrackGenreApiFp.trackGenreCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackGenreCreateChangeStreamGetTrackGenresChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return TrackGenreApiFp.trackGenreCreateChangeStreamGetTrackGenresChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackGenreCreateChangeStreamPostTrackGenresChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return TrackGenreApiFp.trackGenreCreateChangeStreamPostTrackGenresChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 trackGenreDeleteById(params: { id: string }, options?: any) {
			 return TrackGenreApiFp.trackGenreDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackGenreExistsGetTrackGenresidExists(params: { id: string }, options?: any) {
			 return TrackGenreApiFp.trackGenreExistsGetTrackGenresidExists(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackGenreExistsHeadTrackGenresid(params: { id: string }, options?: any) {
			 return TrackGenreApiFp.trackGenreExistsHeadTrackGenresid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackGenreFind(params: { filter?: string }, options?: any) {
			 return TrackGenreApiFp.trackGenreFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 trackGenreFindById(params: { id: string; filter?: string }, options?: any) {
			 return TrackGenreApiFp.trackGenreFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackGenreFindOne(params: { filter?: string }, options?: any) {
			 return TrackGenreApiFp.trackGenreFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackGenrePatchOrCreate(params: { data?: TrackGenre }, options?: any) {
			 return TrackGenreApiFp.trackGenrePatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation genre.
		  * @param id TrackGenre id
		  * @param refresh
		  */
		 trackGenrePrototypeGetGenre(params: { id: string; refresh?: boolean }, options?: any) {
			 return TrackGenreApiFp.trackGenrePrototypeGetGenre(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation track.
		  * @param id TrackGenre id
		  * @param refresh
		  */
		 trackGenrePrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
			 return TrackGenreApiFp.trackGenrePrototypeGetTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id TrackGenre id
		  * @param data An object of model property name/value pairs
		  */
		 trackGenrePrototypePatchAttributes(params: { id: string; data?: TrackGenre }, options?: any) {
			 return TrackGenreApiFp.trackGenrePrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackGenreReplaceByIdPostTrackGenresidReplace(
			 params: { id: string; data?: TrackGenre },
			 options?: any
		 ) {
			 return TrackGenreApiFp.trackGenreReplaceByIdPostTrackGenresidReplace(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackGenreReplaceByIdPutTrackGenresid(
			 params: { id: string; data?: TrackGenre },
			 options?: any
		 ) {
			 return TrackGenreApiFp.trackGenreReplaceByIdPutTrackGenresid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(
			 params: { data?: TrackGenre },
			 options?: any
		 ) {
			 return TrackGenreApiFp.trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackGenreReplaceOrCreatePutTrackGenres(params: { data?: TrackGenre }, options?: any) {
			 return TrackGenreApiFp.trackGenreReplaceOrCreatePutTrackGenres(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackGenreUpdateAll(params: { where?: string; data?: TrackGenre }, options?: any) {
			 return TrackGenreApiFp.trackGenreUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackGenreUpsertWithWhere(params: { where?: string; data?: TrackGenre }, options?: any) {
			 return TrackGenreApiFp.trackGenreUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * TrackInCartApi - fetch parameter creator
  */
 export const TrackInCartApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackInCartCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInCarts/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackInCartCreate(params: { data?: TrackInCart }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInCarts`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInCartCreateChangeStreamGetTrackInCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInCarts/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInCartCreateChangeStreamPostTrackInCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInCarts/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackInCartDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackInCartDeleteById');
		 }
		 const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInCartExistsGetTrackInCartsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInCartExistsGetTrackInCartsidExists'
			 );
		 }
		 const baseUrl = `/TrackInCarts/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInCartExistsHeadTrackInCartsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInCartExistsHeadTrackInCartsid'
			 );
		 }
		 const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInCartFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInCarts`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackInCartFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackInCartFindById');
		 }
		 const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInCartFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInCarts/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInCartPatchOrCreate(params: { data?: TrackInCart }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInCarts`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation cart.
	  * @param id TrackInCart id
	  * @param refresh
	  */
	 trackInCartPrototypeGetCart(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackInCartPrototypeGetCart');
		 }
		 const baseUrl = `/TrackInCarts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackInCart id
	  * @param refresh
	  */
	 trackInCartPrototypeGetTrack(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackInCartPrototypeGetTrack');
		 }
		 const baseUrl = `/TrackInCarts/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackInCart id
	  * @param data An object of model property name/value pairs
	  */
	 trackInCartPrototypePatchAttributes(
		 params: { id: string; data?: TrackInCart },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInCartPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInCartReplaceByIdPostTrackInCartsidReplace(
		 params: { id: string; data?: TrackInCart },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInCartReplaceByIdPostTrackInCartsidReplace'
			 );
		 }
		 const baseUrl = `/TrackInCarts/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInCartReplaceByIdPutTrackInCartsid(
		 params: { id: string; data?: TrackInCart },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInCartReplaceByIdPutTrackInCartsid'
			 );
		 }
		 const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(
		 params: { data?: TrackInCart },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInCarts/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInCartReplaceOrCreatePutTrackInCarts(
		 params: { data?: TrackInCart },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInCarts`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInCartUpdateAll(params: { where?: string; data?: TrackInCart }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInCarts/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInCartUpsertWithWhere(
		 params: { where?: string; data?: TrackInCart },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInCarts/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * TrackInCartApi - functional programming interface
  */
 export const TrackInCartApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackInCartCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackInCartCreate(
		 params: { data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInCartCreateChangeStreamGetTrackInCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 TrackInCartApiFetchParamCreator.trackInCartCreateChangeStreamGetTrackInCartsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInCartCreateChangeStreamPostTrackInCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 TrackInCartApiFetchParamCreator.trackInCartCreateChangeStreamPostTrackInCartsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackInCartDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInCartExistsGetTrackInCartsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartExistsGetTrackInCartsidExists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInCartExistsHeadTrackInCartsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartExistsHeadTrackInCartsid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInCartFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TrackInCart>> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackInCartFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInCartFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInCartPatchOrCreate(
		 params: { data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation cart.
	  * @param id TrackInCart id
	  * @param refresh
	  */
	 trackInCartPrototypeGetCart(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartPrototypeGetCart(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackInCart id
	  * @param refresh
	  */
	 trackInCartPrototypeGetTrack(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartPrototypeGetTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackInCart id
	  * @param data An object of model property name/value pairs
	  */
	 trackInCartPrototypePatchAttributes(
		 params: { id: string; data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInCartReplaceByIdPostTrackInCartsidReplace(
		 params: { id: string; data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs =
			 TrackInCartApiFetchParamCreator.trackInCartReplaceByIdPostTrackInCartsidReplace(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInCartReplaceByIdPutTrackInCartsid(
		 params: { id: string; data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartReplaceByIdPutTrackInCartsid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(
		 params: { data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs =
			 TrackInCartApiFetchParamCreator.trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInCartReplaceOrCreatePutTrackInCarts(
		 params: { data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartReplaceOrCreatePutTrackInCarts(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInCartUpdateAll(
		 params: { where?: string; data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInCartUpsertWithWhere(
		 params: { where?: string; data?: TrackInCart },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInCart> {
		 const fetchArgs = TrackInCartApiFetchParamCreator.trackInCartUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * TrackInCartApi - object-oriented interface
  */
 export class TrackInCartApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackInCartCount(params: { where?: string }, options?: any) {
		 return TrackInCartApiFp.trackInCartCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackInCartCreate(params: { data?: TrackInCart }, options?: any) {
		 return TrackInCartApiFp.trackInCartCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInCartCreateChangeStreamGetTrackInCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return TrackInCartApiFp.trackInCartCreateChangeStreamGetTrackInCartsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInCartCreateChangeStreamPostTrackInCartsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return TrackInCartApiFp.trackInCartCreateChangeStreamPostTrackInCartsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackInCartDeleteById(params: { id: string }, options?: any) {
		 return TrackInCartApiFp.trackInCartDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInCartExistsGetTrackInCartsidExists(params: { id: string }, options?: any) {
		 return TrackInCartApiFp.trackInCartExistsGetTrackInCartsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInCartExistsHeadTrackInCartsid(params: { id: string }, options?: any) {
		 return TrackInCartApiFp.trackInCartExistsHeadTrackInCartsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInCartFind(params: { filter?: string }, options?: any) {
		 return TrackInCartApiFp.trackInCartFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackInCartFindById(params: { id: string; filter?: string }, options?: any) {
		 return TrackInCartApiFp.trackInCartFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInCartFindOne(params: { filter?: string }, options?: any) {
		 return TrackInCartApiFp.trackInCartFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInCartPatchOrCreate(params: { data?: TrackInCart }, options?: any) {
		 return TrackInCartApiFp.trackInCartPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation cart.
	  * @param id TrackInCart id
	  * @param refresh
	  */
	 trackInCartPrototypeGetCart(params: { id: string; refresh?: boolean }, options?: any) {
		 return TrackInCartApiFp.trackInCartPrototypeGetCart(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackInCart id
	  * @param refresh
	  */
	 trackInCartPrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
		 return TrackInCartApiFp.trackInCartPrototypeGetTrack(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackInCart id
	  * @param data An object of model property name/value pairs
	  */
	 trackInCartPrototypePatchAttributes(params: { id: string; data?: TrackInCart }, options?: any) {
		 return TrackInCartApiFp.trackInCartPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInCartReplaceByIdPostTrackInCartsidReplace(
		 params: { id: string; data?: TrackInCart },
		 options?: any
	 ) {
		 return TrackInCartApiFp.trackInCartReplaceByIdPostTrackInCartsidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInCartReplaceByIdPutTrackInCartsid(
		 params: { id: string; data?: TrackInCart },
		 options?: any
	 ) {
		 return TrackInCartApiFp.trackInCartReplaceByIdPutTrackInCartsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(
		 params: { data?: TrackInCart },
		 options?: any
	 ) {
		 return TrackInCartApiFp.trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInCartReplaceOrCreatePutTrackInCarts(params: { data?: TrackInCart }, options?: any) {
		 return TrackInCartApiFp.trackInCartReplaceOrCreatePutTrackInCarts(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInCartUpdateAll(params: { where?: string; data?: TrackInCart }, options?: any) {
		 return TrackInCartApiFp.trackInCartUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInCartUpsertWithWhere(params: { where?: string; data?: TrackInCart }, options?: any) {
		 return TrackInCartApiFp.trackInCartUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * TrackInCartApi - factory interface
  */
 export const TrackInCartApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 trackInCartCount(params: { where?: string }, options?: any) {
			 return TrackInCartApiFp.trackInCartCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 trackInCartCreate(params: { data?: TrackInCart }, options?: any) {
			 return TrackInCartApiFp.trackInCartCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackInCartCreateChangeStreamGetTrackInCartsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return TrackInCartApiFp.trackInCartCreateChangeStreamGetTrackInCartsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackInCartCreateChangeStreamPostTrackInCartsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return TrackInCartApiFp.trackInCartCreateChangeStreamPostTrackInCartsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 trackInCartDeleteById(params: { id: string }, options?: any) {
			 return TrackInCartApiFp.trackInCartDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackInCartExistsGetTrackInCartsidExists(params: { id: string }, options?: any) {
			 return TrackInCartApiFp.trackInCartExistsGetTrackInCartsidExists(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackInCartExistsHeadTrackInCartsid(params: { id: string }, options?: any) {
			 return TrackInCartApiFp.trackInCartExistsHeadTrackInCartsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackInCartFind(params: { filter?: string }, options?: any) {
			 return TrackInCartApiFp.trackInCartFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 trackInCartFindById(params: { id: string; filter?: string }, options?: any) {
			 return TrackInCartApiFp.trackInCartFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackInCartFindOne(params: { filter?: string }, options?: any) {
			 return TrackInCartApiFp.trackInCartFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackInCartPatchOrCreate(params: { data?: TrackInCart }, options?: any) {
			 return TrackInCartApiFp.trackInCartPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation cart.
		  * @param id TrackInCart id
		  * @param refresh
		  */
		 trackInCartPrototypeGetCart(params: { id: string; refresh?: boolean }, options?: any) {
			 return TrackInCartApiFp.trackInCartPrototypeGetCart(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation track.
		  * @param id TrackInCart id
		  * @param refresh
		  */
		 trackInCartPrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
			 return TrackInCartApiFp.trackInCartPrototypeGetTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id TrackInCart id
		  * @param data An object of model property name/value pairs
		  */
		 trackInCartPrototypePatchAttributes(params: { id: string; data?: TrackInCart }, options?: any) {
			 return TrackInCartApiFp.trackInCartPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackInCartReplaceByIdPostTrackInCartsidReplace(
			 params: { id: string; data?: TrackInCart },
			 options?: any
		 ) {
			 return TrackInCartApiFp.trackInCartReplaceByIdPostTrackInCartsidReplace(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackInCartReplaceByIdPutTrackInCartsid(
			 params: { id: string; data?: TrackInCart },
			 options?: any
		 ) {
			 return TrackInCartApiFp.trackInCartReplaceByIdPutTrackInCartsid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(
			 params: { data?: TrackInCart },
			 options?: any
		 ) {
			 return TrackInCartApiFp.trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackInCartReplaceOrCreatePutTrackInCarts(params: { data?: TrackInCart }, options?: any) {
			 return TrackInCartApiFp.trackInCartReplaceOrCreatePutTrackInCarts(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackInCartUpdateAll(params: { where?: string; data?: TrackInCart }, options?: any) {
			 return TrackInCartApiFp.trackInCartUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackInCartUpsertWithWhere(params: { where?: string; data?: TrackInCart }, options?: any) {
			 return TrackInCartApiFp.trackInCartUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * TrackInPlaylistApi - fetch parameter creator
  */
 export const TrackInPlaylistApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackInPlaylistCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInPlaylists/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistCreate(params: { data?: TrackInPlaylist }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInPlaylists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInPlaylists/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInPlaylists/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackInPlaylistDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackInPlaylistDeleteById');
		 }
		 const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInPlaylistExistsGetTrackInPlaylistsidExists(
		 params: { id: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInPlaylistExistsGetTrackInPlaylistsidExists'
			 );
		 }
		 const baseUrl = `/TrackInPlaylists/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInPlaylistExistsHeadTrackInPlaylistsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInPlaylistExistsHeadTrackInPlaylistsid'
			 );
		 }
		 const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInPlaylistFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInPlaylists`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackInPlaylistFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackInPlaylistFindById');
		 }
		 const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInPlaylistFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInPlaylists/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistPatchOrCreate(params: { data?: TrackInPlaylist }, options?: any): FetchArgs {
		 const baseUrl = `/TrackInPlaylists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation playlist.
	  * @param id TrackInPlaylist id
	  * @param refresh
	  */
	 trackInPlaylistPrototypeGetPlaylist(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInPlaylistPrototypeGetPlaylist'
			 );
		 }
		 const baseUrl = `/TrackInPlaylists/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackInPlaylist id
	  * @param refresh
	  */
	 trackInPlaylistPrototypeGetTrack(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInPlaylistPrototypeGetTrack'
			 );
		 }
		 const baseUrl = `/TrackInPlaylists/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackInPlaylist id
	  * @param data An object of model property name/value pairs
	  */
	 trackInPlaylistPrototypePatchAttributes(
		 params: { id: string; data?: TrackInPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInPlaylistPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(
		 params: { id: string; data?: TrackInPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace'
			 );
		 }
		 const baseUrl = `/TrackInPlaylists/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceByIdPutTrackInPlaylistsid(
		 params: { id: string; data?: TrackInPlaylist },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackInPlaylistReplaceByIdPutTrackInPlaylistsid'
			 );
		 }
		 const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(
		 params: { data?: TrackInPlaylist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInPlaylists/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceOrCreatePutTrackInPlaylists(
		 params: { data?: TrackInPlaylist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInPlaylists`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInPlaylistUpdateAll(
		 params: { where?: string; data?: TrackInPlaylist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInPlaylists/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInPlaylistUpsertWithWhere(
		 params: { where?: string; data?: TrackInPlaylist },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackInPlaylists/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * TrackInPlaylistApi - functional programming interface
  */
 export const TrackInPlaylistApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackInPlaylistCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistCreate(
		 params: { data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 TrackInPlaylistApiFetchParamCreator.trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 TrackInPlaylistApiFetchParamCreator.trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackInPlaylistDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistDeleteById(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInPlaylistExistsGetTrackInPlaylistsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs =
			 TrackInPlaylistApiFetchParamCreator.trackInPlaylistExistsGetTrackInPlaylistsidExists(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInPlaylistExistsHeadTrackInPlaylistsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs =
			 TrackInPlaylistApiFetchParamCreator.trackInPlaylistExistsHeadTrackInPlaylistsid(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInPlaylistFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TrackInPlaylist>> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackInPlaylistFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInPlaylistFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistPatchOrCreate(
		 params: { data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistPatchOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation playlist.
	  * @param id TrackInPlaylist id
	  * @param refresh
	  */
	 trackInPlaylistPrototypeGetPlaylist(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Playlist> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistPrototypeGetPlaylist(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackInPlaylist id
	  * @param refresh
	  */
	 trackInPlaylistPrototypeGetTrack(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistPrototypeGetTrack(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackInPlaylist id
	  * @param data An object of model property name/value pairs
	  */
	 trackInPlaylistPrototypePatchAttributes(
		 params: { id: string; data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(
		 params: { id: string; data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs =
			 TrackInPlaylistApiFetchParamCreator.trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceByIdPutTrackInPlaylistsid(
		 params: { id: string; data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs =
			 TrackInPlaylistApiFetchParamCreator.trackInPlaylistReplaceByIdPutTrackInPlaylistsid(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(
		 params: { data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs =
			 TrackInPlaylistApiFetchParamCreator.trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceOrCreatePutTrackInPlaylists(
		 params: { data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs =
			 TrackInPlaylistApiFetchParamCreator.trackInPlaylistReplaceOrCreatePutTrackInPlaylists(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInPlaylistUpdateAll(
		 params: { where?: string; data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInPlaylistUpsertWithWhere(
		 params: { where?: string; data?: TrackInPlaylist },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackInPlaylist> {
		 const fetchArgs = TrackInPlaylistApiFetchParamCreator.trackInPlaylistUpsertWithWhere(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * TrackInPlaylistApi - object-oriented interface
  */
 export class TrackInPlaylistApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackInPlaylistCount(params: { where?: string }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistCreate(params: { data?: TrackInPlaylist }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return TrackInPlaylistApiFp.trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return TrackInPlaylistApiFp.trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackInPlaylistDeleteById(params: { id: string }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistDeleteById(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInPlaylistExistsGetTrackInPlaylistsidExists(params: { id: string }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistExistsGetTrackInPlaylistsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackInPlaylistExistsHeadTrackInPlaylistsid(params: { id: string }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistExistsHeadTrackInPlaylistsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInPlaylistFind(params: { filter?: string }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackInPlaylistFindById(params: { id: string; filter?: string }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackInPlaylistFindOne(params: { filter?: string }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistPatchOrCreate(params: { data?: TrackInPlaylist }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistPatchOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation playlist.
	  * @param id TrackInPlaylist id
	  * @param refresh
	  */
	 trackInPlaylistPrototypeGetPlaylist(params: { id: string; refresh?: boolean }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistPrototypeGetPlaylist(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackInPlaylist id
	  * @param refresh
	  */
	 trackInPlaylistPrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistPrototypeGetTrack(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackInPlaylist id
	  * @param data An object of model property name/value pairs
	  */
	 trackInPlaylistPrototypePatchAttributes(
		 params: { id: string; data?: TrackInPlaylist },
		 options?: any
	 ) {
		 return TrackInPlaylistApiFp.trackInPlaylistPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(
		 params: { id: string; data?: TrackInPlaylist },
		 options?: any
	 ) {
		 return TrackInPlaylistApiFp.trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceByIdPutTrackInPlaylistsid(
		 params: { id: string; data?: TrackInPlaylist },
		 options?: any
	 ) {
		 return TrackInPlaylistApiFp.trackInPlaylistReplaceByIdPutTrackInPlaylistsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(
		 params: { data?: TrackInPlaylist },
		 options?: any
	 ) {
		 return TrackInPlaylistApiFp.trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(
			 params,
			 options
		 )(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackInPlaylistReplaceOrCreatePutTrackInPlaylists(
		 params: { data?: TrackInPlaylist },
		 options?: any
	 ) {
		 return TrackInPlaylistApiFp.trackInPlaylistReplaceOrCreatePutTrackInPlaylists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInPlaylistUpdateAll(params: { where?: string; data?: TrackInPlaylist }, options?: any) {
		 return TrackInPlaylistApiFp.trackInPlaylistUpdateAll(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackInPlaylistUpsertWithWhere(
		 params: { where?: string; data?: TrackInPlaylist },
		 options?: any
	 ) {
		 return TrackInPlaylistApiFp.trackInPlaylistUpsertWithWhere(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
 }
 
 /**
  * TrackInPlaylistApi - factory interface
  */
 export const TrackInPlaylistApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 trackInPlaylistCount(params: { where?: string }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 trackInPlaylistCreate(params: { data?: TrackInPlaylist }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return TrackInPlaylistApiFp.trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return TrackInPlaylistApiFp.trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 trackInPlaylistDeleteById(params: { id: string }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackInPlaylistExistsGetTrackInPlaylistsidExists(params: { id: string }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistExistsGetTrackInPlaylistsidExists(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackInPlaylistExistsHeadTrackInPlaylistsid(params: { id: string }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistExistsHeadTrackInPlaylistsid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackInPlaylistFind(params: { filter?: string }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 trackInPlaylistFindById(params: { id: string; filter?: string }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackInPlaylistFindOne(params: { filter?: string }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackInPlaylistPatchOrCreate(params: { data?: TrackInPlaylist }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation playlist.
		  * @param id TrackInPlaylist id
		  * @param refresh
		  */
		 trackInPlaylistPrototypeGetPlaylist(params: { id: string; refresh?: boolean }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistPrototypeGetPlaylist(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation track.
		  * @param id TrackInPlaylist id
		  * @param refresh
		  */
		 trackInPlaylistPrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistPrototypeGetTrack(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id TrackInPlaylist id
		  * @param data An object of model property name/value pairs
		  */
		 trackInPlaylistPrototypePatchAttributes(
			 params: { id: string; data?: TrackInPlaylist },
			 options?: any
		 ) {
			 return TrackInPlaylistApiFp.trackInPlaylistPrototypePatchAttributes(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(
			 params: { id: string; data?: TrackInPlaylist },
			 options?: any
		 ) {
			 return TrackInPlaylistApiFp.trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackInPlaylistReplaceByIdPutTrackInPlaylistsid(
			 params: { id: string; data?: TrackInPlaylist },
			 options?: any
		 ) {
			 return TrackInPlaylistApiFp.trackInPlaylistReplaceByIdPutTrackInPlaylistsid(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(
			 params: { data?: TrackInPlaylist },
			 options?: any
		 ) {
			 return TrackInPlaylistApiFp.trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackInPlaylistReplaceOrCreatePutTrackInPlaylists(
			 params: { data?: TrackInPlaylist },
			 options?: any
		 ) {
			 return TrackInPlaylistApiFp.trackInPlaylistReplaceOrCreatePutTrackInPlaylists(
				 params,
				 options
			 )(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackInPlaylistUpdateAll(params: { where?: string; data?: TrackInPlaylist }, options?: any) {
			 return TrackInPlaylistApiFp.trackInPlaylistUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackInPlaylistUpsertWithWhere(
			 params: { where?: string; data?: TrackInPlaylist },
			 options?: any
		 ) {
			 return TrackInPlaylistApiFp.trackInPlaylistUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * TrackMoodApi - fetch parameter creator
  */
 export const TrackMoodApiFetchParamCreator = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackMoodCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackMoods/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackMoodCreate(params: { data?: TrackMood }, options?: any): FetchArgs {
		 const baseUrl = `/TrackMoods`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackMoodCreateChangeStreamGetTrackMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackMoods/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackMoodCreateChangeStreamPostTrackMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackMoods/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackMoodDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackMoodDeleteById');
		 }
		 const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackMoodExistsGetTrackMoodsidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackMoodExistsGetTrackMoodsidExists'
			 );
		 }
		 const baseUrl = `/TrackMoods/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackMoodExistsHeadTrackMoodsid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackMoodExistsHeadTrackMoodsid');
		 }
		 const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackMoodFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackMoods`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackMoodFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackMoodFindById');
		 }
		 const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackMoodFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/TrackMoods/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackMoodPatchOrCreate(params: { data?: TrackMood }, options?: any): FetchArgs {
		 const baseUrl = `/TrackMoods`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation mood.
	  * @param id TrackMood id
	  * @param refresh
	  */
	 trackMoodPrototypeGetMood(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackMoodPrototypeGetMood');
		 }
		 const baseUrl = `/TrackMoods/{id}/mood`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackMood id
	  * @param refresh
	  */
	 trackMoodPrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling trackMoodPrototypeGetTrack');
		 }
		 const baseUrl = `/TrackMoods/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 refresh: params['refresh'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackMood id
	  * @param data An object of model property name/value pairs
	  */
	 trackMoodPrototypePatchAttributes(
		 params: { id: string; data?: TrackMood },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackMoodPrototypePatchAttributes'
			 );
		 }
		 const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackMoodReplaceByIdPostTrackMoodsidReplace(
		 params: { id: string; data?: TrackMood },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackMoodReplaceByIdPostTrackMoodsidReplace'
			 );
		 }
		 const baseUrl = `/TrackMoods/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackMoodReplaceByIdPutTrackMoodsid(
		 params: { id: string; data?: TrackMood },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling trackMoodReplaceByIdPutTrackMoodsid'
			 );
		 }
		 const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(
		 params: { data?: TrackMood },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/TrackMoods/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackMoodReplaceOrCreatePutTrackMoods(params: { data?: TrackMood }, options?: any): FetchArgs {
		 const baseUrl = `/TrackMoods`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackMoodUpdateAll(params: { where?: string; data?: TrackMood }, options?: any): FetchArgs {
		 const baseUrl = `/TrackMoods/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackMoodUpsertWithWhere(params: { where?: string; data?: TrackMood }, options?: any): FetchArgs {
		 const baseUrl = `/TrackMoods/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * TrackMoodApi - functional programming interface
  */
 export const TrackMoodApiFp = {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackMoodCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackMoodCreate(
		 params: { data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackMoodCreateChangeStreamGetTrackMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 TrackMoodApiFetchParamCreator.trackMoodCreateChangeStreamGetTrackMoodsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackMoodCreateChangeStreamPostTrackMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs =
			 TrackMoodApiFetchParamCreator.trackMoodCreateChangeStreamPostTrackMoodsChangeStream(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackMoodDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackMoodExistsGetTrackMoodsidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodExistsGetTrackMoodsidExists(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackMoodExistsHeadTrackMoodsid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodExistsHeadTrackMoodsid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackMoodFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TrackMood>> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackMoodFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackMoodFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackMoodPatchOrCreate(
		 params: { data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation mood.
	  * @param id TrackMood id
	  * @param refresh
	  */
	 trackMoodPrototypeGetMood(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Mood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodPrototypeGetMood(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackMood id
	  * @param refresh
	  */
	 trackMoodPrototypeGetTrack(
		 params: { id: string; refresh?: boolean },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodPrototypeGetTrack(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackMood id
	  * @param data An object of model property name/value pairs
	  */
	 trackMoodPrototypePatchAttributes(
		 params: { id: string; data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodPrototypePatchAttributes(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackMoodReplaceByIdPostTrackMoodsidReplace(
		 params: { id: string; data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodReplaceByIdPostTrackMoodsidReplace(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackMoodReplaceByIdPutTrackMoodsid(
		 params: { id: string; data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodReplaceByIdPutTrackMoodsid(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(
		 params: { data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs =
			 TrackMoodApiFetchParamCreator.trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(
				 params,
				 options
			 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackMoodReplaceOrCreatePutTrackMoods(
		 params: { data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodReplaceOrCreatePutTrackMoods(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackMoodUpdateAll(
		 params: { where?: string; data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackMoodUpsertWithWhere(
		 params: { where?: string; data?: TrackMood },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<TrackMood> {
		 const fetchArgs = TrackMoodApiFetchParamCreator.trackMoodUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * TrackMoodApi - object-oriented interface
  */
 export class TrackMoodApi extends BaseAPI {
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 trackMoodCount(params: { where?: string }, options?: any) {
		 return TrackMoodApiFp.trackMoodCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 trackMoodCreate(params: { data?: TrackMood }, options?: any) {
		 return TrackMoodApiFp.trackMoodCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackMoodCreateChangeStreamGetTrackMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return TrackMoodApiFp.trackMoodCreateChangeStreamGetTrackMoodsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 trackMoodCreateChangeStreamPostTrackMoodsChangeStream(
		 params: { options?: string },
		 options?: any
	 ) {
		 return TrackMoodApiFp.trackMoodCreateChangeStreamPostTrackMoodsChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 trackMoodDeleteById(params: { id: string }, options?: any) {
		 return TrackMoodApiFp.trackMoodDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackMoodExistsGetTrackMoodsidExists(params: { id: string }, options?: any) {
		 return TrackMoodApiFp.trackMoodExistsGetTrackMoodsidExists(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 trackMoodExistsHeadTrackMoodsid(params: { id: string }, options?: any) {
		 return TrackMoodApiFp.trackMoodExistsHeadTrackMoodsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackMoodFind(params: { filter?: string }, options?: any) {
		 return TrackMoodApiFp.trackMoodFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 trackMoodFindById(params: { id: string; filter?: string }, options?: any) {
		 return TrackMoodApiFp.trackMoodFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 trackMoodFindOne(params: { filter?: string }, options?: any) {
		 return TrackMoodApiFp.trackMoodFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackMoodPatchOrCreate(params: { data?: TrackMood }, options?: any) {
		 return TrackMoodApiFp.trackMoodPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation mood.
	  * @param id TrackMood id
	  * @param refresh
	  */
	 trackMoodPrototypeGetMood(params: { id: string; refresh?: boolean }, options?: any) {
		 return TrackMoodApiFp.trackMoodPrototypeGetMood(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Fetches belongsTo relation track.
	  * @param id TrackMood id
	  * @param refresh
	  */
	 trackMoodPrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
		 return TrackMoodApiFp.trackMoodPrototypeGetTrack(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id TrackMood id
	  * @param data An object of model property name/value pairs
	  */
	 trackMoodPrototypePatchAttributes(params: { id: string; data?: TrackMood }, options?: any) {
		 return TrackMoodApiFp.trackMoodPrototypePatchAttributes(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackMoodReplaceByIdPostTrackMoodsidReplace(
		 params: { id: string; data?: TrackMood },
		 options?: any
	 ) {
		 return TrackMoodApiFp.trackMoodReplaceByIdPostTrackMoodsidReplace(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 trackMoodReplaceByIdPutTrackMoodsid(params: { id: string; data?: TrackMood }, options?: any) {
		 return TrackMoodApiFp.trackMoodReplaceByIdPutTrackMoodsid(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(
		 params: { data?: TrackMood },
		 options?: any
	 ) {
		 return TrackMoodApiFp.trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 trackMoodReplaceOrCreatePutTrackMoods(params: { data?: TrackMood }, options?: any) {
		 return TrackMoodApiFp.trackMoodReplaceOrCreatePutTrackMoods(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackMoodUpdateAll(params: { where?: string; data?: TrackMood }, options?: any) {
		 return TrackMoodApiFp.trackMoodUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 trackMoodUpsertWithWhere(params: { where?: string; data?: TrackMood }, options?: any) {
		 return TrackMoodApiFp.trackMoodUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * TrackMoodApi - factory interface
  */
 export const TrackMoodApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 trackMoodCount(params: { where?: string }, options?: any) {
			 return TrackMoodApiFp.trackMoodCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 trackMoodCreate(params: { data?: TrackMood }, options?: any) {
			 return TrackMoodApiFp.trackMoodCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackMoodCreateChangeStreamGetTrackMoodsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return TrackMoodApiFp.trackMoodCreateChangeStreamGetTrackMoodsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 trackMoodCreateChangeStreamPostTrackMoodsChangeStream(
			 params: { options?: string },
			 options?: any
		 ) {
			 return TrackMoodApiFp.trackMoodCreateChangeStreamPostTrackMoodsChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 trackMoodDeleteById(params: { id: string }, options?: any) {
			 return TrackMoodApiFp.trackMoodDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackMoodExistsGetTrackMoodsidExists(params: { id: string }, options?: any) {
			 return TrackMoodApiFp.trackMoodExistsGetTrackMoodsidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 trackMoodExistsHeadTrackMoodsid(params: { id: string }, options?: any) {
			 return TrackMoodApiFp.trackMoodExistsHeadTrackMoodsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackMoodFind(params: { filter?: string }, options?: any) {
			 return TrackMoodApiFp.trackMoodFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 trackMoodFindById(params: { id: string; filter?: string }, options?: any) {
			 return TrackMoodApiFp.trackMoodFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 trackMoodFindOne(params: { filter?: string }, options?: any) {
			 return TrackMoodApiFp.trackMoodFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackMoodPatchOrCreate(params: { data?: TrackMood }, options?: any) {
			 return TrackMoodApiFp.trackMoodPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation mood.
		  * @param id TrackMood id
		  * @param refresh
		  */
		 trackMoodPrototypeGetMood(params: { id: string; refresh?: boolean }, options?: any) {
			 return TrackMoodApiFp.trackMoodPrototypeGetMood(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Fetches belongsTo relation track.
		  * @param id TrackMood id
		  * @param refresh
		  */
		 trackMoodPrototypeGetTrack(params: { id: string; refresh?: boolean }, options?: any) {
			 return TrackMoodApiFp.trackMoodPrototypeGetTrack(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id TrackMood id
		  * @param data An object of model property name/value pairs
		  */
		 trackMoodPrototypePatchAttributes(params: { id: string; data?: TrackMood }, options?: any) {
			 return TrackMoodApiFp.trackMoodPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackMoodReplaceByIdPostTrackMoodsidReplace(
			 params: { id: string; data?: TrackMood },
			 options?: any
		 ) {
			 return TrackMoodApiFp.trackMoodReplaceByIdPostTrackMoodsidReplace(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 trackMoodReplaceByIdPutTrackMoodsid(params: { id: string; data?: TrackMood }, options?: any) {
			 return TrackMoodApiFp.trackMoodReplaceByIdPutTrackMoodsid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(
			 params: { data?: TrackMood },
			 options?: any
		 ) {
			 return TrackMoodApiFp.trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 trackMoodReplaceOrCreatePutTrackMoods(params: { data?: TrackMood }, options?: any) {
			 return TrackMoodApiFp.trackMoodReplaceOrCreatePutTrackMoods(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackMoodUpdateAll(params: { where?: string; data?: TrackMood }, options?: any) {
			 return TrackMoodApiFp.trackMoodUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 trackMoodUpsertWithWhere(params: { where?: string; data?: TrackMood }, options?: any) {
			 return TrackMoodApiFp.trackMoodUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 
 /**
  * UserApi - fetch parameter creator
  */
 export const UserApiFetchParamCreator = {
	 /**
	  *
	  * @summary Change a user's password.
	  * @param oldPassword
	  * @param newPassword
	  */
	 userChangePassword(
		 params: { oldPassword: string; newPassword: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "oldPassword" is set
		 if (params['oldPassword'] == null) {
			 throw new Error('Missing required parameter oldPassword when calling userChangePassword');
		 }
		 // verify required parameter "newPassword" is set
		 if (params['newPassword'] == null) {
			 throw new Error('Missing required parameter newPassword when calling userChangePassword');
		 }
		 const baseUrl = `/Users/change-password`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 oldPassword: params['oldPassword'],
			 newPassword: params['newPassword'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Confirm a user registration with identity verification token.
	  * @param uid
	  * @param token
	  * @param redirect
	  */
	 userConfirm(params: { uid: string; token: string; redirect?: string }, options?: any): FetchArgs {
		 // verify required parameter "uid" is set
		 if (params['uid'] == null) {
			 throw new Error('Missing required parameter uid when calling userConfirm');
		 }
		 // verify required parameter "token" is set
		 if (params['token'] == null) {
			 throw new Error('Missing required parameter token when calling userConfirm');
		 }
		 const baseUrl = `/Users/confirm`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 uid: params['uid'],
			 token: params['token'],
			 redirect: params['redirect'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 userCount(params: { where?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Users/count`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 userCreate(params: { data?: User }, options?: any): FetchArgs {
		 const baseUrl = `/Users`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 userCreateChangeStreamGetUsersChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Users/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 options: params['options'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 userCreateChangeStreamPostUsersChangeStream(
		 params: { options?: string },
		 options?: any
	 ): FetchArgs {
		 const baseUrl = `/Users/change-stream`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 options: params['options'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 userDeleteById(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userDeleteById');
		 }
		 const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 userExistsGetUsersidExists(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userExistsGetUsersidExists');
		 }
		 const baseUrl = `/Users/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 userExistsHeadUsersid(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userExistsHeadUsersid');
		 }
		 const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'HEAD' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 userFind(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Users`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 userFindById(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userFindById');
		 }
		 const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 userFindOne(params: { filter?: string }, options?: any): FetchArgs {
		 const baseUrl = `/Users/findOne`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Login a user with username/email and password.
	  * @param credentials
	  * @param include Related objects to include in the response. See the description of return value for more details.
	  */
	 userLogin(params: { credentials: any; include?: string }, options?: any): FetchArgs {
		 // verify required parameter "credentials" is set
		 if (params['credentials'] == null) {
			 throw new Error('Missing required parameter credentials when calling userLogin');
		 }
		 const baseUrl = `/Users/login`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 include: params['include'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['credentials']) {
			 fetchOptions.body = JSON.stringify(params['credentials'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Logout a user with access token.
	  */
	 userLogout(options?: any): FetchArgs {
		 const baseUrl = `/Users/logout`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 userPatchOrCreate(params: { data?: User }, options?: any): FetchArgs {
		 const baseUrl = `/Users`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Counts accessTokens of User.
	  * @param id User id
	  * @param where Criteria to match model instances
	  */
	 userPrototypeCountAccessTokens(params: { id: string; where?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userPrototypeCountAccessTokens');
		 }
		 const baseUrl = `/Users/{id}/accessTokens/count`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in accessTokens of this model.
	  * @param id User id
	  * @param data
	  */
	 userPrototypeCreateAccessTokens(
		 params: { id: string; data?: AccessToken },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userPrototypeCreateAccessTokens');
		 }
		 const baseUrl = `/Users/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Deletes all accessTokens of this model.
	  * @param id User id
	  */
	 userPrototypeDeleteAccessTokens(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userPrototypeDeleteAccessTokens');
		 }
		 const baseUrl = `/Users/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for accessTokens.
	  * @param id User id
	  * @param fk Foreign key for accessTokens
	  */
	 userPrototypeDestroyByIdAccessTokens(
		 params: { id: string; fk: string },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling userPrototypeDestroyByIdAccessTokens'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling userPrototypeDestroyByIdAccessTokens'
			 );
		 }
		 const baseUrl = `/Users/{id}/accessTokens/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for accessTokens.
	  * @param id User id
	  * @param fk Foreign key for accessTokens
	  */
	 userPrototypeFindByIdAccessTokens(params: { id: string; fk: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling userPrototypeFindByIdAccessTokens'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling userPrototypeFindByIdAccessTokens'
			 );
		 }
		 const baseUrl = `/Users/{id}/accessTokens/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Queries accessTokens of User.
	  * @param id User id
	  * @param filter
	  */
	 userPrototypeGetAccessTokens(params: { id: string; filter?: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userPrototypeGetAccessTokens');
		 }
		 const baseUrl = `/Users/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 filter: params['filter'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id User id
	  * @param data An object of model property name/value pairs
	  */
	 userPrototypePatchAttributes(params: { id: string; data?: User }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userPrototypePatchAttributes');
		 }
		 const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PATCH' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for accessTokens.
	  * @param id User id
	  * @param fk Foreign key for accessTokens
	  * @param data
	  */
	 userPrototypeUpdateByIdAccessTokens(
		 params: { id: string; fk: string; data?: AccessToken },
		 options?: any
	 ): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling userPrototypeUpdateByIdAccessTokens'
			 );
		 }
		 // verify required parameter "fk" is set
		 if (params['fk'] == null) {
			 throw new Error(
				 'Missing required parameter fk when calling userPrototypeUpdateByIdAccessTokens'
			 );
		 }
		 const baseUrl = `/Users/{id}/accessTokens/{fk}`
			 .replace(`{${'id'}}`, `${params['id']}`)
			 .replace(`{${'fk'}}`, `${params['fk']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Trigger user's identity verification with configured verifyOptions
	  * @param id User id
	  */
	 userPrototypeVerify(params: { id: string }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userPrototypeVerify');
		 }
		 const baseUrl = `/Users/{id}/verify`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 userReplaceByIdPostUsersidReplace(params: { id: string; data?: User }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error(
				 'Missing required parameter id when calling userReplaceByIdPostUsersidReplace'
			 );
		 }
		 const baseUrl = `/Users/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 userReplaceByIdPutUsersid(params: { id: string; data?: User }, options?: any): FetchArgs {
		 // verify required parameter "id" is set
		 if (params['id'] == null) {
			 throw new Error('Missing required parameter id when calling userReplaceByIdPutUsersid');
		 }
		 const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 userReplaceOrCreatePostUsersReplaceOrCreate(params: { data?: User }, options?: any): FetchArgs {
		 const baseUrl = `/Users/replaceOrCreate`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 userReplaceOrCreatePutUsers(params: { data?: User }, options?: any): FetchArgs {
		 const baseUrl = `/Users`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Reset password for a user with email.
	  * @param options
	  */
	 userResetPassword(params: { options: any }, options?: any): FetchArgs {
		 // verify required parameter "options" is set
		 if (params['options'] == null) {
			 throw new Error('Missing required parameter options when calling userResetPassword');
		 }
		 const baseUrl = `/Users/reset`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['options']) {
			 fetchOptions.body = JSON.stringify(params['options'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Reset user's password via a password-reset token.
	  * @param newPassword
	  */
	 userSetPassword(params: { newPassword: string }, options?: any): FetchArgs {
		 // verify required parameter "newPassword" is set
		 if (params['newPassword'] == null) {
			 throw new Error('Missing required parameter newPassword when calling userSetPassword');
		 }
		 const baseUrl = `/Users/reset-password`;
		 let urlObj = url.parse(baseUrl, true);
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
		 fetchOptions.body = querystring.stringify({
			 newPassword: params['newPassword'],
		 });
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 userUpdateAll(params: { where?: string; data?: User }, options?: any): FetchArgs {
		 const baseUrl = `/Users/update`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 userUpsertWithWhere(params: { where?: string; data?: User }, options?: any): FetchArgs {
		 const baseUrl = `/Users/upsertWithWhere`;
		 let urlObj = url.parse(baseUrl, true);
		 urlObj.query = assign({}, urlObj.query, {
			 where: params['where'],
		 });
		 let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);
 
		 let contentTypeHeader: Dictionary<string> = {};
		 contentTypeHeader = { 'Content-Type': 'application/json' };
		 if (params['data']) {
			 fetchOptions.body = JSON.stringify(params['data'] || {});
		 }
		 if (contentTypeHeader) {
			 fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
		 }
		 return {
			 url: url.format(urlObj),
			 options: fetchOptions,
		 };
	 },
 };
 
 /**
  * UserApi - functional programming interface
  */
 export const UserApiFp = {
	 /**
	  *
	  * @summary Change a user's password.
	  * @param oldPassword
	  * @param newPassword
	  */
	 userChangePassword(
		 params: { oldPassword: string; newPassword: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userChangePassword(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Confirm a user registration with identity verification token.
	  * @param uid
	  * @param token
	  * @param redirect
	  */
	 userConfirm(
		 params: { uid: string; token: string; redirect?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userConfirm(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 userCount(
		 params: { where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = UserApiFetchParamCreator.userCount(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 userCreate(
		 params: { data?: User },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 userCreateChangeStreamGetUsersChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userCreateChangeStreamGetUsersChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 userCreateChangeStreamPostUsersChangeStream(
		 params: { options?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userCreateChangeStreamPostUsersChangeStream(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 userDeleteById(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userDeleteById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 userExistsGetUsersidExists(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = UserApiFetchParamCreator.userExistsGetUsersidExists(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 userExistsHeadUsersid(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
		 const fetchArgs = UserApiFetchParamCreator.userExistsHeadUsersid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 userFind(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
		 const fetchArgs = UserApiFetchParamCreator.userFind(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 userFindById(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userFindById(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 userFindOne(
		 params: { filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userFindOne(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Login a user with username/email and password.
	  * @param credentials
	  * @param include Related objects to include in the response. See the description of return value for more details.
	  */
	 userLogin(
		 params: { credentials: any; include?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userLogin(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Logout a user with access token.
	  */
	 userLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userLogout(options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 userPatchOrCreate(
		 params: { data?: User },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userPatchOrCreate(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Counts accessTokens of User.
	  * @param id User id
	  * @param where Criteria to match model instances
	  */
	 userPrototypeCountAccessTokens(
		 params: { id: string; where?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
		 const fetchArgs = UserApiFetchParamCreator.userPrototypeCountAccessTokens(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Creates a new instance in accessTokens of this model.
	  * @param id User id
	  * @param data
	  */
	 userPrototypeCreateAccessTokens(
		 params: { id: string; data?: AccessToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
		 const fetchArgs = UserApiFetchParamCreator.userPrototypeCreateAccessTokens(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Deletes all accessTokens of this model.
	  * @param id User id
	  */
	 userPrototypeDeleteAccessTokens(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userPrototypeDeleteAccessTokens(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Delete a related item by id for accessTokens.
	  * @param id User id
	  * @param fk Foreign key for accessTokens
	  */
	 userPrototypeDestroyByIdAccessTokens(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userPrototypeDestroyByIdAccessTokens(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Find a related item by id for accessTokens.
	  * @param id User id
	  * @param fk Foreign key for accessTokens
	  */
	 userPrototypeFindByIdAccessTokens(
		 params: { id: string; fk: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
		 const fetchArgs = UserApiFetchParamCreator.userPrototypeFindByIdAccessTokens(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Queries accessTokens of User.
	  * @param id User id
	  * @param filter
	  */
	 userPrototypeGetAccessTokens(
		 params: { id: string; filter?: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccessToken>> {
		 const fetchArgs = UserApiFetchParamCreator.userPrototypeGetAccessTokens(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id User id
	  * @param data An object of model property name/value pairs
	  */
	 userPrototypePatchAttributes(
		 params: { id: string; data?: User },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userPrototypePatchAttributes(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update a related item by id for accessTokens.
	  * @param id User id
	  * @param fk Foreign key for accessTokens
	  * @param data
	  */
	 userPrototypeUpdateByIdAccessTokens(
		 params: { id: string; fk: string; data?: AccessToken },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
		 const fetchArgs = UserApiFetchParamCreator.userPrototypeUpdateByIdAccessTokens(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Trigger user's identity verification with configured verifyOptions
	  * @param id User id
	  */
	 userPrototypeVerify(
		 params: { id: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userPrototypeVerify(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 userReplaceByIdPostUsersidReplace(
		 params: { id: string; data?: User },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userReplaceByIdPostUsersidReplace(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 userReplaceByIdPutUsersid(
		 params: { id: string; data?: User },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userReplaceByIdPutUsersid(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 userReplaceOrCreatePostUsersReplaceOrCreate(
		 params: { data?: User },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userReplaceOrCreatePostUsersReplaceOrCreate(
			 params,
			 options
		 );
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 userReplaceOrCreatePutUsers(
		 params: { data?: User },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userReplaceOrCreatePutUsers(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Reset password for a user with email.
	  * @param options
	  */
	 userResetPassword(
		 params: { options: any },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userResetPassword(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Reset user's password via a password-reset token.
	  * @param newPassword
	  */
	 userSetPassword(
		 params: { newPassword: string },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
		 const fetchArgs = UserApiFetchParamCreator.userSetPassword(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response;
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 userUpdateAll(
		 params: { where?: string; data?: User },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
		 const fetchArgs = UserApiFetchParamCreator.userUpdateAll(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 userUpsertWithWhere(
		 params: { where?: string; data?: User },
		 options?: any
	 ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
		 const fetchArgs = UserApiFetchParamCreator.userUpsertWithWhere(params, options);
		 return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
			 return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
				 if (response.status >= 200 && response.status < 300) {
					 return response.json();
				 } else {
					 throw response;
				 }
			 });
		 };
	 },
 };
 
 /**
  * UserApi - object-oriented interface
  */
 export class UserApi extends BaseAPI {
	 /**
	  *
	  * @summary Change a user's password.
	  * @param oldPassword
	  * @param newPassword
	  */
	 userChangePassword(params: { oldPassword: string; newPassword: string }, options?: any) {
		 return UserApiFp.userChangePassword(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Confirm a user registration with identity verification token.
	  * @param uid
	  * @param token
	  * @param redirect
	  */
	 userConfirm(params: { uid: string; token: string; redirect?: string }, options?: any) {
		 return UserApiFp.userConfirm(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Count instances of the model matched by where from the data source.
	  * @param where Criteria to match model instances
	  */
	 userCount(params: { where?: string }, options?: any) {
		 return UserApiFp.userCount(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a new instance of the model and persist it into the data source.
	  * @param data Model instance data
	  */
	 userCreate(params: { data?: User }, options?: any) {
		 return UserApiFp.userCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 userCreateChangeStreamGetUsersChangeStream(params: { options?: string }, options?: any) {
		 return UserApiFp.userCreateChangeStreamGetUsersChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Create a change stream.
	  * @param options
	  */
	 userCreateChangeStreamPostUsersChangeStream(params: { options?: string }, options?: any) {
		 return UserApiFp.userCreateChangeStreamPostUsersChangeStream(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Delete a model instance by {{id}} from the data source.
	  * @param id Model id
	  */
	 userDeleteById(params: { id: string }, options?: any) {
		 return UserApiFp.userDeleteById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 userExistsGetUsersidExists(params: { id: string }, options?: any) {
		 return UserApiFp.userExistsGetUsersidExists(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Check whether a model instance exists in the data source.
	  * @param id Model id
	  */
	 userExistsHeadUsersid(params: { id: string }, options?: any) {
		 return UserApiFp.userExistsHeadUsersid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find all instances of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 userFind(params: { filter?: string }, options?: any) {
		 return UserApiFp.userFind(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find a model instance by {{id}} from the data source.
	  * @param id Model id
	  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
	  */
	 userFindById(params: { id: string; filter?: string }, options?: any) {
		 return UserApiFp.userFindById(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Find first instance of the model matched by filter from the data source.
	  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
	  */
	 userFindOne(params: { filter?: string }, options?: any) {
		 return UserApiFp.userFindOne(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Login a user with username/email and password.
	  * @param credentials
	  * @param include Related objects to include in the response. See the description of return value for more details.
	  */
	 userLogin(params: { credentials: any; include?: string }, options?: any) {
		 return UserApiFp.userLogin(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Logout a user with access token.
	  */
	 userLogout(options?: any) {
		 return UserApiFp.userLogout(options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 userPatchOrCreate(params: { data?: User }, options?: any) {
		 return UserApiFp.userPatchOrCreate(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Counts accessTokens of User.
	  * @param id User id
	  * @param where Criteria to match model instances
	  */
	 userPrototypeCountAccessTokens(params: { id: string; where?: string }, options?: any) {
		 return UserApiFp.userPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Creates a new instance in accessTokens of this model.
	  * @param id User id
	  * @param data
	  */
	 userPrototypeCreateAccessTokens(params: { id: string; data?: AccessToken }, options?: any) {
		 return UserApiFp.userPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Deletes all accessTokens of this model.
	  * @param id User id
	  */
	 userPrototypeDeleteAccessTokens(params: { id: string }, options?: any) {
		 return UserApiFp.userPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Delete a related item by id for accessTokens.
	  * @param id User id
	  * @param fk Foreign key for accessTokens
	  */
	 userPrototypeDestroyByIdAccessTokens(params: { id: string; fk: string }, options?: any) {
		 return UserApiFp.userPrototypeDestroyByIdAccessTokens(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Find a related item by id for accessTokens.
	  * @param id User id
	  * @param fk Foreign key for accessTokens
	  */
	 userPrototypeFindByIdAccessTokens(params: { id: string; fk: string }, options?: any) {
		 return UserApiFp.userPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Queries accessTokens of User.
	  * @param id User id
	  * @param filter
	  */
	 userPrototypeGetAccessTokens(params: { id: string; filter?: string }, options?: any) {
		 return UserApiFp.userPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Patch attributes for a model instance and persist it into the data source.
	  * @param id User id
	  * @param data An object of model property name/value pairs
	  */
	 userPrototypePatchAttributes(params: { id: string; data?: User }, options?: any) {
		 return UserApiFp.userPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update a related item by id for accessTokens.
	  * @param id User id
	  * @param fk Foreign key for accessTokens
	  * @param data
	  */
	 userPrototypeUpdateByIdAccessTokens(
		 params: { id: string; fk: string; data?: AccessToken },
		 options?: any
	 ) {
		 return UserApiFp.userPrototypeUpdateByIdAccessTokens(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Trigger user's identity verification with configured verifyOptions
	  * @param id User id
	  */
	 userPrototypeVerify(params: { id: string }, options?: any) {
		 return UserApiFp.userPrototypeVerify(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 userReplaceByIdPostUsersidReplace(params: { id: string; data?: User }, options?: any) {
		 return UserApiFp.userReplaceByIdPostUsersidReplace(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace attributes for a model instance and persist it into the data source.
	  * @param id Model id
	  * @param data Model instance data
	  */
	 userReplaceByIdPutUsersid(params: { id: string; data?: User }, options?: any) {
		 return UserApiFp.userReplaceByIdPutUsersid(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 userReplaceOrCreatePostUsersReplaceOrCreate(params: { data?: User }, options?: any) {
		 return UserApiFp.userReplaceOrCreatePostUsersReplaceOrCreate(params, options)(
			 this.fetch,
			 this.basePath
		 );
	 }
	 /**
	  *
	  * @summary Replace an existing model instance or insert a new one into the data source.
	  * @param data Model instance data
	  */
	 userReplaceOrCreatePutUsers(params: { data?: User }, options?: any) {
		 return UserApiFp.userReplaceOrCreatePutUsers(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Reset password for a user with email.
	  * @param options
	  */
	 userResetPassword(params: { options: any }, options?: any) {
		 return UserApiFp.userResetPassword(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Reset user's password via a password-reset token.
	  * @param newPassword
	  */
	 userSetPassword(params: { newPassword: string }, options?: any) {
		 return UserApiFp.userSetPassword(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update instances of the model matched by {{where}} from the data source.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 userUpdateAll(params: { where?: string; data?: User }, options?: any) {
		 return UserApiFp.userUpdateAll(params, options)(this.fetch, this.basePath);
	 }
	 /**
	  *
	  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
	  * @param where Criteria to match model instances
	  * @param data An object of model property name/value pairs
	  */
	 userUpsertWithWhere(params: { where?: string; data?: User }, options?: any) {
		 return UserApiFp.userUpsertWithWhere(params, options)(this.fetch, this.basePath);
	 }
 }
 
 /**
  * UserApi - factory interface
  */
 export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
	 return {
		 /**
		  *
		  * @summary Change a user's password.
		  * @param oldPassword
		  * @param newPassword
		  */
		 userChangePassword(params: { oldPassword: string; newPassword: string }, options?: any) {
			 return UserApiFp.userChangePassword(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Confirm a user registration with identity verification token.
		  * @param uid
		  * @param token
		  * @param redirect
		  */
		 userConfirm(params: { uid: string; token: string; redirect?: string }, options?: any) {
			 return UserApiFp.userConfirm(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Count instances of the model matched by where from the data source.
		  * @param where Criteria to match model instances
		  */
		 userCount(params: { where?: string }, options?: any) {
			 return UserApiFp.userCount(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a new instance of the model and persist it into the data source.
		  * @param data Model instance data
		  */
		 userCreate(params: { data?: User }, options?: any) {
			 return UserApiFp.userCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 userCreateChangeStreamGetUsersChangeStream(params: { options?: string }, options?: any) {
			 return UserApiFp.userCreateChangeStreamGetUsersChangeStream(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Create a change stream.
		  * @param options
		  */
		 userCreateChangeStreamPostUsersChangeStream(params: { options?: string }, options?: any) {
			 return UserApiFp.userCreateChangeStreamPostUsersChangeStream(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Delete a model instance by {{id}} from the data source.
		  * @param id Model id
		  */
		 userDeleteById(params: { id: string }, options?: any) {
			 return UserApiFp.userDeleteById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 userExistsGetUsersidExists(params: { id: string }, options?: any) {
			 return UserApiFp.userExistsGetUsersidExists(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Check whether a model instance exists in the data source.
		  * @param id Model id
		  */
		 userExistsHeadUsersid(params: { id: string }, options?: any) {
			 return UserApiFp.userExistsHeadUsersid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find all instances of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 userFind(params: { filter?: string }, options?: any) {
			 return UserApiFp.userFind(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a model instance by {{id}} from the data source.
		  * @param id Model id
		  * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
		  */
		 userFindById(params: { id: string; filter?: string }, options?: any) {
			 return UserApiFp.userFindById(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find first instance of the model matched by filter from the data source.
		  * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
		  */
		 userFindOne(params: { filter?: string }, options?: any) {
			 return UserApiFp.userFindOne(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Login a user with username/email and password.
		  * @param credentials
		  * @param include Related objects to include in the response. See the description of return value for more details.
		  */
		 userLogin(params: { credentials: any; include?: string }, options?: any) {
			 return UserApiFp.userLogin(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Logout a user with access token.
		  */
		 userLogout(options?: any) {
			 return UserApiFp.userLogout(options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 userPatchOrCreate(params: { data?: User }, options?: any) {
			 return UserApiFp.userPatchOrCreate(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Counts accessTokens of User.
		  * @param id User id
		  * @param where Criteria to match model instances
		  */
		 userPrototypeCountAccessTokens(params: { id: string; where?: string }, options?: any) {
			 return UserApiFp.userPrototypeCountAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Creates a new instance in accessTokens of this model.
		  * @param id User id
		  * @param data
		  */
		 userPrototypeCreateAccessTokens(params: { id: string; data?: AccessToken }, options?: any) {
			 return UserApiFp.userPrototypeCreateAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Deletes all accessTokens of this model.
		  * @param id User id
		  */
		 userPrototypeDeleteAccessTokens(params: { id: string }, options?: any) {
			 return UserApiFp.userPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Delete a related item by id for accessTokens.
		  * @param id User id
		  * @param fk Foreign key for accessTokens
		  */
		 userPrototypeDestroyByIdAccessTokens(params: { id: string; fk: string }, options?: any) {
			 return UserApiFp.userPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Find a related item by id for accessTokens.
		  * @param id User id
		  * @param fk Foreign key for accessTokens
		  */
		 userPrototypeFindByIdAccessTokens(params: { id: string; fk: string }, options?: any) {
			 return UserApiFp.userPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Queries accessTokens of User.
		  * @param id User id
		  * @param filter
		  */
		 userPrototypeGetAccessTokens(params: { id: string; filter?: string }, options?: any) {
			 return UserApiFp.userPrototypeGetAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Patch attributes for a model instance and persist it into the data source.
		  * @param id User id
		  * @param data An object of model property name/value pairs
		  */
		 userPrototypePatchAttributes(params: { id: string; data?: User }, options?: any) {
			 return UserApiFp.userPrototypePatchAttributes(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update a related item by id for accessTokens.
		  * @param id User id
		  * @param fk Foreign key for accessTokens
		  * @param data
		  */
		 userPrototypeUpdateByIdAccessTokens(
			 params: { id: string; fk: string; data?: AccessToken },
			 options?: any
		 ) {
			 return UserApiFp.userPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Trigger user's identity verification with configured verifyOptions
		  * @param id User id
		  */
		 userPrototypeVerify(params: { id: string }, options?: any) {
			 return UserApiFp.userPrototypeVerify(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 userReplaceByIdPostUsersidReplace(params: { id: string; data?: User }, options?: any) {
			 return UserApiFp.userReplaceByIdPostUsersidReplace(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace attributes for a model instance and persist it into the data source.
		  * @param id Model id
		  * @param data Model instance data
		  */
		 userReplaceByIdPutUsersid(params: { id: string; data?: User }, options?: any) {
			 return UserApiFp.userReplaceByIdPutUsersid(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 userReplaceOrCreatePostUsersReplaceOrCreate(params: { data?: User }, options?: any) {
			 return UserApiFp.userReplaceOrCreatePostUsersReplaceOrCreate(params, options)(
				 fetch,
				 basePath
			 );
		 },
		 /**
		  *
		  * @summary Replace an existing model instance or insert a new one into the data source.
		  * @param data Model instance data
		  */
		 userReplaceOrCreatePutUsers(params: { data?: User }, options?: any) {
			 return UserApiFp.userReplaceOrCreatePutUsers(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Reset password for a user with email.
		  * @param options
		  */
		 userResetPassword(params: { options: any }, options?: any) {
			 return UserApiFp.userResetPassword(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Reset user's password via a password-reset token.
		  * @param newPassword
		  */
		 userSetPassword(params: { newPassword: string }, options?: any) {
			 return UserApiFp.userSetPassword(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update instances of the model matched by {{where}} from the data source.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 userUpdateAll(params: { where?: string; data?: User }, options?: any) {
			 return UserApiFp.userUpdateAll(params, options)(fetch, basePath);
		 },
		 /**
		  *
		  * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
		  * @param where Criteria to match model instances
		  * @param data An object of model property name/value pairs
		  */
		 userUpsertWithWhere(params: { where?: string; data?: User }, options?: any) {
			 return UserApiFp.userUpsertWithWhere(params, options)(fetch, basePath);
		 },
	 };
 };
 